'use strict';

var pixi_js = require('pixi.js');
var typedSignals = require('typed-signals');
var view = require('./utils/helpers/view.js');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const SECURE_CHARACTER = "*";
class Input extends pixi_js.Container {
  /**
   * Creates an input.
   * @param { number } options - Options object to use.
   * @param { Sprite | Graphics | Texture | string } options.bg - Background of the Input.
   * <br> Can be a string (name of texture) or an instance of Texture, Sprite or Graphics.
   * <br> If you want to use NineSliceSprite, you have to pass a text (name of texture)
   * or an instance of Texture as a parameter.
   * @param { PixiTextStyle } options.textStyle - Text style of the Input.
   * @param { string } options.placeholder - Placeholder of the Input.
   * @param { string } options.value - Value of the Input.
   * @param { number } options.maxLength - Max length of the Input.
   * @param { 'left' | 'center' | 'right' } options.align - Align of the Input.
   * @param { Padding } options.padding - Padding of the Input.
   * @param { number } options.padding.top - Top padding of the Input.
   * @param { number } options.padding.right - Right padding of the Input.
   * @param { number } options.padding.bottom - Bottom padding of the Input.
   * @param { number } options.padding.left - Left padding of the Input.
   * @param { boolean } options.cleanOnFocus - Clean Input on focus.
   * @param { boolean } options.addMask - Add mask to the Input text, so it is cut off when it does not fit.
   * @param { Array } options.nineSliceSprite - NineSliceSprite values for bg and fill ([number, number, number, number]).
   * <br> <b>!!! IMPORTANT:</b> To make it work, you have to pass a texture name or texture instance as a bg parameter.
   */
  constructor(options) {
    super();
    __publicField(this, "_bg");
    __publicField(this, "inputMask");
    __publicField(this, "_cursor");
    __publicField(this, "_value", "");
    __publicField(this, "_secure");
    __publicField(this, "inputField");
    __publicField(this, "placeholder");
    __publicField(this, "editing", false);
    __publicField(this, "tick", 0);
    __publicField(this, "lastInputData");
    __publicField(this, "activation", false);
    __publicField(this, "options");
    __publicField(this, "input");
    __publicField(this, "handleActivationBinding", this.handleActivation.bind(this));
    __publicField(this, "onKeyUpBinding", this.onKeyUp.bind(this));
    __publicField(this, "stopEditingBinding", this.stopEditing.bind(this));
    __publicField(this, "onInputBinding", this.onInput.bind(this));
    /** Fires when input loses focus. */
    __publicField(this, "onEnter");
    /** Fires every time input string is changed. */
    __publicField(this, "onChange");
    /** Top side padding */
    __publicField(this, "paddingTop", 0);
    /** Right side padding */
    __publicField(this, "paddingRight", 0);
    /** Bottom side padding */
    __publicField(this, "paddingBottom", 0);
    /** Left side padding */
    __publicField(this, "paddingLeft", 0);
    this.options = options;
    this.options = options;
    this.padding = options.padding;
    this._secure = options.secure ?? false;
    this.cursor = "text";
    this.interactive = true;
    this.on("pointertap", () => {
      this.activation = true;
      pixi_js.isMobile.any && this.handleActivation();
    });
    if (pixi_js.isMobile.any) {
      window.addEventListener("touchstart", this.handleActivationBinding);
    } else if (!pixi_js.isMobile.any) {
      window.addEventListener("click", this.handleActivationBinding);
      window.addEventListener("keyup", this.onKeyUpBinding);
      window.addEventListener("input", this.onInputBinding);
    }
    this.onEnter = new typedSignals.Signal();
    this.onChange = new typedSignals.Signal();
    pixi_js.Ticker.shared.add((ticker) => this.update(ticker.deltaTime));
    if (options.bg) {
      this.bg = options.bg;
    } else {
      console.error("Input: bg is not defined, please define it.");
    }
  }
  onInput(e) {
    this.lastInputData = e.data;
  }
  onKeyUp(e) {
    const key = e.key;
    if (key === "Backspace") {
      this._delete();
    } else if (key === "Escape" || key === "Enter") {
      this.stopEditing();
    } else if (key.length === 1) {
      this._add(key);
    } else if (this.lastInputData && this.lastInputData.length === 1) {
      this._add(this.lastInputData);
    }
  }
  init() {
    const options = this.options;
    const defaultTextStyle = {
      fill: 0,
      align: "center"
    };
    this.options.textStyle = options.textStyle ?? defaultTextStyle;
    this.options.TextClass = options.TextClass ?? pixi_js.Text;
    const textStyle = { ...defaultTextStyle, ...options.textStyle };
    const colorSource = pixi_js.Color.isColorLike(this.options.textStyle.fill) ? this.options.textStyle.fill : 0;
    this.inputField = new this.options.TextClass({
      text: "",
      style: textStyle
    });
    this._cursor = new pixi_js.Sprite(pixi_js.Texture.WHITE);
    this._cursor.tint = colorSource;
    this._cursor.anchor.set(0.5);
    this._cursor.width = 2;
    this._cursor.height = this.inputField.height * 0.8;
    this._cursor.alpha = 0;
    this.placeholder = new this.options.TextClass({
      text: options.placeholder,
      style: textStyle ?? defaultTextStyle
    });
    this.placeholder.visible = !!options.placeholder;
    this.addChild(this.inputField, this.placeholder, this._cursor);
    this.value = options.value ?? "";
    this.align();
  }
  set bg(bg) {
    if (this._bg) {
      this._bg.destroy();
    }
    if (this.options?.nineSliceSprite) {
      if (typeof bg === "string") {
        this._bg = new pixi_js.NineSliceSprite({
          texture: pixi_js.Texture.from(bg),
          leftWidth: this.options.nineSliceSprite[0],
          topHeight: this.options.nineSliceSprite[1],
          rightWidth: this.options.nineSliceSprite[2],
          bottomHeight: this.options.nineSliceSprite[3]
        });
      } else if (bg instanceof pixi_js.Texture) {
        this._bg = new pixi_js.NineSliceSprite({
          texture: bg,
          leftWidth: this.options.nineSliceSprite[0],
          topHeight: this.options.nineSliceSprite[1],
          rightWidth: this.options.nineSliceSprite[2],
          bottomHeight: this.options.nineSliceSprite[3]
        });
      } else {
        console.warn(`NineSliceSprite can not be used with views set as Container.
                    Pass the texture or texture name as instead of the Container extended instance.`);
      }
    }
    if (!this._bg) {
      this._bg = view.getView(bg);
    }
    this._bg.cursor = "text";
    this._bg.interactive = true;
    this.addChildAt(this._bg, 0);
    if (!this.inputField) {
      this.init();
    }
    if (this.options.addMask) {
      this.createInputMask(bg);
    }
  }
  get bg() {
    return this._bg;
  }
  _add(key) {
    if (!this.editing) {
      return;
    }
    if (this.options.maxLength && this.value.length >= this.options.maxLength) {
      return;
    }
    this.value = this.value + key;
    this.onChange.emit(this.value);
  }
  _delete() {
    const length = this.value.length;
    if (!this.editing || length === 0) return;
    this.value = this.value.substring(0, length - 1);
    this.onChange.emit(this.value);
  }
  _startEditing() {
    if (this.options.cleanOnFocus) {
      this.value = "";
    }
    this.tick = 0;
    this.editing = true;
    this.placeholder.visible = false;
    this._cursor.alpha = 1;
    if (pixi_js.isMobile.any) {
      this.createInputField();
    }
    this.align();
  }
  createInputField() {
    if (this.input) {
      this.input.removeEventListener("blur", this.stopEditingBinding);
      this.input.removeEventListener("keyup", this.onKeyUpBinding);
      this.input.removeEventListener("input", this.onInputBinding);
      this.input?.blur();
      this.input?.remove();
      this.input = null;
    }
    const input = document.createElement("input");
    document.body.appendChild(input);
    input.style.position = "fixed";
    input.style.left = `${this.getGlobalPosition().x}px`;
    input.style.top = `${this.getGlobalPosition().y}px`;
    input.style.opacity = "0.0000001";
    input.style.width = `${this._bg.width}px`;
    input.style.height = `${this._bg.height}px`;
    input.style.border = "none";
    input.style.outline = "none";
    input.style.background = "white";
    if (pixi_js.isMobile.android.device) {
      setTimeout(() => {
        input.focus();
        input.click();
      }, 100);
    } else {
      input.focus();
      input.click();
    }
    input.addEventListener("blur", this.stopEditingBinding);
    input.addEventListener("keyup", this.onKeyUpBinding);
    input.addEventListener("input", this.onInputBinding);
    this.input = input;
    this.align();
  }
  handleActivation() {
    this.stopEditing();
    if (this.activation) {
      this._startEditing();
      this.activation = false;
    }
  }
  stopEditing() {
    if (!this.editing) return;
    this._cursor.alpha = 0;
    this.editing = false;
    if (this.inputField.text === "") {
      this.placeholder.visible = true;
    }
    if (this.value.length === 0) this.placeholder.visible = true;
    if (pixi_js.isMobile.any) {
      this.input?.blur();
      this.input?.remove();
      this.input = null;
    }
    this.align();
    this.onEnter.emit(this.value);
  }
  update(dt) {
    if (!this.editing) return;
    this.tick += dt * 0.1;
    this._cursor.alpha = Math.round(Math.sin(this.tick) * 0.5 + 0.5);
  }
  align() {
    if (!this._bg) return;
    const align = this.getAlign();
    this.inputField.anchor.set(align, 0.5);
    this.inputField.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.inputField.y = this._bg.height / 2 + this.paddingTop - this.paddingBottom;
    this.placeholder.anchor.set(align, 0.5);
    this.placeholder.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.placeholder.y = this._bg.height / 2;
    this._cursor.x = this.getCursorPosX();
    this._cursor.y = this.inputField.y;
  }
  getAlign() {
    const maxWidth = this._bg.width * 0.95;
    const paddings = this.paddingLeft + this.paddingRight - 10;
    const isOverflowed = this.inputField.width + paddings > maxWidth;
    if (isOverflowed) {
      return this.editing ? 1 : 0;
    }
    switch (this.options.align) {
      case "left":
        return 0;
      case "center":
        return 0.5;
      case "right":
        return 1;
      default:
        return 0;
    }
  }
  getCursorPosX() {
    const align = this.getAlign();
    switch (align) {
      case 0:
        return this.inputField.x + this.inputField.width;
      case 0.5:
        return this.inputField.x + this.inputField.width * 0.5;
      case 1:
        return this.inputField.x;
      default:
        return 0;
    }
  }
  /** Sets the input text. */
  set value(text) {
    const textLength = text.length;
    this._value = text;
    this.inputField.text = this.secure ? SECURE_CHARACTER.repeat(textLength) : text;
    if (textLength !== 0) {
      this.placeholder.visible = false;
    } else {
      this.placeholder.visible = !this.editing;
    }
    this.align();
  }
  /** Return text of the input. */
  get value() {
    return this._value;
  }
  set secure(val) {
    this._secure = val;
    this.value = this._value;
  }
  get secure() {
    return this._secure;
  }
  /**
   * Set paddings
   * @param value - number, array of 4 numbers or object with keys: top, right, bottom, left
   * or: [top, right, bottom, left]
   * or: [top&bottom, right&left]
   * or: {
   *  left: 10,
   *  right: 10,
   *  top: 10,
   *  bottom: 10,
   * }
   */
  set padding(value) {
    if (typeof value === "number") {
      this.paddingTop = value;
      this.paddingRight = value;
      this.paddingBottom = value;
      this.paddingLeft = value;
    }
    if (Array.isArray(value)) {
      this.paddingTop = value[0] ?? 0;
      this.paddingRight = value[1] ?? value[0] ?? 0;
      this.paddingBottom = value[2] ?? value[0] ?? 0;
      this.paddingLeft = value[3] ?? value[1] ?? value[0] ?? 0;
    } else if (typeof value === "object") {
      this.paddingTop = value.top ?? 0;
      this.paddingRight = value.right ?? 0;
      this.paddingBottom = value.bottom ?? 0;
      this.paddingLeft = value.left ?? 0;
    }
  }
  // Return array of paddings [top, right, bottom, left]
  get padding() {
    return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
  }
  destroy(options) {
    this.off("pointertap");
    if (pixi_js.isMobile.any) {
      window.removeEventListener("touchstart", this.handleActivationBinding);
    } else if (!pixi_js.isMobile.any) {
      window.removeEventListener("click", this.handleActivationBinding);
      window.removeEventListener("keyup", this.onKeyUpBinding);
      window.removeEventListener("input", this.onInputBinding);
    }
    super.destroy(options);
  }
  /**
   * Sets width of a Input.
   * If nineSliceSprite is set, then width will be set to nineSliceSprite.
   * If nineSliceSprite is not set, then width will control components width as Container.
   * @param width - Width value.
   */
  set width(width) {
    if (this.options?.nineSliceSprite) {
      if (this._bg) {
        this._bg.width = width;
      }
      this.updateInputMaskSize();
      this.align();
    } else {
      super.width = width;
    }
  }
  /** Gets width of Input. */
  get width() {
    return super.width;
  }
  /**
   * Sets height of a Input.
   * If nineSliceSprite is set, then height will be set to nineSliceSprite.
   * If nineSliceSprite is not set, then height will control components height as Container.
   * @param height - Height value.
   */
  set height(height) {
    if (this.options?.nineSliceSprite) {
      if (this._bg) {
        this._bg.height = height;
      }
      this.updateInputMaskSize();
      this.align();
    } else {
      super.height = height;
    }
  }
  /** Gets height of Input. */
  get height() {
    return super.height;
  }
  setSize(value, height) {
    if (this.options?.nineSliceSprite) {
      if (this._bg) {
        this._bg.setSize(value, height);
      }
      this.updateInputMaskSize();
      this.align();
    } else {
      super.setSize(value, height);
    }
  }
  createInputMask(bg) {
    if (this.inputMask) {
      this.inputField.mask = null;
      this._cursor.mask = null;
      this.inputMask.destroy();
    }
    if (this.options?.nineSliceSprite && typeof bg === "string") {
      this.inputMask = new pixi_js.NineSliceSprite({
        texture: pixi_js.Texture.from(bg),
        leftWidth: this.options.nineSliceSprite[0],
        topHeight: this.options.nineSliceSprite[1],
        rightWidth: this.options.nineSliceSprite[2],
        bottomHeight: this.options.nineSliceSprite[3]
      });
    } else if (bg instanceof pixi_js.Sprite) {
      this.inputMask = new pixi_js.Sprite(bg.texture);
    } else if (bg instanceof pixi_js.Graphics) {
      this.inputMask = bg.clone(true);
    } else {
      this.inputMask = view.getView(bg);
    }
    this.inputField.mask = this.inputMask;
    this._cursor.mask = this.inputMask;
    this.updateInputMaskSize();
    this.addChildAt(this.inputMask, 0);
  }
  updateInputMaskSize() {
    if (!this.inputMask || !this._bg) return;
    this.inputMask.setSize(
      this._bg.width - this.paddingLeft - this.paddingRight,
      this._bg.height - this.paddingTop - this.paddingBottom
    );
    this.inputMask.position.set(this.paddingLeft, this.paddingTop);
  }
}

exports.Input = Input;
//# sourceMappingURL=Input.js.map
