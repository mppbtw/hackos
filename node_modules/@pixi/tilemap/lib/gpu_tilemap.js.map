{"version":3,"file":"gpu_tilemap.js","sources":["../src/gpu_tilemap.ts"],"sourcesContent":["import { BindGroup, ExtensionType, GpuProgram, Shader } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nconst gpu_tilemap_vertex = `\nstruct GlobalUniforms {\n  uProjectionMatrix:mat3x3f,\n  uWorldTransformMatrix:mat3x3f,\n  uWorldColorAlpha: vec4f,\n  uResolution: vec2f,\n}\n\nstruct TilemapUniforms {\n  u_proj_trans:mat3x3f,\n  u_anim_frame:vec2f\n}\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\n\nstruct VSOutput {\n  @builtin(position) vPosition: vec4f,\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32\n};\n\n@vertex\nfn mainVert(\n   @location(6) aVertexPosition: vec2f,\n   @location(4) aTextureCoord: vec2f,\n   @location(3) aFrame: vec4f,\n   @location(1) aAnim: vec2f,\n   @location(2) aAnimDivisor: f32,\n   @location(5) aTextureId: i32,\n   @location(0) aAlpha: f32,\n ) -> VSOutput {\n\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  var animCount = floor((aAnim + 0.5) / 2048.0);\n  var animFrameOffset = aAnim - animCount * 2048.0;\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\n  var loop_num = floor((currentFrame + 0.5) / animCount);\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n  var vTextureCoord = aTextureCoord + animOffset;\n  var vFrame = aFrame + vec4(animOffset, animOffset);\n\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aAlpha);\n};\n`;\n\nconst gpu_tilemap_fragment = `\n//include_textures\n\n@fragment\nfn mainFrag(\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32,\n  ) -> @location(0) vec4f {\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\n  return color * vAlpha;\n};\n`;\n\nexport class GpuTilemapAdaptor extends TilemapAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'tilemap',\n    } as const;\n\n    _shader: Shader = null;\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\n    bind_group: BindGroup = null;\n\n    destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\n    {\n        const renderer = pipe.renderer;\n        const shader = this._shader;\n        // GPU..\n\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n        shader.groups[1] = tilemap.getTileset().getBindGroup();\n        shader.groups[2] = this.bind_group;\n\n        renderer.encoder.draw({\n            geometry: tilemap.vb,\n            shader,\n            state: tilemap.state,\n            size: tilemap.rects_count * 6\n        });\n        // TODO: does it need groups?\n    }\n\n    init(): void\n    {\n        this._shader = new Shader({\n            gpuProgram: GpuProgram.from({\n                vertex: { source: gpu_tilemap_vertex, entryPoint: 'mainVert' },\n                fragment: {\n                    source: gpu_tilemap_fragment\n                        .replace('//include_textures', TileTextureArray.generate_gpu_textures(this.max_textures))\n                },\n            })\n        });\n\n        this.bind_group = new BindGroup({\n            ut: this.pipe_uniforms\n        });\n    }\n}\n"],"names":["TilemapAdaptor","settings","Shader","GpuProgram","TileTextureArray","BindGroup","ExtensionType"],"mappings":";;;;;;;;;;;;;AAMA,MAAM,kBAAqB,GAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA,CAAA;AAgD3B,MAAM,oBAAuB,GAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA,CAAA;AAmBtB,MAAM,0BAA0BA,0BACvC,CAAA;AAAA,EADO,WAAA,GAAA;AAAA,IAAA,KAAA,CAAA,GAAA,SAAA,CAAA,CAAA;AASH,IAAkB,aAAA,CAAA,IAAA,EAAA,SAAA,EAAA,IAAA,CAAA,CAAA;AAClB,IAAA,aAAA,CAAA,IAAA,EAAA,cAAA,EAAuBC,iBAAS,CAAA,oBAAA,CAAA,CAAA;AAChC,IAAwB,aAAA,CAAA,IAAA,EAAA,YAAA,EAAA,IAAA,CAAA,CAAA;AAAA,GAAA;AAAA,EAExB,OACA,GAAA;AACI,IAAK,IAAA,CAAA,OAAA,CAAQ,QAAQ,IAAI,CAAA,CAAA;AACzB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,GACnB;AAAA,EAEA,OAAA,CAAQ,MAAmB,OAC3B,EAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA,CAAA;AACtB,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AAGpB,IAAA,MAAA,CAAO,MAAO,CAAA,CAAC,CAAI,GAAA,QAAA,CAAS,cAAe,CAAA,SAAA,CAAA;AAC3C,IAAA,MAAA,CAAO,OAAO,CAAC,CAAA,GAAI,OAAQ,CAAA,UAAA,GAAa,YAAa,EAAA,CAAA;AACrD,IAAO,MAAA,CAAA,MAAA,CAAO,CAAC,CAAA,GAAI,IAAK,CAAA,UAAA,CAAA;AAExB,IAAA,QAAA,CAAS,QAAQ,IAAK,CAAA;AAAA,MAClB,UAAU,OAAQ,CAAA,EAAA;AAAA,MAClB,MAAA;AAAA,MACA,OAAO,OAAQ,CAAA,KAAA;AAAA,MACf,IAAA,EAAM,QAAQ,WAAc,GAAA,CAAA;AAAA,KAC/B,CAAA,CAAA;AAAA,GAEL;AAAA,EAEA,IACA,GAAA;AACI,IAAK,IAAA,CAAA,OAAA,GAAU,IAAIC,cAAO,CAAA;AAAA,MACtB,UAAA,EAAYC,mBAAW,IAAK,CAAA;AAAA,QACxB,MAAQ,EAAA,EAAE,MAAQ,EAAA,kBAAA,EAAoB,YAAY,UAAW,EAAA;AAAA,QAC7D,QAAU,EAAA;AAAA,UACN,MAAA,EAAQ,qBACH,OAAQ,CAAA,oBAAA,EAAsBC,kCAAiB,qBAAsB,CAAA,IAAA,CAAK,YAAY,CAAC,CAAA;AAAA,SAChG;AAAA,OACH,CAAA;AAAA,KACJ,CAAA,CAAA;AAED,IAAK,IAAA,CAAA,UAAA,GAAa,IAAIC,iBAAU,CAAA;AAAA,MAC5B,IAAI,IAAK,CAAA,aAAA;AAAA,KACZ,CAAA,CAAA;AAAA,GACL;AACJ,CAAA;AApDI,aAAA,CAFS,mBAEK,WAAY,EAAA;AAAA,EACtB,IAAM,EAAA;AAAA,IACFC,qBAAc,CAAA,kBAAA;AAAA,GAClB;AAAA,EACA,IAAM,EAAA,SAAA;AACV,CAAA,CAAA;;;;"}