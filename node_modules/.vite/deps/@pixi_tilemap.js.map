{
  "version": 3,
  "sources": ["../../@pixi/tilemap/src/settings.ts", "../../@pixi/tilemap/src/TilemapGeometry.ts", "../../@pixi/tilemap/src/TilemapPipe.ts", "../../@pixi/tilemap/src/TileTextureArray.ts", "../../@pixi/tilemap/src/gl_tilemap.ts", "../../@pixi/tilemap/src/gpu_tilemap.ts", "../../@pixi/tilemap/src/Tilemap.ts", "../../@pixi/tilemap/src/CompositeTilemap.ts", "../../@pixi/tilemap/src/index.ts"],
  "sourcesContent": ["import { SCALE_MODE } from 'pixi.js';\n\n/**\n * These are additional @pixi/tilemap options.\n *\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\n * is undefined.\n */\nexport const settings = {\n    /** The default number of textures per tilemap in a tilemap composite. */\n    TEXTURES_PER_TILEMAP: 16,\n\n    /** The scaling mode of the combined texture tiling. */\n    TEXTILE_SCALE_MODE: 'linear' as SCALE_MODE,\n\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\n    use32bitIndex: false,\n};\n\n// @deprecated\nexport const Constant = settings;\n", "import { Buffer, BufferUsage, Geometry } from 'pixi.js';\n\n// For some reason, ESLint goes mad with indentation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nexport class TilemapGeometry extends Geometry\n{\n    static vertSize = 13;\n    static vertPerQuad = 4;\n    static stride = this.vertSize * 4;\n    lastTimeAccess = 0;\n\n    vertSize = TilemapGeometry.vertSize;\n    vertPerQuad = TilemapGeometry.vertPerQuad;\n    stride = TilemapGeometry.stride;\n\n    constructor(indexBuffer: Buffer)\n    {\n        const buf = new Buffer({\n            data: new Float32Array(2),\n            label: 'tilemap-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const stride = TilemapGeometry.stride;\n\n        // TODO: why location is like that in webgl? ascending?\n\n\t    super({\n            indexBuffer,\n            attributes: {\n                aVertexPosition: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                    // location: 6,\n                },\n                aTextureCoord: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                    // location: 4,\n                },\n                aFrame: {\n                    buffer: buf,\n                    format: 'float32x4',\n                    stride,\n                    offset: 4 * 4,\n                    // location: 3,\n                },\n                aAnim: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 8 * 4,\n                    // location: 1,\n                },\n                aTextureId: {\n                    buffer: buf,\n                    format: 'sint32',\n                    stride,\n                    offset: 10 * 4,\n                    // location: 5\n                },\n                aAnimDivisor: {\n                    buffer: buf,\n                    format: 'float32',\n                    stride,\n                    offset: 11 * 4,\n                    // location: 2\n                },\n                aAlpha: {\n                    buffer: buf,\n                    format: 'float32',\n                    stride,\n                    offset: 12 * 4,\n                    // location: 0\n                }\n            },\n        });\n\n        this.buf = buf;\n    }\n\n    buf: Buffer;\n}\n", "import {\n    Buffer,\n    BufferUsage, ExtensionType, GlobalUniformGroup,\n    IndexBufferArray, Instruction, InstructionPipe, InstructionSet, Matrix, Renderer,\n    RenderPipe, UniformGroup\n} from 'pixi.js';\nimport { CompositeTilemap } from './CompositeTilemap';\nimport { settings } from './settings';\nimport { TilemapGeometry } from './TilemapGeometry';\n\nimport type { Tilemap } from './Tilemap';\n\n// For some reason, ESLint goes mad with indentation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nexport abstract class TilemapAdaptor\n{\n    abstract init(): void;\n    abstract execute(meshPipe: TilemapPipe, mesh: Tilemap): void;\n    abstract destroy(): void;\n\n    public pipe_uniforms = new UniformGroup({\n        u_proj_trans: { value: new Matrix(), type: 'mat3x3<f32>' },\n        u_anim_frame: { value: new Float32Array(2), type: 'vec2<f32>' },\n    });\n}\n\nexport interface TilemapInstruction extends Instruction\n{\n    renderPipeId: 'tilemap';\n    tilemap: Tilemap;\n}\n\n/**\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\n */\nexport class TilemapPipe implements RenderPipe<Tilemap>, InstructionPipe<TilemapInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'tilemap',\n    } as const;\n    /** The managing renderer */\n    public readonly renderer: Renderer;\n\n    /** The tile animation frame */\n    public tileAnim = [0, 0];\n\n    private ibLen = 0;// index buffer length\n\n    /** The index buffer for the tilemaps to share. */\n    private indexBuffer: Buffer = null;\n\n    /** The shader used to render tilemaps. */\n    private shader: TilemapGeometry;\n\n    private adaptor: TilemapAdaptor;\n\n    constructor(renderer: Renderer, adaptor: TilemapAdaptor)\n    {\n        this.renderer = renderer;\n        this.adaptor = adaptor;\n\n        this.adaptor.init();\n\n\t    this.indexBuffer = new Buffer({\n            data: new Uint16Array([0, 1, 2, 0, 2, 3]),\n            label: 'index-tilemap-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\t    this.checkIndexBuffer(2000);\n    }\n\n    start(): void\n    {\n\t    // sorry, nothing\n    }\n\n    /**\n\t * @internal\n\t * @ignore\n\t */\n    createVb(): TilemapGeometry\n    {\n\t    const geom = new TilemapGeometry(this.indexBuffer);\n\n        geom.lastTimeAccess = Date.now();\n\n\t    return geom;\n    }\n\n    /** @return The {@link TilemapGeometry} shader that this rendering pipeline is using. */\n    getShader(): TilemapGeometry { return this.shader; }\n\n    destroy(): void\n    {\n\t    // this.rectShader.destroy();\n\t    this.shader = null;\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    public checkIndexBuffer(size: number): void\n    {\n\t    const totalIndices = size * 6;\n\n\t    if (totalIndices <= this.ibLen)\n\t    {\n\t        return;\n\t    }\n\n\t    let len = totalIndices;\n\n\t    while (len < totalIndices)\n\t    {\n\t        len <<= 1;\n\t    }\n\n\t    this.ibLen = totalIndices;\n\t    this.indexBuffer.data = createIndicesForQuads(size,\n\t        settings.use32bitIndex ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices));\n    }\n\n    destroyRenderable(_renderable: Tilemap): void\n    {\n        _renderable.vb.destroy(true);\n        _renderable.vb = null;\n    }\n\n    addRenderable(tilemap: Tilemap, instructionSet: InstructionSet | undefined): void\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        tilemap.updateBuffer(this);\n        tilemap.checkValid();\n        tilemap.getTileset().update();\n\n        if (tilemap.is_valid)\n        {\n            batcher.break(instructionSet);\n            instructionSet.add(tilemap._instruction);\n        }\n    }\n\n    updateRenderable(tilemap: Tilemap, _instructionSet?: InstructionSet | undefined): void\n    {\n        tilemap.updateBuffer(this);\n        tilemap.getTileset().update();\n    }\n\n    validateRenderable(renderable: Tilemap): boolean\n    {\n        return renderable.checkValid();\n    }\n\n    public execute({ tilemap }: TilemapInstruction)\n    {\n        if (!tilemap.isRenderable) return;\n\n        tilemap.state.blendMode = tilemap.groupBlendMode;\n\n        const { pipe_uniforms } = this.adaptor;\n\n        const u_proj_trans = pipe_uniforms.uniforms.u_proj_trans;\n        const u_global = ((this.renderer.globalUniforms as any)._activeUniforms.at(-1) as GlobalUniformGroup).uniforms;\n        let anim_frame = this.tileAnim;\n        const { u_anim_frame } = pipe_uniforms.uniforms;\n\n        u_global.uProjectionMatrix.copyTo(u_proj_trans).append(u_global.uWorldTransformMatrix)\n            .append(tilemap.worldTransform);\n        if (tilemap.compositeParent)\n        {\n            anim_frame = (tilemap.parent as CompositeTilemap).tileAnim || anim_frame;\n        }\n        u_anim_frame[0] = anim_frame[0];\n        u_anim_frame[1] = anim_frame[1];\n\n        pipe_uniforms.update();\n\n        this.adaptor.execute(this, tilemap);\n    }\n}\n\nfunction createIndicesForQuads(\n    size: number,\n    outBuffer: IndexBufferArray\n): IndexBufferArray\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n", "import { BindGroup, Buffer, BufferUsage, Texture, TextureSource, UniformGroup } from 'pixi.js';\n\nexport class TileTextureArray\n{\n    max_textures: number;\n    constructor(max_textures: number)\n    {\n        this.max_textures = max_textures;\n        this.tex_sizes = new Float32Array((this.max_textures * 4) + 4);\n        this.tex_buf = new Buffer({\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n        });\n    }\n\n    arr: TextureSource[] = [];\n    count = 0;\n    dirty = false;\n    dirty_gpu = false;\n    bind_group: BindGroup = null;\n    bind_group_resources: any = {};\n    tex_sizes: Float32Array = null;\n    null_color: Float32Array = new Float32Array([0, 0, 0, 0.5]);\n    tex_buf: Buffer = null;\n\n    get length()\n    {\n        return this.count;\n    }\n\n    push(tex: TextureSource)\n    {\n        this.arr[this.count++] = tex;\n        this.dirty = true;\n    }\n\n    at(ind: number)\n    {\n        return this.arr[ind];\n    }\n\n    update()\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        this.dirty = false;\n        this.dirty_gpu = true;\n\n        const { tex_sizes, arr, count, max_textures, null_color } = this;\n\n        for (let i = 0; i < count; i++)\n        {\n            const tex = arr[i];\n\n            if (tex)\n            {\n                tex_sizes[(i * 4)] = tex.pixelWidth;\n                tex_sizes[(i * 4) + 1] = tex.pixelHeight;\n                tex_sizes[(i * 4) + 2] = 1.0 / tex.pixelWidth;\n                tex_sizes[(i * 4) + 3] = 1.0 / tex.pixelHeight;\n            }\n        }\n\n        tex_sizes[max_textures * 4] = null_color[0];\n        tex_sizes[(max_textures * 4) + 1] = null_color[1];\n        tex_sizes[(max_textures * 4) + 2] = null_color[2];\n        tex_sizes[(max_textures * 4) + 3] = null_color[3];\n    }\n\n    markDirty()\n    {\n        this.dirty = true;\n    }\n\n    getBindGroup()\n    {\n        this.update();\n        if (!this.dirty_gpu)\n        {\n            return this.bind_group;\n        }\n\n        const { bind_group_resources, max_textures, arr, count } = this;\n\n        let bindIndex = 0;\n\n        bind_group_resources[bindIndex++] = new UniformGroup({\n            u_texture_size: {\n                value: this.tex_sizes,\n                type: 'vec4<f32>',\n                size: max_textures\n            },\n            u_null_color: {\n                value: this.null_color,\n                type: 'vec4<f32>'\n            },\n        });\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            const texture = (i < count ? arr[i] : null) || Texture.EMPTY.source;\n\n            bind_group_resources[bindIndex++] = texture.source;\n            bind_group_resources[bindIndex++] = texture.style;\n        }\n\n        if (!this.bind_group)\n        {\n            this.bind_group = new BindGroup(bind_group_resources);\n        }\n\n        return this.bind_group;\n    }\n\n    static generate_gpu_textures(max_textures: number): string\n    {\n        const src: string[] = [];\n\n        src.push(`struct TextureArrayFields {`);\n        src.push(`    u_texture_size: array<vec4f, ${max_textures}>,`);\n        src.push(`    u_null_color: vec4f`);\n        src.push(`}`);\n        src.push(`@group(1) @binding(0) var<uniform> taf: TextureArrayFields;`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`@group(1) @binding(${(i * 2) + 1}) var u_texture_${i}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${(i * 2) + 2}) var u_sampler_${i}: sampler;`);\n        }\n\n        src.push('fn sampleMultiTexture(texture_id: i32, uv: vec2f, dx: vec2f, dy: vec2f) -> vec4f {');\n        src.push(`switch texture_id {`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`  case ${i}: { return textureSampleGrad(u_texture_${i}, u_sampler_${i}, uv, dx, dy); }`);\n        }\n        src.push(`  default: { return taf.u_null_color; }`);\n        src.push('} }');\n\n        return src.join('\\n');\n    }\n\n    static generate_gl_textures(max_textures: number): string\n    {\n        const src: string[] = [];\n\n        src.push(`uniform vec4 u_texture_size[${max_textures + 1}];`);\n        src.push(`uniform sampler2D u_textures[${max_textures}];`);\n        src.push(`uniform vec4 u_null_color;`);\n\n        src.push('vec4 sampleMultiTexture(float texture_id, vec2 uv) {');\n        src.push(`if(texture_id < -0.5) return u_texture_size[${max_textures}];`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`if(texture_id < ${i}.5) return texture(u_textures[${i}], uv * u_texture_size[${i}].zw);`);\n        }\n        src.push(`return u_texture_size[${max_textures}];`);\n        src.push('}');\n\n        return src.join('\\n');\n    }\n\n    static gl_gen_resources(max_textures: number): any\n    {\n        const sampleValues: Array<number> = [];\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            sampleValues[i] = i;\n        }\n\n        const samplerSize: Array<number> = [];\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            // These are overwritten by TilemapRenderer when textures actually bound.\n            samplerSize.push(2048);\n            samplerSize.push(2048);\n            samplerSize.push(1.0 / 2048);\n            samplerSize.push(1.0 / 2048);\n        }\n\n        return {\n            u_textures: {\n                value: sampleValues,\n                type: 'i32',\n                size: max_textures\n            },\n            u_texture_size: {\n                value: samplerSize,\n                type: 'vec4<f32>',\n                size: max_textures\n            }\n        };\n    }\n}\n", "import { ExtensionType, GlProgram, Shader, UniformGroup, WebGLRenderer } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nconst gl_tilemap_vertex = `\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\nin vec4 aFrame;\nin vec2 aAnim;\nin float aAnimDivisor;\nin float aTextureId;\nin float aAlpha;\n\nuniform mat3 u_proj_trans;\nuniform vec2 u_anim_frame;\n\nout vec2 vTextureCoord;\nout float vTextureId;\nout vec4 vFrame;\nout float vAlpha;\n\nvoid main(void)\n{\n  gl_Position = vec4((u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n  vec2 animFrameOffset = aAnim - animCount * 2048.0;\n  vec2 currentFrame = floor(u_anim_frame / aAnimDivisor);\n  vec2 loop_num = floor((currentFrame + 0.5) / animCount);\n  vec2 animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n\n  vTextureCoord = aTextureCoord + animOffset;\n  vFrame = aFrame + vec4(animOffset, animOffset);\n  vTextureId = aTextureId;\n  vAlpha = aAlpha;\n}\n`;\n\nconst gl_tilemap_fragment = `\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nin vec2 vTextureCoord;\nin vec4 vFrame;\nin float vTextureId;\nin float vAlpha;\n\n//include_textures\n\nvoid main(void)\n{\n  float textureId = floor(vTextureId + 0.5);\n  vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  vec4 color = sampleMultiTexture(textureId, textureCoord);\n  finalColor = color * vAlpha;\n}\n`;\n\nexport class GlTilemapAdaptor extends TilemapAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'tilemap',\n    } as const;\n\n    _shader: Shader = null;\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\n\n    destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\n    {\n        const renderer = pipe.renderer as WebGLRenderer;\n        const shader = this._shader;\n        const tileset = tilemap.getTileset();\n\n        const tu = shader.resources.texture_uniforms;\n\n        if (tu.uniforms.u_texture_size !== tileset.tex_sizes)\n        {\n            tu.uniforms.u_texture_size = tileset.tex_sizes;\n            tu.update();\n        }\n\n        for (let i = 0; i < tileset.length; i++)\n        {\n            renderer.texture.bind(tileset.arr[i], i);\n        }\n\n        renderer.encoder.draw({\n            geometry: tilemap.vb,\n            shader,\n            state: tilemap.state,\n            size: tilemap.rects_count * 6\n        });\n\n        // TODO: support several tilemaps here, without re-setting extra uniforms\n    }\n\n    init(): void\n    {\n        this._shader = new Shader({\n            glProgram: GlProgram.from({\n                vertex: gl_tilemap_vertex,\n                fragment: gl_tilemap_fragment.replace('//include_textures',\n                    TileTextureArray.generate_gl_textures(this.max_textures))\n            }),\n            resources: {\n                texture_uniforms: new UniformGroup(TileTextureArray.gl_gen_resources(this.max_textures), { isStatic: true }),\n                pipe_uniforms: this.pipe_uniforms.uniformStructures,\n            },\n        });\n    }\n}\n", "import { BindGroup, ExtensionType, GpuProgram, Shader } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nconst gpu_tilemap_vertex = `\nstruct GlobalUniforms {\n  uProjectionMatrix:mat3x3f,\n  uWorldTransformMatrix:mat3x3f,\n  uWorldColorAlpha: vec4f,\n  uResolution: vec2f,\n}\n\nstruct TilemapUniforms {\n  u_proj_trans:mat3x3f,\n  u_anim_frame:vec2f\n}\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\n\nstruct VSOutput {\n  @builtin(position) vPosition: vec4f,\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32\n};\n\n@vertex\nfn mainVert(\n   @location(6) aVertexPosition: vec2f,\n   @location(4) aTextureCoord: vec2f,\n   @location(3) aFrame: vec4f,\n   @location(1) aAnim: vec2f,\n   @location(2) aAnimDivisor: f32,\n   @location(5) aTextureId: i32,\n   @location(0) aAlpha: f32,\n ) -> VSOutput {\n\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  var animCount = floor((aAnim + 0.5) / 2048.0);\n  var animFrameOffset = aAnim - animCount * 2048.0;\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\n  var loop_num = floor((currentFrame + 0.5) / animCount);\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n  var vTextureCoord = aTextureCoord + animOffset;\n  var vFrame = aFrame + vec4(animOffset, animOffset);\n\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aAlpha);\n};\n`;\n\nconst gpu_tilemap_fragment = `\n//include_textures\n\n@fragment\nfn mainFrag(\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32,\n  ) -> @location(0) vec4f {\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\n  return color * vAlpha;\n};\n`;\n\nexport class GpuTilemapAdaptor extends TilemapAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'tilemap',\n    } as const;\n\n    _shader: Shader = null;\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\n    bind_group: BindGroup = null;\n\n    destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\n    {\n        const renderer = pipe.renderer;\n        const shader = this._shader;\n        // GPU..\n\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n        shader.groups[1] = tilemap.getTileset().getBindGroup();\n        shader.groups[2] = this.bind_group;\n\n        renderer.encoder.draw({\n            geometry: tilemap.vb,\n            shader,\n            state: tilemap.state,\n            size: tilemap.rects_count * 6\n        });\n        // TODO: does it need groups?\n    }\n\n    init(): void\n    {\n        this._shader = new Shader({\n            gpuProgram: GpuProgram.from({\n                vertex: { source: gpu_tilemap_vertex, entryPoint: 'mainVert' },\n                fragment: {\n                    source: gpu_tilemap_fragment\n                        .replace('//include_textures', TileTextureArray.generate_gpu_textures(this.max_textures))\n                },\n            })\n        });\n\n        this.bind_group = new BindGroup({\n            ut: this.pipe_uniforms\n        });\n    }\n}\n", "/* eslint-disable no-unused-vars */\nimport { Bounds, Container, groupD8, State, Texture, TextureSource } from 'pixi.js';\nimport { settings } from './settings';\nimport { TilemapInstruction, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nimport type { DestroyOptions } from 'pixi.js';\nimport type { TilemapGeometry } from './TilemapGeometry';\n\nenum POINT_STRUCT\n    {\n    U,\n    V,\n    X,\n    Y,\n    TILE_WIDTH,\n    TILE_HEIGHT,\n    ROTATE,\n    ANIM_X,\n    ANIM_Y,\n    TEXTURE_INDEX,\n    ANIM_COUNT_X,\n    ANIM_COUNT_Y,\n    ANIM_DIVISOR,\n    ALPHA,\n}\n\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\n\n/**\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\n *\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\n *\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\n * instances.\n *\n * @example\n * import { Tilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Add the spritesheet into your loader!\n * Loader.shared.add('atlas', 'assets/atlas.json');\n *\n * // Make the tilemap once the tileset assets are available.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      // The base-texture is shared between all the tile textures.\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\n *          .tile('grass.png', 0, 0)\n *          .tile('grass.png', 100, 100)\n *          .tile('brick_wall.png', 0, 100);\n * });\n */\nexport class Tilemap extends Container\n{\n    // TODO: make default color work\n    /**\n     * Currently doesnt work.\n     */\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    state = State.for2d();\n\n    is_valid = false;\n\n    public readonly renderPipeId = 'tilemap';\n    public readonly canBundle = true;\n\n    _instruction = {\n        renderPipeId: 'tilemap',\n        tilemap: this as Tilemap\n    } as TilemapInstruction;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    checkValid()\n    {\n        const v = this.tileset.count > 0 && this.pointsBuf.length > 0;\n        const res = this.is_valid !== v;\n\n        this.is_valid = v;\n\n        return res !== v;\n    }\n\n    /**\n     * The tile animation frame.\n     *\n     * @see CompositeTilemap.tileAnim\n     */\n    public tileAnim: [number, number] = null;\n\n    /**\n     * This is the last uploaded size of the tilemap geometry.\n     * @ignore\n     */\n    rects_count = 0;\n\n    /** @ignore */\n    compositeParent = false;\n\n    /**\n     * The list of base-textures being used in the tilemap.\n     *\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\n     * should be added after tiles have been added into the map.\n     */\n    protected tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n    /**\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\n     */\n    protected readonly tilemapBounds = new Bounds();\n\n    /** Flags whether any animated tile was added. */\n    protected hasAnimatedTile = false;\n\n    /** The interleaved geometry of the tilemap. */\n    private pointsBuf: Array<number> = [];\n\n    /**\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\n     *      base-textures in this array must not be duplicated.\n     */\n    constructor(tileset: TextureSource | Array<TextureSource>)\n    {\n        super();\n        this.setTileset(tileset);\n    }\n\n    /**\n     * @returns The tileset of this tilemap.\n     */\n    getTileset(): TileTextureArray\n    {\n        return this.tileset;\n    }\n\n    /**\n     * Define the tileset used by the tilemap.\n     *\n     * @param textureOrArray - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\n     *  be wrapped into an array. This should not contain any duplicates.\n     */\n    setTileset(textureOrArray: TileTextureArray | TextureSource | Array<TextureSource> = []): this\n    {\n        let ts = this.tileset;\n\n        if (textureOrArray instanceof TileTextureArray)\n        {\n            this.tileset = textureOrArray;\n            this.didViewUpdate = true;\n        }\n        else if (textureOrArray instanceof TextureSource)\n        {\n            if (ts.count === 1 && ts.arr[0] === textureOrArray)\n            {\n                return this;\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n            ts.push(textureOrArray);\n            this.didViewUpdate = true;\n        }\n        else\n        {\n            if (textureOrArray.length === ts.count)\n            {\n                let flag = true;\n\n                for (let i = 0; i < textureOrArray.length; i++)\n                {\n                    if (textureOrArray[i]?.source !== ts.arr[i])\n                    {\n                        flag = false;\n                        break;\n                    }\n                }\n\n                if (flag)\n                {\n                    return this;\n                }\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n            for (let i = 0; i < textureOrArray.length; i++)\n            {\n                ts.push(textureOrArray[i]?.source);\n            }\n            this.didViewUpdate = true;\n        }\n\n        return this;\n    }\n\n    /**  Clears all the tiles added into this tilemap. */\n    clear(): this\n    {\n        this.pointsBuf.length = 0;\n        this.rects_count = 0;\n        this.tilemapBounds.clear();\n        this.hasAnimatedTile = false;\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given texture at (x, y).\n     *\n     * @param tileTexture - The tiling texture to render.\n     * @param x - The local x-coordinate of the tile's position.\n     * @param y - The local y-coordinate of the tile's position.\n     * @param options - Additional tile options.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n     *      animation frame textures in the base-texture.\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n     *      animation frames textures in the base-texture.\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n     *      per row.\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n     *      per column.\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\n     * @param [options.alpha=1] - Tile alpha\n     * @return This tilemap, good for chaining.\n     */\n    tile(\n        tileTexture: number | string | Texture | TextureSource,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number,\n            animDivisor?: number,\n            alpha?: number,\n        } = {}\n    ): this\n    {\n        this.didViewUpdate = true;\n        let baseTexture: TextureSource;\n        let textureIndex = -1;\n        let was_num = false;\n\n        if (typeof tileTexture === 'number')\n        {\n            textureIndex = tileTexture;\n            was_num = true;\n            baseTexture = this.tileset.arr[textureIndex];\n        }\n        else\n        {\n            let texture: Texture | TextureSource;\n\n            if (typeof tileTexture === 'string')\n            {\n                texture = Texture.from(tileTexture);\n            }\n            else\n            {\n                texture = tileTexture;\n            }\n\n            const textureList = this.tileset;\n\n            for (let i = 0; i < textureList.count; i++)\n            {\n                if (textureList.arr[i] === texture.source)\n                {\n                    textureIndex = i;\n                    break;\n                }\n            }\n\n            if ('frame' in texture)\n            {\n                options.u = options.u ?? texture.frame.x;\n                options.v = options.v ?? texture.frame.y;\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\n            }\n\n            baseTexture = texture.source;\n        }\n\n        if (!was_num && !baseTexture)\n        {\n            console.error('The tile texture was not found in the tilemap tileset.');\n\n            return this;\n        }\n\n        const {\n            u = 0,\n            v = 0,\n            tileWidth = baseTexture.width,\n            tileHeight = baseTexture.height,\n            animX = 0,\n            animY = 0,\n            rotate = 0,\n            animCountX = 1024,\n            animCountY = 1024,\n            animDivisor = 1,\n            alpha = 1,\n        } = options;\n\n        const pb = this.pointsBuf;\n\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\n\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n        pb.push(animDivisor);\n        pb.push(alpha);\n\n        this.tilemapBounds.addFrame(x, y, x + tileWidth, y + tileHeight);\n\n        return this;\n    }\n\n    /** Changes the rotation of the last tile. */\n    tileRotate(rotate: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\n    }\n\n    /** Changes the `animX`, `animCountX` of the last tile. */\n    tileAnimX(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n    }\n\n    /** Changes the `animY`, `animCountY` of the last tile. */\n    tileAnimY(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\n    }\n\n    /** Changes the `animDivisor` value of the last tile. */\n    tileAnimDivisor(divisor: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\n    }\n\n    tileAlpha(alpha: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\n    }\n\n    private vbId = 0;\n    vb: TilemapGeometry = null;\n    private vbBuffer: ArrayBuffer = null;\n    private vbArray: Float32Array = null;\n    private vbInts: Uint32Array = null;\n\n    private destroyVb(): void\n    {\n        if (this.vb)\n        {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    updateBuffer(plugin: TilemapPipe)\n    {\n        const points = this.pointsBuf;\n        const rects_count = points.length / POINT_STRUCT_SIZE;\n        let vb = this.vb;\n\n        if (this.tileset.count === 0 || rects_count === 0 || (this.rects_count === rects_count && vb))\n        {\n            return;\n        }\n        this.rects_count = rects_count;\n\n        // lost context! recover!\n\n        if (!vb)\n        {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n        }\n\n        // if layer was changed, re-upload vertices\n        const vertices = rects_count * vb.vertPerQuad;\n\n        plugin.checkIndexBuffer(rects_count);\n\n        const vertexBuf = vb.getBuffer('aVertexPosition');\n        const vs = vb.stride * vertices;\n\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\n        {\n            // !@#$ happens, need resize\n            let bk = vb.stride;\n\n            while (bk < vs)\n            {\n                bk *= 2;\n            }\n            this.vbBuffer = new ArrayBuffer(bk);\n            this.vbArray = new Float32Array(this.vbBuffer);\n            this.vbInts = new Uint32Array(this.vbBuffer);\n        }\n\n        const arr = this.vbArray;\n        const ints = this.vbInts;\n        let sz = 0;\n        let textureId = 0;\n\n        for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\n        {\n            const eps = 0.5;\n\n            if (this.compositeParent)\n            {\n                textureId = points[i + POINT_STRUCT.TEXTURE_INDEX];\n            }\n            const x = points[i + POINT_STRUCT.X];\n            const y = points[i + POINT_STRUCT.Y];\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\n            const u = points[i + POINT_STRUCT.U];\n            const v = points[i + POINT_STRUCT.V];\n            let rotate = points[i + POINT_STRUCT.ROTATE];\n\n            const animX = points[i + POINT_STRUCT.ANIM_X];\n            const animY = points[i + POINT_STRUCT.ANIM_Y];\n            const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\n            const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\n\n            const animXEncoded = animX + (animWidth * 2048);\n            const animYEncoded = animY + (animHeight * 2048);\n            const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\n            const alpha = points[i + POINT_STRUCT.ALPHA];\n\n            let u0: number;\n            let v0: number; let u1: number;\n            let v1: number; let u2: number;\n            let v2: number; let u3: number;\n            let v3: number;\n\n            if (rotate === 0)\n            {\n                u0 = u;\n                v0 = v;\n                u1 = u + w;\n                v1 = v;\n                u2 = u + w;\n                v2 = v + h;\n                u3 = u;\n                v3 = v + h;\n            }\n            else\n            {\n                let w2 = w / 2;\n                let h2 = h / 2;\n\n                if (rotate % 4 !== 0)\n                {\n                    w2 = h / 2;\n                    h2 = w / 2;\n                }\n                const cX = u + w2;\n                const cY = v + h2;\n\n                rotate = groupD8.add(rotate, groupD8.NW);\n                u0 = cX + (w2 * groupD8.uX(rotate));\n                v0 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                u1 = cX + (w2 * groupD8.uX(rotate));\n                v1 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u2 = cX + (w2 * groupD8.uX(rotate));\n                v2 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u3 = cX + (w2 * groupD8.uX(rotate));\n                v3 = cY + (h2 * groupD8.uY(rotate));\n            }\n\n            arr[sz++] = x;\n            arr[sz++] = y;\n            arr[sz++] = u0;\n            arr[sz++] = v0;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x + w;\n            arr[sz++] = y;\n            arr[sz++] = u1;\n            arr[sz++] = v1;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x + w;\n            arr[sz++] = y + h;\n            arr[sz++] = u2;\n            arr[sz++] = v2;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x;\n            arr[sz++] = y + h;\n            arr[sz++] = u3;\n            arr[sz++] = v3;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n        }\n\n        vertexBuf.data = arr;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        if (this.rects_count * POINT_STRUCT_SIZE !== this.pointsBuf.length\n            || (anim && this.hasAnimatedTile))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This will pull forward the modification marker.\n     *\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        this.rects_count = this.pointsBuf.length / POINT_STRUCT_SIZE;\n    }\n\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.tilemapBounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    get bounds()\n    {\n        return this.tilemapBounds;\n    }\n\n    /** @override */\n    destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n        this.destroyVb();\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\n    {\n        this.tile(\n            texture,\n            x,\n            y,\n            {\n                animX,\n                animY,\n            }\n        );\n\n        return true;\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX = 0,\n        animY = 0,\n        rotate = 0,\n        animCountX = 1024,\n        animCountY = 1024,\n        animDivisor = 1,\n        alpha = 1,\n    ): this\n    {\n        return this.tile(\n            textureIndex,\n            x, y,\n            {\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, alpha\n            }\n        );\n    }\n}\n", "import { Container, Texture, TextureSource } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\n\n/**\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\n *\n * The composite tileset is the concatenation of the individual tilesets used in the tilemaps. You can\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\n *\n * @example\n * import { Application } from '@pixi/app';\n * import { CompositeTilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Setup view & stage.\n * const app = new Application();\n *\n * document.body.appendChild(app.renderer.view);\n * app.stage.interactive = true;\n *\n * // Global reference to the tilemap.\n * let globalTilemap: CompositeTilemap;\n *\n * // Load the tileset spritesheet!\n * Loader.shared.load('atlas.json');\n *\n * // Initialize the tilemap scene when the assets load.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      const tilemap = new CompositeTilemap();\n *\n *      // Setup the game level with grass and dungeons!\n *      for (let x = 0; x < 10; x++)\n *      {\n *          for (let y = 0; y < 10; y++)\n *          {\n *              tilemap.tile(\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\n *                  x * 100,\n *                  y * 100,\n *              );\n *          }\n *      }\n *\n *      globalTilemap = app.stage.addChild(tilemap);\n * });\n *\n * // Show a bomb at a random location whenever the user clicks!\n * app.stage.on('click', function onClick()\n * {\n *      if (!globalTilemap) return;\n *\n *      const x = Math.floor(Math.random() * 10);\n *      const y = Math.floor(Math.random() * 10);\n *\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\n * });\n */\nexport class CompositeTilemap extends Container\n{\n    /** The hard limit on the number of tile textures used in each tilemap. */\n    public readonly texturesPerTilemap: number;\n\n    /**\n     * The animation frame vector.\n     *\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\n     * row and `animCountY` per column.\n     *\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\n     */\n    public tileAnim: [number, number] = null;\n\n    /** The last modified tilemap. */\n    protected lastModifiedTilemap: Tilemap = null;\n\n    private modificationMarker = 0;\n    // private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n\n    /**\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\n     *  will work equivalently.\n     */\n    constructor(tileset?: Array<TextureSource>)\n    {\n        super();\n\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\n        this.tileset(tileset);\n    }\n\n    /**\n     * This will preinitialize the tilesets of the layered tilemaps.\n     *\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\n     *\n     * @param tileTextures - The list of tile textures that make up the tileset.\n     */\n    tileset(tileTextures: Array<TextureSource>): this\n    {\n        if (!tileTextures)\n        {\n            tileTextures = [];\n        }\n\n        const texPerChild = this.texturesPerTilemap;\n        const len1 = this.children.length;\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\n\n        for (let i = 0; i < Math.min(len1, len2); i++)\n        {\n            (this.children[i] as Tilemap).setTileset(\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\n            );\n        }\n        for (let i = len1; i < len2; i++)\n        {\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n\n            tilemap.compositeParent = true;\n\n            // TODO: Don't use children\n            this.addChild(tilemap);\n        }\n\n        return this;\n    }\n\n    /** Clears the tilemap composite. */\n    clear(): this\n    {\n        for (let i = 0; i < this.children.length; i++)\n        {\n            (this.children[i] as Tilemap).clear();\n        }\n\n        this.modificationMarker = 0;\n\n        return this;\n    }\n\n    /** Changes the rotation of the last added tile. */\n    tileRotate(rotate: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileRotate(rotate);\n        }\n\n        return this;\n    }\n\n    /** Changes `animX`, `animCountX` of the last added tile. */\n    tileAnimX(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimX(offset, count);\n        }\n\n        return this;\n    }\n\n    /** Changes `animY`, `animCountY` of the last added tile. */\n    tileAnimY(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimY(offset, count);\n        }\n\n        return this;\n    }\n\n    /** Changes `tileAnimDivisor` value of the last added tile. */\n    tileAnimDivisor(divisor: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given tile texture at (x, y).\n     *\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\n     * @param x - The local x-coordinate of the tile's location.\n     * @param y - The local y-coordinate of the tile's location.\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n     *      animation frame textures in the base-texture.\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n     *      animation frames textures in the base-texture.\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n     *      per row.\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n     *      per column.\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\n     * @param [options.alpha=1] - Tile alpha\n     * @return This tilemap, good for chaining.\n     */\n    tile(\n        tileTexture: Texture | string | number,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number,\n            animDivisor?: number,\n            alpha?: number,\n        } = {}\n    ): this\n    {\n        let tilemap: Tilemap = null;\n        const children = this.children;\n\n        this.lastModifiedTilemap = null;\n\n        if (typeof tileTexture === 'number')\n        {\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\n            let tileIndex = 0;\n\n            tilemap = children[childIndex] as Tilemap;\n\n            if (!tilemap)\n            {\n                tilemap = children[0] as Tilemap;\n\n                // Silently fail if the tilemap doesn't exist\n                if (!tilemap) return this;\n\n                tileIndex = 0;\n            }\n            else\n            {\n                tileIndex = tileTexture % this.texturesPerTilemap;\n            }\n\n            tilemap.tile(\n                tileIndex,\n                x,\n                y,\n                options,\n            );\n        }\n        else\n        {\n            if (typeof tileTexture === 'string')\n            {\n                tileTexture = Texture.from(tileTexture);\n            }\n\n            // Probe all tilemaps to find which tileset contains the base-texture.\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i] as Tilemap;\n                const tex = child.getTileset().arr;\n\n                for (let j = 0; j < tex.length; j++)\n                {\n                    if (tex[j] === tileTexture.source)\n                    {\n                        tilemap = child;\n                        break;\n                    }\n                }\n\n                if (tilemap)\n                {\n                    break;\n                }\n            }\n\n            // If no tileset contains the base-texture, attempt to add it.\n            if (!tilemap)\n            {\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\n                for (let i = children.length - 1; i >= 0; i--)\n                {\n                    const child = children[i] as Tilemap;\n\n                    if (child.getTileset().count < this.texturesPerTilemap)\n                    {\n                        tilemap = child;\n                        child.getTileset().push(tileTexture.source);\n                        break;\n                    }\n                }\n\n                // Otherwise, create a new tilemap initialized with that tile texture.\n                if (!tilemap)\n                {\n                    tilemap = new Tilemap(tileTexture.source);\n                    tilemap.compositeParent = true;\n\n                    this.addChild(tilemap);\n                }\n            }\n\n            tilemap.tile(\n                tileTexture,\n                x,\n                y,\n                options,\n            );\n        }\n\n        this.lastModifiedTilemap = tilemap;\n\n        return this;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        const layers = this.children;\n\n        if (this.modificationMarker !== layers.length)\n        {\n            return true;\n        }\n        for (let i = 0; i < layers.length; i++)\n        {\n            if ((layers[i] as Tilemap).isModified(anim))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        const layers = this.children;\n\n        this.modificationMarker = layers.length;\n        for (let i = 0; i < layers.length; i++)\n        {\n            (layers[i] as Tilemap).clearModify();\n        }\n    }\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @see CompositeTilemap.tile\n     */\n    addFrame(\n        texture: Texture | string | number,\n        x: number,\n        y: number,\n        animX?: number,\n        animY?: number,\n        animWidth?: number,\n        animHeight?: number,\n        animDivisor?: number,\n        alpha?: number\n    ): this\n    {\n        return this.tile(\n            texture,\n            x, y,\n            {\n                animX,\n                animY,\n                animCountX: animWidth,\n                animCountY: animHeight,\n                animDivisor,\n                alpha\n            }\n        );\n    }\n\n    /**\n     * @deprecated @pixi/tilemap 3\n     * @see CompositeTilemap.tile\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX?: number,\n        animY?: number,\n        rotate?: number,\n        animWidth?: number,\n        animHeight?: number\n    ): this\n    {\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\n        const textureId: number = textureIndex % this.texturesPerTilemap;\n\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset().count > 0)\n        {\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\n            this.lastModifiedTilemap.addRect(\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\n            );\n        }\n        else\n        {\n            this.lastModifiedTilemap = null;\n        }\n\n        return this;\n    }\n\n    /**\n     * Alias for {@link CompositeTilemap.tileset tileset}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    setBitmaps = this.tileset;\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @readonly\n     * @see CompositeTilemap.texturesPerTilemap\n     */\n    get texPerChild(): number { return this.texturesPerTilemap; }\n}\n", "// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\nimport { extensions } from 'pixi.js';\nimport { GlTilemapAdaptor } from './gl_tilemap';\nimport { GpuTilemapAdaptor } from './gpu_tilemap';\nimport { TilemapPipe } from './TilemapPipe';\n\nexport * from './CompositeTilemap';\nexport * from './settings';\nexport * from './Tilemap';\nexport * from './TilemapGeometry';\nexport * from './TilemapPipe';\n\nextensions.add(TilemapPipe);\nextensions.add(GlTilemapAdaptor);\nextensions.add(GpuTilemapAdaptor);\n"],
  "mappings": "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",
  "names": ["_TilemapGeometry", "Buffer", "__publicField", "Buffer", "__publicField", "Buffer", "__publicField", "__publicField", "POINT_STRUCT", "__publicField", "__publicField"]
}
