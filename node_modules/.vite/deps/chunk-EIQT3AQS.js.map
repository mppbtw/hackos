{
  "version": 3,
  "sources": ["../../pixi.js/src/environment-browser/browserExt.ts", "../../pixi.js/src/environment-webworker/webworkerExt.ts", "../../pixi.js/lib/filters/blend-modes/blend-template.frag.mjs", "../../pixi.js/lib/filters/blend-modes/blend-template.vert.mjs", "../../pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs", "../../pixi.js/src/filters/blend-modes/BlendModeFilter.ts", "../../pixi.js/src/filters/blend-modes/hls/GLhls.ts", "../../pixi.js/src/filters/blend-modes/hls/GPUhls.ts", "../../pixi.js/src/advanced-blend-modes/ColorBlend.ts", "../../pixi.js/src/advanced-blend-modes/ColorBurnBlend.ts", "../../pixi.js/src/advanced-blend-modes/ColorDodgeBlend.ts", "../../pixi.js/src/advanced-blend-modes/DarkenBlend.ts", "../../pixi.js/src/advanced-blend-modes/DifferenceBlend.ts", "../../pixi.js/src/advanced-blend-modes/DivideBlend.ts", "../../pixi.js/src/advanced-blend-modes/ExclusionBlend.ts", "../../pixi.js/src/advanced-blend-modes/HardLightBlend.ts", "../../pixi.js/src/advanced-blend-modes/HardMixBlend.ts", "../../pixi.js/src/advanced-blend-modes/LightenBlend.ts", "../../pixi.js/src/advanced-blend-modes/LinearBurnBlend.ts", "../../pixi.js/src/advanced-blend-modes/LinearDodgeBlend.ts", "../../pixi.js/src/advanced-blend-modes/LinearLightBlend.ts", "../../pixi.js/src/advanced-blend-modes/LuminosityBlend.ts", "../../pixi.js/src/advanced-blend-modes/NegationBlend.ts", "../../pixi.js/src/advanced-blend-modes/OverlayBlend.ts", "../../pixi.js/src/advanced-blend-modes/PinLightBlend.ts", "../../pixi.js/src/advanced-blend-modes/SaturationBlend.ts", "../../pixi.js/src/advanced-blend-modes/SoftLightBlend.ts", "../../pixi.js/src/advanced-blend-modes/SubtractBlend.ts", "../../pixi.js/src/advanced-blend-modes/VividLightBlend.ts", "../../pixi.js/src/utils/browser/isWebGLSupported.ts", "../../pixi.js/src/utils/browser/isWebGPUSupported.ts", "../../pixi.js/src/rendering/renderers/autoDetectRenderer.ts", "../../pixi.js/src/app/Application.ts", "../../pixi.js/src/scene/text-bitmap/BitmapFont.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts", "../../pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts", "../../pixi.js/src/assets/BackgroundLoader.ts", "../../pixi.js/src/assets/cache/parsers/cacheTextureArray.ts", "../../pixi.js/src/assets/detections/utils/testImageFormat.ts", "../../pixi.js/src/assets/detections/parsers/detectAvif.ts", "../../pixi.js/src/assets/detections/parsers/detectDefaults.ts", "../../pixi.js/src/assets/detections/utils/testVideoFormat.ts", "../../pixi.js/src/assets/detections/parsers/detectMp4.ts", "../../pixi.js/src/assets/detections/parsers/detectOgv.ts", "../../pixi.js/src/assets/detections/parsers/detectWebm.ts", "../../pixi.js/src/assets/detections/parsers/detectWebp.ts", "../../pixi.js/src/assets/loader/Loader.ts", "../../pixi.js/src/assets/utils/checkDataUrl.ts", "../../pixi.js/src/assets/utils/checkExtension.ts", "../../pixi.js/src/assets/loader/parsers/loadJson.ts", "../../pixi.js/src/assets/loader/parsers/loadTxt.ts", "../../pixi.js/src/assets/loader/parsers/loadWebFont.ts", "../../pixi.js/src/utils/network/getResolutionOfUrl.ts", "../../pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts", "../../pixi.js/src/assets/loader/parsers/textures/loadSVG.ts", "../../pixi.js/lib/_virtual/checkImageBitmap.worker.mjs", "../../pixi.js/lib/_virtual/loadImageBitmap.worker.mjs", "../../pixi.js/src/assets/loader/workers/WorkerManager.ts", "../../pixi.js/src/assets/loader/parsers/textures/loadTextures.ts", "../../pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts", "../../pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts", "../../pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts", "../../pixi.js/src/assets/Assets.ts", "../../pixi.js/src/compressed-textures/basis/detectBasis.ts", "../../pixi.js/src/rendering/renderers/shared/texture/sources/CompressedSource.ts", "../../pixi.js/src/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.ts", "../../pixi.js/src/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.ts", "../../pixi.js/lib/_virtual/basis.worker.mjs", "../../pixi.js/src/compressed-textures/basis/utils/setBasisTranscoderPath.ts", "../../pixi.js/src/compressed-textures/basis/worker/loadBasisOnWorker.ts", "../../pixi.js/src/compressed-textures/basis/loadBasis.ts", "../../pixi.js/src/compressed-textures/basis/utils/createLevelBuffers.ts", "../../pixi.js/src/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.ts", "../../pixi.js/src/compressed-textures/dds/const.ts", "../../pixi.js/src/compressed-textures/dds/parseDDS.ts", "../../pixi.js/src/compressed-textures/dds/loadDDS.ts", "../../pixi.js/src/compressed-textures/ktx2/const.ts", "../../pixi.js/src/compressed-textures/ktx/parseKTX.ts", "../../pixi.js/src/compressed-textures/ktx/loadKTX.ts", "../../pixi.js/lib/_virtual/ktx.worker.mjs", "../../pixi.js/src/compressed-textures/ktx2/utils/setKTXTranscoderPath.ts", "../../pixi.js/src/compressed-textures/ktx2/worker/loadKTX2onWorker.ts", "../../pixi.js/src/compressed-textures/ktx2/loadKTX2.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/convertFormatIfRequired.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/glFormatToGPUFormat.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/vkFormatToGPUFormat.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.ts", "../../pixi.js/src/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.ts", "../../pixi.js/src/compressed-textures/shared/resolveCompressedTextureUrl.ts", "../../pixi.js/src/compressed-textures/shared/detectCompressed.ts", "../../pixi.js/src/culling/Culler.ts", "../../pixi.js/src/culling/CullerPlugin.ts", "../../pixi.js/src/environment-webworker/WebWorkerAdapter.ts", "../../pixi.js/lib/filters/defaults/defaultFilter.vert.mjs", "../../pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs", "../../pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs", "../../pixi.js/src/filters/defaults/alpha/AlphaFilter.ts", "../../pixi.js/src/filters/defaults/blur/const.ts", "../../pixi.js/src/filters/defaults/blur/gl/generateBlurFragSource.ts", "../../pixi.js/src/filters/defaults/blur/gl/generateBlurVertSource.ts", "../../pixi.js/src/filters/defaults/blur/gl/generateBlurGlProgram.ts", "../../pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs", "../../pixi.js/src/filters/defaults/blur/gpu/generateBlurProgram.ts", "../../pixi.js/src/filters/defaults/blur/BlurFilterPass.ts", "../../pixi.js/src/filters/defaults/blur/BlurFilter.ts", "../../pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs", "../../pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs", "../../pixi.js/src/filters/defaults/color-matrix/ColorMatrixFilter.ts", "../../pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs", "../../pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs", "../../pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs", "../../pixi.js/src/filters/defaults/displacement/DisplacementFilter.ts", "../../pixi.js/lib/filters/defaults/noise/noise.frag.mjs", "../../pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs", "../../pixi.js/src/filters/defaults/noise/NoiseFilter.ts", "../../pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs", "../../pixi.js/src/maths/point/pointInTriangle.ts", "../../pixi.js/src/maths/shapes/Triangle.ts", "../../pixi.js/src/prepare/PrepareBase.ts", "../../pixi.js/src/scene/mesh/shared/Mesh.ts", "../../pixi.js/src/scene/sprite-animated/AnimatedSprite.ts", "../../pixi.js/src/utils/misc/Transform.ts", "../../pixi.js/src/scene/sprite-tiling/TilingSprite.ts", "../../pixi.js/src/scene/text/AbstractText.ts", "../../pixi.js/src/scene/text/Text.ts", "../../pixi.js/src/prepare/PrepareQueue.ts", "../../pixi.js/src/scene/text-bitmap/BitmapText.ts", "../../pixi.js/src/scene/text-html/HTMLText.ts", "../../pixi.js/src/prepare/PrepareUpload.ts", "../../pixi.js/src/prepare/PrepareSystem.ts", "../../pixi.js/src/rendering/batcher/gpu/generateGPULayout.ts", "../../pixi.js/src/rendering/batcher/gpu/generateLayout.ts", "../../pixi.js/src/rendering/high-shader/compiler/utils/formatShader.ts", "../../pixi.js/src/rendering/mask/scissor/ScissorMask.ts", "../../pixi.js/src/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.ts", "../../pixi.js/src/rendering/renderers/gl/shader/program/mapSize.ts", "../../pixi.js/src/rendering/renderers/gpu/buffer/GpuReadBuffer.ts", "../../pixi.js/src/rendering/renderers/shared/geometry/const.ts", "../../pixi.js/src/rendering/renderers/shared/renderTarget/viewportFromFrame.ts", "../../pixi.js/src/rendering/renderers/shared/texture/const.ts", "../../pixi.js/src/rendering/renderers/shared/texture/TextureUvs.ts", "../../pixi.js/src/rendering/renderers/shared/texture/utils/generateUID.ts", "../../pixi.js/src/rendering/renderers/shared/utils/parseFunctionBody.ts", "../../pixi.js/src/scene/container/RenderContainer.ts", "../../pixi.js/src/scene/container/utils/mixHexColors.ts", "../../pixi.js/src/scene/container/utils/updateLocalTransform.ts", "../../pixi.js/src/scene/container/utils/updateWorldTransform.ts", "../../pixi.js/src/scene/graphics/shared/utils/buildGeometryFromPath.ts", "../../pixi.js/src/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.ts", "../../pixi.js/src/scene/mesh-perspective/utils/compute2DProjections.ts", "../../pixi.js/src/scene/mesh-perspective/PerspectivePlaneGeometry.ts", "../../pixi.js/src/scene/mesh-perspective/PerspectiveMesh.ts", "../../pixi.js/src/scene/mesh-plane/MeshPlane.ts", "../../pixi.js/src/scene/mesh-simple/RopeGeometry.ts", "../../pixi.js/src/scene/mesh-simple/MeshRope.ts", "../../pixi.js/src/scene/mesh-simple/MeshSimple.ts", "../../pixi.js/src/scene/mesh/shared/getTextureDefaultMatrix.ts", "../../pixi.js/src/scene/particle-container/shared/Particle.ts", "../../pixi.js/src/scene/particle-container/shared/particleData.ts", "../../pixi.js/src/scene/particle-container/shared/ParticleContainer.ts", "../../pixi.js/src/scene/sprite-nine-slice/NineSliceSprite.ts", "../../pixi.js/src/scene/text/utils/ensureTextStyle.ts", "../../pixi.js/src/utils/logging/logDebugTexture.ts", "../../pixi.js/src/utils/logging/logScene.ts", "../../pixi.js/src/index.ts"],
  "sourcesContent": ["import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @memberof environment\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @memberof environment\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n", "var blendTemplateFrag = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uBlend;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uBackTexture;\\n\\n{FUNCTIONS}\\n\\nvoid main()\\n{ \\n    vec4 back = texture(uBackTexture, vTextureCoord);\\n    vec4 front = texture(uTexture, vTextureCoord);\\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\\n    \\n    {MAIN}\\n}\\n\";\n\nexport { blendTemplateFrag as default };\n//# sourceMappingURL=blend-template.frag.mjs.map\n", "var blendTemplateVert = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 backgroundUv;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { blendTemplateVert as default };\n//# sourceMappingURL=blend-template.vert.mjs.map\n", "var blendTemplate = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlendUniforms {\\n  uBlend:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\\n\\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n{FUNCTIONS}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>\\n) -> @location(0) vec4<f32> {\\n\\n\\n   var back =  textureSample(uBackTexture, uSampler, uv);\\n   var front = textureSample(uTexture, uSampler, uv);\\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\\n   \\n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\\n\\n   {MAIN}\\n\\n   return out;\\n}\";\n\nexport { blendTemplate as default };\n//# sourceMappingURL=blend-template.wgsl.mjs.map\n", "import { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { Filter } from '../Filter';\nimport blendTemplateFrag from './blend-template.frag';\nimport blendTemplateVert from './blend-template.vert';\nimport blendTemplate from './blend-template.wgsl';\n\nexport interface BlendModeFilterOptions\n{\n    source?: string;\n    gpu?: {\n        functions?: string;\n        main?: string;\n    }\n    gl?: {\n        functions?: string;\n        main?: string;\n    }\n}\n\nexport class BlendModeFilter extends Filter\n{\n    constructor(options: BlendModeFilterOptions)\n    {\n        const gpuOptions = options.gpu;\n\n        const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: gpuSource,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: gpuSource,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glOptions = options.gl;\n\n        const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });\n\n        const glProgram = GlProgram.from({\n            vertex: blendTemplateVert,\n            fragment: glSource\n        });\n\n        const uniformGroup = new UniformGroup({\n            uBlend: {\n                value: 1,\n                type: 'f32'\n            }\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            blendRequired: true,\n            resources: {\n                blendUniforms: uniformGroup,\n                uBackTexture: Texture.EMPTY\n            }\n        });\n    }\n}\n\nfunction compileBlendModeShader(options: {source: string, functions?: string, main?: string}): string\n{\n    const { source, functions, main } = options;\n\n    return source.replace('{FUNCTIONS}', functions).replace('{MAIN}', main);\n}\n", "/** A helper object containing the hsl shader code for both glsl */\nexport const hslgl = `\n\tfloat getLuminosity(vec3 c) {\n\t\treturn 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n\t}\n\n\tvec3 setLuminosity(vec3 c, float lum) {\n\t\tfloat modLum = lum - getLuminosity(c);\n\t\tvec3 color = c.rgb + vec3(modLum);\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tvec3 modLumVec = vec3(modLum);\n\n\t\tfloat cMin = min(color.r, min(color.g, color.b));\n\t\tfloat cMax = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0) {\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0) {\n\t\t\tcolor = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfloat getSaturation(vec3 c) {\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tvec3 setSaturationMinMidMax(vec3 cSorted, float s) {\n\t\tvec3 colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x) {\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse {\n\t\t\tcolorSorted.y = 0.0;\n\t\t\tcolorSorted.z = 0.0;\n\t\t}\n\n\t\tcolorSorted.x = 0.0;\n\n\t\treturn colorSorted;\n\t}\n\n\tvec3 setSaturation(vec3 c, float s) {\n\t\tvec3 color = c;\n\n\t\tif(color.r <= color.g && color.r <= color.b) {\n\t\t\tif(color.g <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rgb, s).rgb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.rbg, s).rbg;\n\t\t\t}\n\t\t}\n\t\telse if(color.g <= color.r && color.g <= color.b) {\n\t\t\tif(color.r <= color.b) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.grb, s).grb;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.gbr, s).gbr;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif(color.r <= color.g) {\n\t\t\t\tcolor = setSaturationMinMidMax(color.brg, s).brg;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = setSaturationMinMidMax(color.bgr, s).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n    `;\n", "/** A helper object containing the hsl shader code for wgsl */\nexport const hslgpu = `\n\tfn getLuminosity(c: vec3<f32>) -> f32\n\t{\n\t\treturn 0.3*c.r + 0.59*c.g + 0.11*c.b;\n\t}\n\n\tfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>\n\t{\n\t\tvar modLum: f32 = lum - getLuminosity(c);\n\t\tvar color: vec3<f32> = c.rgb + modLum;\n\n\t\t// clip back into legal range\n\t\tmodLum = getLuminosity(color);\n\t\tlet modLumVec = vec3<f32>(modLum);\n\n\t\tlet cMin: f32 = min(color.r, min(color.g, color.b));\n\t\tlet cMax: f32 = max(color.r, max(color.g, color.b));\n\n\t\tif(cMin < 0.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\n\t\t}\n\n\t\tif(cMax > 1.0)\n\t\t{\n\t\t\tcolor = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfn getSaturation(c: vec3<f32>) -> f32\n\t{\n\t\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n\t}\n\n\tfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar colorSorted = cSorted;\n\n\t\tif(colorSorted.z > colorSorted.x)\n\t\t{\n\t\t\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\n\t\t\tcolorSorted.z = s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolorSorted.y = 0;\n\t\t\tcolorSorted.z = 0;\n\t\t}\n\n\t\tcolorSorted.x = 0;\n\n\t\treturn colorSorted;\n\t}\n\n\tfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>\n\t{\n\t\tvar color = c;\n\n\t\tif (color.r <= color.g && color.r <= color.b)\n\t\t{\n\t\t\tif (color.g <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;\n\t\t\t}\n\t\t}\n\t\telse if (color.g <= color.r && color.g <= color.b)\n\t\t{\n\t\t\tif (color.r <= color.b)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Using bgr for both fixes part of hue\n\t\t\tif (color.r <= color.g)\n\t\t\t{\n\t\t\t\tcolor = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;\n\t\t\t}\n\t\t}\n\n\t\treturn color;\n\t}\n\t`;\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'color'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color'\n * @memberof filters\n */\nexport class ColorBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendColor(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'color-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-burn'\n * @memberof filters\n */\nexport class ColorBurnBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-burn',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0 - ((1.0 - base) / blend)), 0.0);\n                }\n\n                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and brightens the base color to reflect the blend color by decreasing contrast between the two.\n * Available as `container.blendMode = 'color-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-dodge'\n * @memberof filters\n */\nexport class ColorDodgeBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-dodge',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorDodge(float base, float blend)\n                {\n                    return base / (1.0 - blend);\n                }\n\n                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return base / (1.0 - blend);\n                }\n\n                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorDodge(base.r, blend.r),\n                        colorDodge(base.g, blend.g),\n                        colorDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `,\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Uses each color channel to select the darker of the following two values; base or blend color\n * Available as `container.blendMode = 'darken'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'darken'\n * @memberof filters\n */\nexport class DarkenBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'darken',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendDarken(vec3 base, vec3 blend, float opacity)\n                {\n                    return (min(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (min(blend,base) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'difference'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'difference'\n * @memberof filters\n */\nexport class DifferenceBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'difference',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (abs(blend - base) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Divides the blend from the base color using each color channel\n * Available as `container.blendMode = 'divide'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'divide'\n * @memberof filters\n */\nexport class DivideBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'divide',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float divide(float base, float blend)\n                {\n                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;\n                }\n\n                vec3 blendDivide(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn divide(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);\n                }\n\n                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        divide(base.r, blend.r),\n                        divide(base.g, blend.g),\n                        divide(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'exclusion'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'exclusion'\n * @memberof filters\n */\nexport class ExclusionBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'exclusion',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 exclusion(vec3 base, vec3 blend)\n                {\n                    return base + blend - 2.0 * base * blend;\n                }\n\n                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return base+blend-2.0*base*blend;\n                }\n\n                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'hard-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-light'\n * @memberof filters\n */\nexport class HardLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'hard-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float hardLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);\n                }\n\n                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn hardLight(base: f32, blend: f32) -> f32\n                {\n                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);\n                }\n\n                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        hardLight(base.r, blend.r),\n                        hardLight(base.g, blend.g),\n                        hardLight(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Hard defines each of the color channel values of the blend color to the RGB values of the base color.\n * If the sum of a channel is 255, it receives a value of 255; if less than 255, a value of 0.\n *\n * Available as `container.blendMode = 'hard-mix'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-mix'\n * @memberof filters\n */\nexport class HardMixBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'hard-mix',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float hardMix(float base, float blend)\n                {\n                    return (base + blend >= 1.0) ? 1.0 : 0.0;\n                }\n\n                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn hardMix(base: f32, blend: f32) -> f32\n                {\n                    return select(0.0, 1.0, base + blend >= 1.0);\n                }\n\n                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'lighten'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'lighten'\n * @memberof filters\n */\nexport class LightenBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'lighten',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 blendLighten(vec3 base, vec3 blend, float opacity)\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    return (max(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'linear-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-burn'\n * @memberof filters\n */\nexport class LinearBurnBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-burn',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearBurn(float base, float blend)\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearBurn(base.r, blend.r),\n                        linearBurn(base.g, blend.g),\n                        linearBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and brightens the base color to reflect the blend color by decreasing contrast between the two.\n * Available as `container.blendMode = 'linear-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-dodge'\n * @memberof filters\n */\nexport class LinearDodgeBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-dodge',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1, base + blend);\n                }\n\n                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearDodge(base.r, blend.r),\n                        linearDodge(base.g, blend.g),\n                        linearDodge(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Increase or decrease brightness by burning or dodging color values, based on the blend color\n * Available as `container.blendMode = 'linear-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-light'\n * @memberof filters\n */\nexport class LinearLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'linear-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float linearBurn(float base, float blend) {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                float linearDodge(float base, float blend) {\n                    return min(1.0, base + blend);\n                }\n\n                float linearLight(float base, float blend) {\n                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));\n                }\n\n                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n                    vec3 blended = vec3(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn linearBurn(base: f32, blend: f32) -> f32\n                {\n                    return max(0.0, base + blend - 1.0);\n                }\n\n                fn linearDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base + blend);\n                }\n\n                fn linearLight(base: f32, blend: f32) -> f32\n                {\n                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        linearLight(base.r, blend.r),\n                        linearLight(base.g, blend.g),\n                        linearLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'luminosity'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'luminosity'\n * @memberof filters\n */\nexport class LuminosityBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'luminosity',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));\n                    return (blendLuminosity * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'negation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'negation'\n */\nexport class NegationBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'negation',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                vec3 negation(vec3 base, vec3 blend)\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                vec3 blendNegation(vec3 base, vec3 blend, float opacity)\n                {\n                    return (negation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>\n                {\n                    return 1.0-abs(1.0-base-blend);\n                }\n\n                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'overlay'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'overlay'\n */\nexport class OverlayBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'overlay',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float overlay(float base, float blend)\n                {\n                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));\n                }\n\n                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n   \n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n                `,\n            },\n            gpu: {\n                functions: `\n                fn overlay(base: f32, blend: f32) -> f32\n                {\n                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);\n                }\n\n                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        overlay(base.r, blend.r),\n                        overlay(base.g, blend.g),\n                        overlay(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `,\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Replaces colors based on the blend color.\n * Available as `container.blendMode = 'pin-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'pin-light'\n * @memberof filters\n */\nexport class PinLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'pin-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float pinLight(float base, float blend)\n                {\n                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));\n                }\n\n                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn pinLight(base: f32, blend: f32) -> f32\n                {\n                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);\n                }\n\n                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        pinLight(base.r, blend.r),\n                        pinLight(base.g, blend.g),\n                        pinLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\nimport { hslgl } from '../filters/blend-modes/hls/GLhls';\nimport { hslgpu } from '../filters/blend-modes/hls/GPUhls';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'saturation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'saturation'\n */\nexport class SaturationBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'saturation',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                ${hslgl}\n\n                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                ${hslgpu}\n\n                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));\n                    return (blendSaturation * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'soft-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'soft-light'\n */\nexport class SoftLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'soft-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float softLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));\n                }\n\n                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn softLight(base: f32, blend: f32) -> f32\n                {\n                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);\n                }\n\n                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        softLight(base.r, blend.r),\n                        softLight(base.g, blend.g),\n                        softLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Subtracts the blend from the base color using each color channel\n * Available as `container.blendMode = 'subtract'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'subtract'\n * @memberof filters\n */\nexport class SubtractBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'subtract',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float subtract(float base, float blend)\n                {\n                    return max(0.0, base - blend);\n                }\n\n                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n                `\n            },\n            gpu: {\n                functions: `\n                fn subtract(base: f32, blend: f32) -> f32\n                {\n                    return max(0, base - blend);\n                }\n\n                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        subtract(base.r, blend.r),\n                        subtract(base.g, blend.g),\n                        subtract(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Available as `container.blendMode = 'vivid-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'vivid-light'\n */\nexport class VividLightBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'vivid-light',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                float colorDodge(float base, float blend)\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                float vividLight(float base, float blend)\n                {\n                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));\n                }\n\n                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;\n            `\n            },\n            gpu: {\n                functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn colorDodge(base: f32, blend: f32) -> f32\n                {\n                    return min(1.0, base / (1.0-blend));\n                }\n\n                fn vividLight(base: f32, blend: f32) -> f32\n                {\n                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);\n                }\n\n                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        vividLight(base.r, blend.r),\n                        vividLight(base.g, blend.g),\n                        vividLight(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n                `,\n                main: `\n                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n                `\n            }\n        });\n    }\n}\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support.\n * @param failIfMajorPerformanceCaveat - whether to fail if there is a major performance caveat, defaults to false\n * @memberof utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n", "import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support.\n * @param options - The options for requesting a GPU adapter.\n * @memberof utils\n * @function isWebGPUSupported\n * @returns Is WebGPU supported.\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n", "import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * The app module provides a set of classes to use as a starting point when building applications.\n *\n * <aside>This module has a mixin for <code>TickerPlugin</code> and <code>ResizePlugin</code>.\n * These will need to be imported if you are managing your own renderer.</aside>\n *\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init();\n *\n * // don't forget to add the canvas to the DOM\n * document.body.appendChild(app.canvas);\n * ```\n * @namespace app\n */\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @example\n * import { ApplicationPlugin } from 'pixi.js';\n *\n * const plugin: ApplicationPlugin = {\n *    init: (options: Partial<ApplicationOptions>) =>\n *    {\n *       // handle init here, use app options if needed\n *    },\n *    destroy: () =>\n *    {\n *       // handle destruction code here\n *    }\n * }\n * @memberof app\n * @see {@link app.ApplicationOptions}\n * @ignore\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link app.Application#init} method.\n * @memberof app\n * @example\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init({\n *    autoStart: false,\n *    resizeTo: window,\n *    sharedTicker: true,\n * });\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * await app.init({ width: 800, height: 600 });\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.canvas);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @memberof app\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @alias _plugins\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /** The root display container that's rendered. */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {rendering.Renderer}\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    /** @ignore */\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @readonly\n     * @member {HTMLCanvasElement}\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n     * @param {object|boolean} [options=false] - The options for destroying the stage.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n     * called as well. `options` will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true,\n     * it should destroy the texture of the child sprite.\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     *  If options.children is set to true,\n     * it should destroy the texture source of the child sprite.\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true,\n     * it should destroy the context of the child graphics.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n", "import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n            } = textures[charData.page];\n\n            const frameReal = new Rectangle(\n                charData.x + textureFrame.x,\n                charData.y + textureFrame.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n", "import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { CacheParser } from '../../../assets/cache/CacheParser';\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParserAdvanced } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheBitmapFont',\n    },\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n} satisfies CacheParser<BitmapFont>;\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    name: 'loadBitmapFont',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        // if we have a distance field - we can assume this is a signed distance field font\n        // and we should use force linear filtering and no alpha premultiply\n        const textureOptions = (bitmapFontData.distanceField) ? {\n            scaleMode: 'linear',\n            alphaMode: 'premultiply-alpha-on-upload',\n            autoGenerateMipmaps: false,\n            resolution: 1,\n        } : {};\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url.src]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} satisfies LoaderParserAdvanced<string, BitmapFont, BitmapFont>;\n", "import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof assets\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @memberof assets\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n", "export async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @memberof assets\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @memberof assets\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n", "const inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @memberof assets\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @memberof assets\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @memberof assets\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @memberof assets\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser should have a name`);\n                    // #endif\n                }\n                else if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n", "export function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n", "import { path } from '../../utils/path';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadJson',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @memberof assets\n */\nexport const loadTxt = {\n\n    name: 'loadTxt',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Data for loading a font\n * @memberof assets\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @memberof assets\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @memberof assets\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadWebFont',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            Cache.set(`${name}-and-url`, {\n                url,\n                fontFaces,\n            });\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) =>\n            {\n                Cache.remove(t.family);\n                DOMAdapter.get().getFontFaceSet().delete(t);\n            });\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n", "import { Resolver } from '../../assets/resolver/Resolver';\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @memberof utils\n * @function getResolutionOfUrl\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue = 1): number\n{\n    const resolution = Resolver.RETINA_PREFIX?.exec(url);\n\n    if (resolution)\n    {\n        return parseFloat(resolution[1]);\n    }\n\n    return defaultValue;\n}\n", "import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the [loadSVG]{@link assets.loadSVG} plugin.\n * @see assets.loadSVG\n * @memberof assets\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    name: 'loadSVG',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: HTMLImageElement['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const blobUrl = URL.createObjectURL(blob);\n\n    const image = new Image();\n\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    URL.revokeObjectURL(blobUrl);\n\n    // convert to canvas...\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n", "import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    private readonly _workerPool: Worker[];\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link assets.loadTextures} plugin.\n * @see assets.loadTextures\n * @memberof assets\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link assets.LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof assets\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @memberof assets\n */\nexport function crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @memberof assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Asset.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @memberof assets\n */\nexport const loadVideoTextures = {\n\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<VideoSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: VideoSourceOptions = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, VideoSourceOptions>;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @memberof assets\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @memberof assets\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n", "/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback for when progress on asset loading is made.\n * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n * of the assets loaded.\n * @memberof assets\n * @callback ProgressCallback\n * @param {number} progress - The percentage (0.0 - 1.0) of the assets loaded.\n * @returns {void}\n * @example\n * (progress) => console.log(progress * 100 + '%')\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for the Assets Class.\n * @memberof assets\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is preferred) or a single resolutions  */\n        resolution?: number | number[];\n        /**\n         * the formats you prefer, by default this will be:\n         * ['avif', 'webp', 'png', 'jpg', 'jpeg', 'webm', 'mp4', 'm4v', 'ogv']\n         */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * If true, don't attempt to detect whether browser has preferred formats available.\n     * May result in increased performance as it skips detection step.\n     */\n    skipDetections?: boolean;\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @namespace assets\n *\n * Use the singleton class [Assets]{@link assets.Assets} to easily load and manage all your assets.\n *\n * ```typescript\n * import { Assets, Texture } from 'pixi.js';\n *\n * const bunnyTexture = await Assets.load<Texture>('bunny.png');\n * const sprite = new Sprite(bunnyTexture);\n * ```\n *\n * Check out the sections below for more information on how to deal with assets.\n *\n * <details id=\"assets-loading\">\n *\n * <summary>Asset Loading</summary>\n *\n * Do not be afraid to load things multiple times - under the hood, it will **NEVER** load anything more than once.\n *\n * *For example:*\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box Pixi supports the following files:\n * - Textures (**_avif_**, **_webp_**, **_png_**, **_jpg_**, **_gif_**, **_svg_**) via {@link assets.loadTextures}, {@link assets.loadSvg}\n * - Video Textures (**_mp4_**, **_m4v_**, **_webm_**, **_ogg_**, **_ogv_**, **_h264_**, **_avi_**, **_mov_**) via {@link assets.loadVideoTextures}\n * - Sprite sheets (**_json_**) via {@link assets.spritesheetAsset}\n * - Bitmap fonts (**_xml_**, **_fnt_**, **_txt_**) via {@link assets.loadBitmapFont}\n * - Web fonts (**_ttf_**, **_woff_**, **_woff2_**) via {@link assets.loadWebFont}\n * - JSON files (**_json_**) via {@link assets.loadJson}\n * - Text Files (**_txt_**) via {@link assets.loadTxt}\n * <br/>\n * More types can be added fairly easily by creating additional {@link assets.LoaderParser LoaderParsers}.\n * </details>\n *\n * <details id=\"textures\">\n *\n * <summary>Textures</summary>\n *\n * - Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via `Texture.from()` (see {@link core.from|Texture.from})\n * and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist\n * (for example you prefer 2x resolutions images but only 1x is available for that texture,\n * the Assets manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name: `my-spritesheet{resolution}.{imageFormat}.json`\n * <br><br>For example:\n *   - `my-spritesheet@2x.webp.json`* // 2x resolution, WebP sprite sheet*\n *   - `my-spritesheet@0.5x.png.json`* // 0.5x resolution, png sprite sheet*\n * - This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n * </details>\n *\n * <details id=\"fonts\">\n *\n * <summary>Fonts</summary>\n *\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * </details>\n *\n * <details id=\"background-loading\">\n *\n * <summary>Background Loading</summary>\n *\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n * </details>\n *\n * <details id=\"manifests-and-bundles\">\n *\n * <summary>Manifest and Bundles</summary>\n *\n * - {@link assets.AssetsManifest Manifest} is a descriptor that contains a list of all assets and their properties.\n * - {@link assets.AssetsBundle Bundles} are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     alias: 'background',\n *                     src: 'sunset.png',\n *                 },\n *                 {\n *                     alias: 'bar',\n *                     src: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     alias: 'character',\n *                     src: 'robot.png',\n *                 },\n *                 {\n *                     alias: 'enemy',\n *                     src: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Assets.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * </details>\n */\n\n/**\n * The global Assets class, it's a singleton so you don't need to instantiate it.\n *\n * **The `Assets` class has four main responsibilities:**\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n *\n * **It also has a few advanced features:**\n * 1. Allows developers to provide a {@link assets.Manifest} upfront of all assets and help manage\n * them via {@link assets.AssetsBundles Bundles}.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n * @memberof assets\n * @class Assets\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /** The loader, loads stuff! */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {assets.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Assets manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n     *\n     * Assets.add({\n     *     alias: 'bunnyBooBoo',\n     *     src: [\n     *         'bunny.png',\n     *         'bunny.webp',\n     *    ],\n     * });\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param assets - the unresolved assets to add to the resolver\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Assets.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your initial load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\n\nimport type { FormatDetectionParser } from '../../assets/detections/types';\n\nexport const detectBasis = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 3,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (await isWebGPUSupported()) return true;\n        if (isWebGLSupported()) return true;\n\n        return false;\n    },\n    add: async (formats) => [...formats, 'basis'],\n    remove: async (formats) => formats.filter((f) => f !== 'basis'),\n} as FormatDetectionParser;\n", "import { TextureSource } from './TextureSource';\n\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport class CompressedSource extends TextureSource<Uint8Array[]>\n{\n    public readonly uploadMethodId = 'compressed';\n\n    constructor(options: TextureSourceOptions)\n    {\n        super(options);\n\n        this.resource = options.resource;\n        this.mipLevelCount = this.resource.length;\n    }\n}\n", "import type { TEXTURE_FORMATS } from '../../../shared/texture/const';\n\nlet supportedGLCompressedTextureFormats: TEXTURE_FORMATS[];\n\nexport function getSupportedGlCompressedTextureFormats(): TEXTURE_FORMATS[]\n{\n    if (supportedGLCompressedTextureFormats) return supportedGLCompressedTextureFormats;\n\n    // TODO: can we use already created context (webgl or webgl2)?\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl');\n\n    if (!gl)\n    {\n        return [];\n    }\n\n    supportedGLCompressedTextureFormats = [\n        // BC compressed formats usable if \"texture-compression-bc\" is both\n        // supported by the device/user agent and enabled in requestDevice.\n        // 'bc6h-rgb-ufloat'\n        // 'bc6h-rgb-float'\n        // 'bc7-rgba-unorm',\n        // 'bc7-rgba-unorm-srgb',\n        ...gl.getExtension('EXT_texture_compression_bptc') ? [\n            'bc6h-rgb-ufloat',\n            'bc6h-rgb-float',\n            'bc7-rgba-unorm',\n            'bc7-rgba-unorm-srgb',\n        ] : [],\n        // BC compressed formats usable if \"texture-compression-bc\" is both\n        // supported by the device/user agent and enabled in requestDevice.\n        // 'bc1-rgba-unorm',\n        // 'bc1-rgba-unorm-srgb',\n        // 'bc4-r-unorm'\n        // 'bc4-r-snorm'\n        // 'bc5-rg-unorm'\n        // 'bc5-rg-snorm'\n        ...gl.getExtension('WEBGL_compressed_texture_s3tc') ? [\n            'bc1-rgba-unorm',\n            'bc2-rgba-unorm',\n            'bc3-rgba-unorm',\n        ] : [],\n        ...gl.getExtension('WEBGL_compressed_texture_s3tc_srgb') ? [\n            'bc1-rgba-unorm-srgb',\n            'bc2-rgba-unorm-srgb',\n            'bc3-rgba-unorm-srgb',\n        ] : [],\n\n        ...gl.getExtension('EXT_texture_compression_rgtc') ? [\n            'bc4-r-unorm',\n            'bc4-r-snorm',\n            'bc5-rg-unorm',\n            'bc5-rg-snorm',\n        ] : [],\n\n        // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n        // supported by the device/user agent and enabled in requestDevice.\n        ...gl.getExtension('WEBGL_compressed_texture_etc') ? [\n            'etc2-rgb8unorm',\n            'etc2-rgb8unorm-srgb',\n            'etc2-rgba8unorm',\n            'etc2-rgba8unorm-srgb',\n            'etc2-rgb8a1unorm',\n            'etc2-rgb8a1unorm-srgb',\n            'eac-r11unorm',\n            'eac-rg11unorm',\n        ] : [],\n        // 'eac-r11snorm',\n        // 'eac-rg11snorm',\n        // ASTC compressed formats usable if \"texture-compression-astc\" is both\n        // supported by the device/user agent and enabled in requestDevice.\n        ...gl.getExtension('WEBGL_compressed_texture_astc') ? [\n            'astc-4x4-unorm',\n            'astc-4x4-unorm-srgb',\n            'astc-5x4-unorm',\n            'astc-5x4-unorm-srgb',\n            'astc-5x5-unorm',\n            'astc-5x5-unorm-srgb',\n            'astc-6x5-unorm',\n            'astc-6x5-unorm-srgb',\n            'astc-6x6-unorm',\n            'astc-6x6-unorm-srgb',\n            'astc-8x5-unorm',\n            'astc-8x5-unorm-srgb',\n            'astc-8x6-unorm',\n            'astc-8x6-unorm-srgb',\n            'astc-8x8-unorm',\n            'astc-8x8-unorm-srgb',\n            'astc-10x5-unorm',\n            'astc-10x5-unorm-srgb',\n            'astc-10x6-unorm',\n            'astc-10x6-unorm-srgb',\n            'astc-10x8-unorm',\n            'astc-10x8-unorm-srgb',\n            'astc-10x10-unorm',\n            'astc-10x10-unorm-srgb',\n            'astc-12x10-unorm',\n            'astc-12x10-unorm-srgb',\n            'astc-12x12-unorm',\n            'astc-12x12-unorm-srgb'\n        ] : [],\n    ] as TEXTURE_FORMATS[];\n\n    return supportedGLCompressedTextureFormats;\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { TEXTURE_FORMATS } from '../../../shared/texture/const';\n\nlet supportedGPUCompressedTextureFormats: TEXTURE_FORMATS[];\n\nexport async function getSupportedGPUCompressedTextureFormats(): Promise<TEXTURE_FORMATS[]>\n{\n    if (supportedGPUCompressedTextureFormats) return supportedGPUCompressedTextureFormats;\n\n    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter();\n\n    supportedGPUCompressedTextureFormats = [\n        ...adapter.features.has('texture-compression-bc') ? [\n            // BC compressed formats usable if \"texture-compression-bc\" is both\n            // supported by the device/user agent and enabled in requestDevice.\n            'bc1-rgba-unorm',\n            'bc1-rgba-unorm-srgb',\n            'bc2-rgba-unorm',\n            'bc2-rgba-unorm-srgb',\n            'bc3-rgba-unorm',\n            'bc3-rgba-unorm-srgb',\n            'bc4-r-unorm',\n            'bc4-r-snorm',\n            'bc5-rg-unorm',\n            'bc5-rg-snorm',\n            'bc6h-rgb-ufloat',\n            'bc6h-rgb-float',\n            'bc7-rgba-unorm',\n            'bc7-rgba-unorm-srgb',\n        ] : [],\n        ...adapter.features.has('texture-compression-etc2') ? [\n            // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n            // supported by the device/user agent and enabled in requestDevice.\n            'etc2-rgb8unorm',\n            'etc2-rgb8unorm-srgb',\n            'etc2-rgb8a1unorm',\n            'etc2-rgb8a1unorm-srgb',\n            'etc2-rgba8unorm',\n            'etc2-rgba8unorm-srgb',\n            'eac-r11unorm',\n            'eac-r11snorm',\n            'eac-rg11unorm',\n            'eac-rg11snorm',\n        ] : [],\n        ...adapter.features.has('texture-compression-astc') ? [\n            // ASTC compressed formats usable if \"texture-compression-astc\" is both\n            // supported by the device/user agent and enabled in requestDevice.\n            'astc-4x4-unorm',\n            'astc-4x4-unorm-srgb',\n            'astc-5x4-unorm',\n            'astc-5x4-unorm-srgb',\n            'astc-5x5-unorm',\n            'astc-5x5-unorm-srgb',\n            'astc-6x5-unorm',\n            'astc-6x5-unorm-srgb',\n            'astc-6x6-unorm',\n            'astc-6x6-unorm-srgb',\n            'astc-8x5-unorm',\n            'astc-8x5-unorm-srgb',\n            'astc-8x6-unorm',\n            'astc-8x6-unorm-srgb',\n            'astc-8x8-unorm',\n            'astc-8x8-unorm-srgb',\n            'astc-10x5-unorm',\n            'astc-10x5-unorm-srgb',\n            'astc-10x6-unorm',\n            'astc-10x6-unorm-srgb',\n            'astc-10x8-unorm',\n            'astc-10x8-unorm-srgb',\n            'astc-10x10-unorm',\n            'astc-10x10-unorm-srgb',\n            'astc-12x10-unorm',\n            'astc-12x10-unorm-srgb',\n            'astc-12x12-unorm',\n            'astc-12x12-unorm-srgb',\n        ] : [],\n    ] as TEXTURE_FORMATS[];\n\n    return supportedGPUCompressedTextureFormats;\n}\n", "import { isWebGLSupported } from '../../../../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../../../../utils/browser/isWebGPUSupported';\nimport { getSupportedGlCompressedTextureFormats } from '../../../gl/texture/utils/getSupportedGlCompressedTextureFormats';\nimport { getSupportedGPUCompressedTextureFormats } from '../../../gpu/texture/utils/getSupportedGPUCompressedTextureFormats';\n\nimport type { TEXTURE_FORMATS } from '../const';\n\nlet supportedCompressedTextureFormats: TEXTURE_FORMATS[];\n\nexport async function getSupportedCompressedTextureFormats(): Promise<TEXTURE_FORMATS[]>\n{\n    if (supportedCompressedTextureFormats !== undefined) return supportedCompressedTextureFormats;\n\n    supportedCompressedTextureFormats = await (async (): Promise<TEXTURE_FORMATS[]> =>\n    {\n        // find only overlapping ones..\n        const _isWebGPUSupported = await isWebGPUSupported();\n        const _isWebGLSupported = isWebGLSupported();\n\n        if (_isWebGPUSupported && _isWebGLSupported)\n        {\n            const gpuTextureFormats = await getSupportedGPUCompressedTextureFormats();\n            const glTextureFormats = getSupportedGlCompressedTextureFormats();\n\n            return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));\n        }\n        else if (_isWebGPUSupported)\n        {\n            return await getSupportedGPUCompressedTextureFormats();\n        }\n        else if (_isWebGLSupported)\n        {\n            return getSupportedGlCompressedTextureFormats();\n        }\n\n        return [];\n    })();\n\n    return supportedCompressedTextureFormats;\n}\n", "import { getSupportedCompressedTextureFormats } from './getSupportedCompressedTextureFormats';\n\nimport type { TEXTURE_FORMATS } from '../const';\n\nexport const nonCompressedFormats: TEXTURE_FORMATS[] = [\n    // 8-bit formats\n    'r8unorm',\n    'r8snorm',\n    'r8uint',\n    'r8sint',\n\n    // 16-bit formats\n    'r16uint',\n    'r16sint',\n    'r16float',\n    'rg8unorm',\n    'rg8snorm',\n    'rg8uint',\n    'rg8sint',\n\n    // 32-bit formats\n    'r32uint',\n    'r32sint',\n    'r32float',\n    'rg16uint',\n    'rg16sint',\n    'rg16float',\n    'rgba8unorm',\n    'rgba8unorm-srgb',\n    'rgba8snorm',\n    'rgba8uint',\n    'rgba8sint',\n    'bgra8unorm',\n    'bgra8unorm-srgb',\n    // Packed 32-bit formats\n    'rgb9e5ufloat',\n    'rgb10a2unorm',\n    'rg11b10ufloat',\n\n    // 64-bit formats\n    'rg32uint',\n    'rg32sint',\n    'rg32float',\n    'rgba16uint',\n    'rgba16sint',\n    'rgba16float',\n\n    // 128-bit formats\n    'rgba32uint',\n    'rgba32sint',\n    'rgba32float',\n\n    // Depth/stencil formats\n    'stencil8',\n    'depth16unorm',\n    'depth24plus',\n    'depth24plus-stencil8',\n    'depth32float',\n\n    // \"depth32float-stencil8\" feature\n    'depth32float-stencil8',\n];\n\nlet supportedTextureFormats: TEXTURE_FORMATS[];\n\nexport async function getSupportedTextureFormats(): Promise<TEXTURE_FORMATS[]>\n{\n    if (supportedTextureFormats !== undefined) return supportedTextureFormats;\n\n    const compressedTextureFormats = await getSupportedCompressedTextureFormats();\n\n    supportedTextureFormats = [\n        ...nonCompressedFormats,\n        ...compressedTextureFormats,\n    ];\n\n    return supportedTextureFormats;\n}\n\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\\n      const images = basisTexture.getNumImages();\\n      const levels = basisTexture.getNumLevels(0);\\n      const success = basisTexture.startTranscoding();\\n      if (!success) {\\n        throw new Error(\\\"startTranscoding failed\\\");\\n      }\\n      const levelBuffers = [];\\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\\n          const levelBuffer = new Uint8Array(transcodeSize);\\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\\n          if (!success2) {\\n            throw new Error(\\\"transcodeImage failed\\\");\\n          }\\n          levelBuffers.push(levelBuffer);\\n        }\\n      }\\n      return levelBuffers;\\n    }\\n\\n    const gpuFormatToBasisTranscoderFormatMap = {\\n      \\\"bc3-rgba-unorm\\\": 3,\\n      // cTFBC3_RGBA\\n      \\\"bc7-rgba-unorm\\\": 6,\\n      // cTFBC7_RGBA,\\n      \\\"etc2-rgba8unorm\\\": 1,\\n      // cTFETC2_RGBA,\\n      \\\"astc-4x4-unorm\\\": 10,\\n      // cTFASTC_4x4_RGBA,\\n      // Uncompressed\\n      rgba8unorm: 13,\\n      // cTFRGBA32,\\n      rgba4unorm: 16\\n      // cTFRGBA4444,\\n    };\\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\\n    }\\n\\n    const settings = {\\n      jsUrl: \\\"basis/basis_transcoder.js\\\",\\n      wasmUrl: \\\"basis/basis_transcoder.wasm\\\"\\n    };\\n    let basisTranscoderFormat;\\n    let basisTranscodedTextureFormat;\\n    let basisPromise;\\n    async function getBasis() {\\n      if (!basisPromise) {\\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\\n        importScripts(absoluteJsUrl);\\n        basisPromise = new Promise((resolve) => {\\n          BASIS({\\n            locateFile: (_file) => absoluteWasmUrl\\n          }).then((module) => {\\n            module.initializeBasis();\\n            resolve(module.BasisFile);\\n          });\\n        });\\n      }\\n      return basisPromise;\\n    }\\n    async function fetchBasisTexture(url, BasisTexture) {\\n      const basisResponse = await fetch(url);\\n      if (basisResponse.ok) {\\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\\n      }\\n      throw new Error(`Failed to load Basis texture: ${url}`);\\n    }\\n    const preferredTranscodedFormat = [\\n      \\\"bc7-rgba-unorm\\\",\\n      \\\"astc-4x4-unorm\\\",\\n      \\\"etc2-rgba8unorm\\\",\\n      \\\"bc3-rgba-unorm\\\",\\n      \\\"rgba8unorm\\\"\\n    ];\\n    async function load(url) {\\n      const BasisTexture = await getBasis();\\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\\n      return {\\n        width: basisTexture.getImageWidth(0, 0),\\n        height: basisTexture.getImageHeight(0, 0),\\n        format: basisTranscodedTextureFormat,\\n        resource: levelBuffers,\\n        alphaMode: \\\"no-premultiply-alpha\\\"\\n      };\\n    }\\n    async function init(jsUrl, wasmUrl, supportedTextures) {\\n      if (jsUrl)\\n        settings.jsUrl = jsUrl;\\n      if (wasmUrl)\\n        settings.wasmUrl = wasmUrl;\\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\\n      await getBasis();\\n    }\\n    const messageHandlers = {\\n      init: async (data) => {\\n        const { jsUrl, wasmUrl, supportedTextures } = data;\\n        await init(jsUrl, wasmUrl, supportedTextures);\\n      },\\n      load: async (data) => {\\n        try {\\n          const textureOptions = await load(data.url);\\n          return {\\n            type: \\\"load\\\",\\n            url: data.url,\\n            success: true,\\n            textureOptions,\\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\\n          };\\n        } catch (e) {\\n          throw e;\\n        }\\n      }\\n    };\\n    self.onmessage = async (messageEvent) => {\\n      const message = messageEvent.data;\\n      const response = await messageHandlers[message.type](message);\\n      if (response) {\\n        self.postMessage(response, response.transferables);\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=basis.worker.mjs.map\n", "export const basisTranscoderUrls = {\n    jsUrl: 'https://files.pixijs.download/transcoders/basis/basis_transcoder.js',\n    wasmUrl: 'https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm',\n};\n\nexport function setBasisTranscoderPath(config: Partial<typeof basisTranscoderUrls>)\n{\n    Object.assign(basisTranscoderUrls, config);\n}\n", "import BasisWorker from 'worker:./basis.worker.ts';\nimport { basisTranscoderUrls } from '../utils/setBasisTranscoderPath';\n\nimport type { TEXTURE_FORMATS } from '../../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\n\nlet basisWorker: Worker;\nconst urlHash: Record<string, (value: any) => void> = {};\n\nfunction getBasisWorker(supportedTextures: TEXTURE_FORMATS[]): Worker\n{\n    if (!basisWorker)\n    {\n        basisWorker = new BasisWorker().worker;\n\n        basisWorker.onmessage = (messageEvent) =>\n        {\n            const { success, url, textureOptions } = messageEvent.data;\n\n            if (!success)\n            {\n                console.warn('Failed to load Basis texture', url);\n            }\n\n            urlHash[url](textureOptions);\n        };\n\n        basisWorker.postMessage({\n            type: 'init',\n            jsUrl: basisTranscoderUrls.jsUrl,\n            wasmUrl: basisTranscoderUrls.wasmUrl,\n            supportedTextures\n        });\n    }\n\n    return basisWorker;\n}\n\nexport function loadBasisOnWorker(\n    url: string,\n    supportedTextures: TEXTURE_FORMATS[]\n): Promise<TextureSourceOptions>\n{\n    const ktxWorker = getBasisWorker(supportedTextures);\n\n    return new Promise((resolve) =>\n    {\n        urlHash[url] = resolve;\n\n        ktxWorker.postMessage({ type: 'load', url });\n    });\n}\n", "import { LoaderParserPriority } from '../../assets/loader/parsers/LoaderParser';\nimport { createTexture } from '../../assets/loader/parsers/textures/utils/createTexture';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { CompressedSource } from '../../rendering/renderers/shared/texture/sources/CompressedSource';\nimport { getSupportedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats';\nimport { loadBasisOnWorker } from './worker/loadBasisOnWorker';\n\nimport type { Loader } from '../../assets/loader/Loader';\nimport type { LoaderParser } from '../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../assets/types';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\n\n/** Loads KTX textures! */\nexport const loadBasis = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadBasis',\n    },\n\n    name: 'loadBasis',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, ['.basis']);\n    },\n\n    async load(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        const supportedTextures = await getSupportedTextureFormats();\n\n        const textureOptions = await loadBasisOnWorker(url, supportedTextures);\n\n        const compressedTextureSource = new CompressedSource(textureOptions);\n\n        return createTexture(compressedTextureSource, loader, url);\n    },\n\n    unload(texture: Texture | Texture[]): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} satisfies LoaderParser<Texture | Texture[], TextureSourceOptions>;\n", "import type { BasisTexture } from '../types';\n\nexport function createLevelBuffers(basisTexture: BasisTexture, basisTranscoderFormat: number): Uint8Array[]\n{\n    const images = basisTexture.getNumImages();\n    const levels = basisTexture.getNumLevels(0);\n\n    const success = basisTexture.startTranscoding();\n\n    if (!success)\n    {\n        throw new Error('startTranscoding failed');\n    }\n\n    const levelBuffers = [];\n\n    for (let levelIndex = 0; levelIndex < levels; ++levelIndex)\n    {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex)\n        {\n            const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n            const levelBuffer = new Uint8Array(transcodeSize);\n\n            const success = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n\n            if (!success)\n            {\n                throw new Error('transcodeImage failed');\n            }\n\n            levelBuffers.push(levelBuffer);\n        }\n    }\n\n    return levelBuffers;\n}\n", "const gpuFormatToBasisTranscoderFormatMap: Record<string, number> = {\n    'bc3-rgba-unorm': 3, // cTFBC3_RGBA\n    'bc7-rgba-unorm': 6, // cTFBC7_RGBA,\n    'etc2-rgba8unorm': 1, // cTFETC2_RGBA,\n    'astc-4x4-unorm': 10, // cTFASTC_4x4_RGBA,\n    // Uncompressed\n    rgba8unorm: 13, // cTFRGBA32,\n    rgba4unorm: 16, // cTFRGBA4444,\n};\n\nexport function gpuFormatToBasisTranscoderFormat(transcoderFormat: string): number\n{\n    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n\n    if (format)\n    {\n        return format;\n    }\n\n    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n}\n", "import type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\n\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n/**\n * DWORD offsets of the DDS file header fields (relative to file start).\n * @ignore\n */\nconst DDS_HEADER_FIELDS = {\n    MAGIC: 0,\n    SIZE: 1,\n    FLAGS: 2,\n    HEIGHT: 3,\n    WIDTH: 4,\n    MIPMAP_COUNT: 7,\n    PIXEL_FORMAT: 19,\n    PF_FLAGS: 20,\n    FOURCC: 21,\n    RGB_BITCOUNT: 22,\n    R_BIT_MASK: 23,\n    G_BIT_MASK: 24,\n    B_BIT_MASK: 25,\n    A_BIT_MASK: 26,\n};\n\n/**\n * DWORD offsets of the DDS_HEADER_DX10 fields.\n * @ignore\n */\nconst DDS_DX10_FIELDS = {\n    DXGI_FORMAT: 0,\n    RESOURCE_DIMENSION: 1,\n    MISC_FLAG: 2,\n    ARRAY_SIZE: 3,\n    MISC_FLAGS2: 4,\n};\n\n/**\n * @see https://docs.microsoft.com/en-us/windows/win32/api/dxgiformat/ne-dxgiformat-dxgi_format\n * This is way over-blown for us! Lend us a hand, and remove the ones that aren't used (but set the remaining\n * ones to their correct value)\n * @ignore\n */\nexport enum DXGI_FORMAT\n    {\n    DXGI_FORMAT_UNKNOWN,\n    DXGI_FORMAT_R32G32B32A32_TYPELESS,\n    DXGI_FORMAT_R32G32B32A32_FLOAT,\n    DXGI_FORMAT_R32G32B32A32_UINT,\n    DXGI_FORMAT_R32G32B32A32_SINT,\n    DXGI_FORMAT_R32G32B32_TYPELESS,\n    DXGI_FORMAT_R32G32B32_FLOAT,\n    DXGI_FORMAT_R32G32B32_UINT,\n    DXGI_FORMAT_R32G32B32_SINT,\n    DXGI_FORMAT_R16G16B16A16_TYPELESS,\n    DXGI_FORMAT_R16G16B16A16_FLOAT,\n    DXGI_FORMAT_R16G16B16A16_UNORM,\n    DXGI_FORMAT_R16G16B16A16_UINT,\n    DXGI_FORMAT_R16G16B16A16_SNORM,\n    DXGI_FORMAT_R16G16B16A16_SINT,\n    DXGI_FORMAT_R32G32_TYPELESS,\n    DXGI_FORMAT_R32G32_FLOAT,\n    DXGI_FORMAT_R32G32_UINT,\n    DXGI_FORMAT_R32G32_SINT,\n    DXGI_FORMAT_R32G8X24_TYPELESS,\n    DXGI_FORMAT_D32_FLOAT_S8X24_UINT,\n    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS,\n    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT,\n    DXGI_FORMAT_R10G10B10A2_TYPELESS,\n    DXGI_FORMAT_R10G10B10A2_UNORM,\n    DXGI_FORMAT_R10G10B10A2_UINT,\n    DXGI_FORMAT_R11G11B10_FLOAT,\n    DXGI_FORMAT_R8G8B8A8_TYPELESS,\n    DXGI_FORMAT_R8G8B8A8_UNORM,\n    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,\n    DXGI_FORMAT_R8G8B8A8_UINT,\n    DXGI_FORMAT_R8G8B8A8_SNORM,\n    DXGI_FORMAT_R8G8B8A8_SINT,\n    DXGI_FORMAT_R16G16_TYPELESS,\n    DXGI_FORMAT_R16G16_FLOAT,\n    DXGI_FORMAT_R16G16_UNORM,\n    DXGI_FORMAT_R16G16_UINT,\n    DXGI_FORMAT_R16G16_SNORM,\n    DXGI_FORMAT_R16G16_SINT,\n    DXGI_FORMAT_R32_TYPELESS,\n    DXGI_FORMAT_D32_FLOAT,\n    DXGI_FORMAT_R32_FLOAT,\n    DXGI_FORMAT_R32_UINT,\n    DXGI_FORMAT_R32_SINT,\n    DXGI_FORMAT_R24G8_TYPELESS,\n    DXGI_FORMAT_D24_UNORM_S8_UINT,\n    DXGI_FORMAT_R24_UNORM_X8_TYPELESS,\n    DXGI_FORMAT_X24_TYPELESS_G8_UINT,\n    DXGI_FORMAT_R8G8_TYPELESS,\n    DXGI_FORMAT_R8G8_UNORM,\n    DXGI_FORMAT_R8G8_UINT,\n    DXGI_FORMAT_R8G8_SNORM,\n    DXGI_FORMAT_R8G8_SINT,\n    DXGI_FORMAT_R16_TYPELESS,\n    DXGI_FORMAT_R16_FLOAT,\n    DXGI_FORMAT_D16_UNORM,\n    DXGI_FORMAT_R16_UNORM,\n    DXGI_FORMAT_R16_UINT,\n    DXGI_FORMAT_R16_SNORM,\n    DXGI_FORMAT_R16_SINT,\n    DXGI_FORMAT_R8_TYPELESS,\n    DXGI_FORMAT_R8_UNORM,\n    DXGI_FORMAT_R8_UINT,\n    DXGI_FORMAT_R8_SNORM,\n    DXGI_FORMAT_R8_SINT,\n    DXGI_FORMAT_A8_UNORM,\n    DXGI_FORMAT_R1_UNORM,\n    DXGI_FORMAT_R9G9B9E5_SHAREDEXP,\n    DXGI_FORMAT_R8G8_B8G8_UNORM,\n    DXGI_FORMAT_G8R8_G8B8_UNORM,\n    DXGI_FORMAT_BC1_TYPELESS,\n    DXGI_FORMAT_BC1_UNORM,\n    DXGI_FORMAT_BC1_UNORM_SRGB,\n    DXGI_FORMAT_BC2_TYPELESS,\n    DXGI_FORMAT_BC2_UNORM,\n    DXGI_FORMAT_BC2_UNORM_SRGB,\n    DXGI_FORMAT_BC3_TYPELESS,\n    DXGI_FORMAT_BC3_UNORM,\n    DXGI_FORMAT_BC3_UNORM_SRGB,\n    DXGI_FORMAT_BC4_TYPELESS,\n    DXGI_FORMAT_BC4_UNORM,\n    DXGI_FORMAT_BC4_SNORM,\n    DXGI_FORMAT_BC5_TYPELESS,\n    DXGI_FORMAT_BC5_UNORM,\n    DXGI_FORMAT_BC5_SNORM,\n    DXGI_FORMAT_B5G6R5_UNORM,\n    DXGI_FORMAT_B5G5R5A1_UNORM,\n    DXGI_FORMAT_B8G8R8A8_UNORM,\n    DXGI_FORMAT_B8G8R8X8_UNORM,\n    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM,\n    DXGI_FORMAT_B8G8R8A8_TYPELESS,\n    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB,\n    DXGI_FORMAT_B8G8R8X8_TYPELESS,\n    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB,\n    DXGI_FORMAT_BC6H_TYPELESS,\n    DXGI_FORMAT_BC6H_UF16,\n    DXGI_FORMAT_BC6H_SF16,\n    DXGI_FORMAT_BC7_TYPELESS,\n    DXGI_FORMAT_BC7_UNORM,\n    DXGI_FORMAT_BC7_UNORM_SRGB,\n    DXGI_FORMAT_AYUV,\n    DXGI_FORMAT_Y410,\n    DXGI_FORMAT_Y416,\n    DXGI_FORMAT_NV12,\n    DXGI_FORMAT_P010,\n    DXGI_FORMAT_P016,\n    DXGI_FORMAT_420_OPAQUE,\n    DXGI_FORMAT_YUY2,\n    DXGI_FORMAT_Y210,\n    DXGI_FORMAT_Y216,\n    DXGI_FORMAT_NV11,\n    DXGI_FORMAT_AI44,\n    DXGI_FORMAT_IA44,\n    DXGI_FORMAT_P8,\n    DXGI_FORMAT_A8P8,\n    DXGI_FORMAT_B4G4R4A4_UNORM,\n    DXGI_FORMAT_P208,\n    DXGI_FORMAT_V208,\n    DXGI_FORMAT_V408,\n    DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE,\n    DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE,\n    DXGI_FORMAT_FORCE_UINT\n}\n\n/**\n * Possible values of the field {@link DDS_DX10_FIELDS.RESOURCE_DIMENSION}\n * @ignore\n */\nexport enum D3D10_RESOURCE_DIMENSION\n    {\n    DDS_DIMENSION_TEXTURE1D = 2,\n    DDS_DIMENSION_TEXTURE2D = 3,\n    DDS_DIMENSION_TEXTURE3D = 6\n}\n\nfunction fourCCToInt32(value: string)\n{\n    return value.charCodeAt(0)\n        + (value.charCodeAt(1) << 8)\n        + (value.charCodeAt(2) << 16)\n        + (value.charCodeAt(3) << 24);\n}\n\n// Four character codes for DXTn formats\n// https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide\n// https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dformat\nexport enum D3DFMT\n    {\n    UNKNOWN = 0,\n    R8G8B8 = 20,\n    A8R8G8B8 = 21,\n    X8R8G8B8 = 22,\n    R5G6B5 = 23,\n    X1R5G5B5 = 24,\n    A1R5G5B5 = 25,\n    A4R4G4B4 = 26,\n    R3G3B2 = 27,\n    A8 = 28,\n    A8R3G3B2 = 29,\n    X4R4G4B4 = 30,\n    A2B10G10R10 = 31,\n    A8B8G8R8 = 32,\n    X8B8G8R8 = 33,\n    G16R16 = 34,\n    A2R10G10B10 = 35,\n    A16B16G16R16 = 36,\n    A8P8 = 40,\n    P8 = 41,\n    L8 = 50,\n    A8L8 = 51,\n    A4L4 = 52,\n    V8U8 = 60,\n    L6V5U5 = 61,\n    X8L8V8U8 = 62,\n    Q8W8V8U8 = 63,\n    V16U16 = 64,\n    A2W10V10U10 = 67,\n    Q16W16V16U16 = 110,\n    R16F = 111,\n    G16R16F = 112,\n    A16B16G16R16F = 113,\n    R32F = 114,\n    G32R32F = 115,\n    A32B32G32R32F = 116,\n    UYVY = fourCCToInt32('UYVY'),\n    R8G8_B8G8 = fourCCToInt32('RGBG'),\n    YUY2 = fourCCToInt32('YUY2'),\n    D3DFMT_G8R8_G8B8 = fourCCToInt32('GRGB'),\n    DXT1 = fourCCToInt32('DXT1'),\n    DXT2 = fourCCToInt32('DXT2'),\n    DXT3 = fourCCToInt32('DXT3'),\n    DXT4 = fourCCToInt32('DXT4'),\n    DXT5 = fourCCToInt32('DXT5'),\n    ATI1 = fourCCToInt32('ATI1'),\n    AT1N = fourCCToInt32('AT1N'),\n    ATI2 = fourCCToInt32('ATI2'),\n    AT2N = fourCCToInt32('AT2N'),\n    BC4U = fourCCToInt32('BC4U'),\n    BC4S = fourCCToInt32('BC4S'),\n    BC5U = fourCCToInt32('BC5U'),\n    BC5S = fourCCToInt32('BC5S'),\n\n    DX10 = fourCCToInt32('DX10'),\n}\n\n/**\n * Maps `FOURCC_*` formats to {@link TEXTURE_FORMATS}.\n * https://en.wikipedia.org/wiki/S3_Texture_Compression#S3TC_format_comparison\n * https://github.com/microsoft/DirectXTex/blob/main/DDSTextureLoader/DDSTextureLoader11.cpp\n * @ignore\n */\nexport const FOURCC_TO_TEXTURE_FORMAT: { [id: number]: TEXTURE_FORMATS } = {\n    [D3DFMT.DXT1]: 'bc1-rgba-unorm',\n    [D3DFMT.DXT2]: 'bc2-rgba-unorm',\n    [D3DFMT.DXT3]: 'bc2-rgba-unorm',\n    [D3DFMT.DXT4]: 'bc3-rgba-unorm',\n    [D3DFMT.DXT5]: 'bc3-rgba-unorm',\n\n    [D3DFMT.ATI1]: 'bc4-r-unorm',\n    [D3DFMT.BC4U]: 'bc4-r-unorm',\n    [D3DFMT.BC4S]: 'bc4-r-snorm',\n\n    [D3DFMT.ATI2]: 'bc5-rg-unorm',\n    [D3DFMT.BC5U]: 'bc5-rg-unorm',\n    [D3DFMT.BC5S]: 'bc5-rg-snorm',\n\n    [D3DFMT.A16B16G16R16]: 'rgba16uint',\n    [D3DFMT.Q16W16V16U16]: 'rgba16sint',\n    [D3DFMT.R16F]: 'r16float',\n    [D3DFMT.G16R16F]: 'rg16float',\n    [D3DFMT.A16B16G16R16F]: 'rgba16float',\n    [D3DFMT.R32F]: 'r32float',\n    [D3DFMT.G32R32F]: 'rg32float',\n    [D3DFMT.A32B32G32R32F]: 'rgba32float',\n};\n\n/**\n * Maps {@link DXGI_FORMAT} to {@link TEXTURE_FORMATS}\n * @ignore\n */\nexport const DXGI_TO_TEXTURE_FORMAT: { [id: number]: TEXTURE_FORMATS } = {\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS]: 'bc1-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM]: 'bc1-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB]: 'bc1-rgba-unorm-srgb',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS]: 'bc2-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM]: 'bc2-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB]: 'bc2-rgba-unorm-srgb',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS]: 'bc3-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM]: 'bc3-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB]: 'bc3-rgba-unorm-srgb',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC4_TYPELESS]: 'bc4-r-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC4_UNORM]: 'bc4-r-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC4_SNORM]: 'bc4-r-snorm',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC5_TYPELESS]: 'bc5-rg-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC5_UNORM]: 'bc5-rg-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC5_SNORM]: 'bc5-rg-snorm',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC6H_TYPELESS]: 'bc6h-rgb-ufloat',\n    [DXGI_FORMAT.DXGI_FORMAT_BC6H_UF16]: 'bc6h-rgb-ufloat',\n    [DXGI_FORMAT.DXGI_FORMAT_BC6H_SF16]: 'bc6h-rgb-float',\n\n    [DXGI_FORMAT.DXGI_FORMAT_BC7_TYPELESS]: 'bc7-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC7_UNORM]: 'bc7-rgba-unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_BC7_UNORM_SRGB]: 'bc7-rgba-unorm-srgb',\n\n    [DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM]: 'rgba8unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB]: 'rgba8unorm-srgb',\n    [DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM]: 'bgra8unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB]: 'bgra8unorm-srgb',\n    [DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT]: 'r32float',\n\n    [DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM]: 'rg8unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_R16_UNORM]: 'r16uint',\n\n    [DXGI_FORMAT.DXGI_FORMAT_R8_UNORM]: 'r8unorm',\n    [DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM]: 'rgb10a2unorm',\n\n    [DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_UNORM]: 'rgba16uint',\n    [DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_SNORM]: 'rgba16sint',\n    [DXGI_FORMAT.DXGI_FORMAT_R16G16B16A16_FLOAT]: 'rgba16float',\n    [DXGI_FORMAT.DXGI_FORMAT_R16_FLOAT]: 'r16float',\n    [DXGI_FORMAT.DXGI_FORMAT_R16G16_FLOAT]: 'rg16float',\n    [DXGI_FORMAT.DXGI_FORMAT_R32G32_FLOAT]: 'rg32float',\n    [DXGI_FORMAT.DXGI_FORMAT_R32G32B32A32_FLOAT]: 'rgba32float',\n\n};\n\nexport const DDS = {\n    MAGIC_VALUE: 0x20534444,\n    MAGIC_SIZE: 4,\n    HEADER_SIZE: 124,\n    HEADER_DX10_SIZE: 20,\n    PIXEL_FORMAT_FLAGS: {\n        // PIXEL_FORMAT flags\n        // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h\n        // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat\n        ALPHAPIXELS: 0x1,\n        ALPHA: 0x2,\n        FOURCC: 0x4,\n        RGB: 0x40,\n        RGBA: 0x41,\n        YUV: 0x200,\n        LUMINANCE: 0x20000,\n        LUMINANCEA: 0x20001,\n    },\n\n    RESOURCE_MISC_TEXTURECUBE: 0x4,\n\n    HEADER_FIELDS: DDS_HEADER_FIELDS,\n    HEADER_DX10_FIELDS: DDS_DX10_FIELDS,\n    DXGI_FORMAT,\n    D3D10_RESOURCE_DIMENSION,\n    D3DFMT\n};\n\n// formats and block size (in bytes)\nexport const TEXTURE_FORMAT_BLOCK_SIZE: Record<string, number> = {\n    'bc1-rgba-unorm':  8,\n    'bc1-rgba-unorm-srgb':  8,\n    'bc2-rgba-unorm':  16,\n    'bc2-rgba-unorm-srgb':  16,\n    'bc3-rgba-unorm':  16,\n    'bc3-rgba-unorm-srgb':  16,\n    'bc4-r-unorm':  8,\n    'bc4-r-snorm':  8,\n    'bc5-rg-unorm':  16,\n    'bc5-rg-snorm':  16,\n    'bc6h-rgb-ufloat':  16,\n    'bc6h-rgb-float':  16,\n    'bc7-rgba-unorm':  16,\n    'bc7-rgba-unorm-srgb':  16\n};\n", "import { DDS, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './const';\n\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\n\nexport function parseDDS(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>\n{\n    const {\n        format,\n        fourCC,\n        width,\n        height,\n        dataOffset,\n        mipmapCount,\n    } = parseDDSHeader(arrayBuffer);\n\n    if (!supportedFormats.includes(format))\n    {\n        throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);\n    }\n\n    if (mipmapCount <= 1)\n    { // No need bothering with the imageSize calculation!\n        return {\n            format,\n            width,\n            height,\n            resource: [new Uint8Array(arrayBuffer, dataOffset)],\n            alphaMode: 'no-premultiply-alpha',\n        } as TextureSourceOptions;\n    }\n\n    const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);\n\n    const textureOptions: TextureSourceOptions = {\n        format,\n        width,\n        height,\n        resource: levelBuffers,\n        alphaMode: 'no-premultiply-alpha'\n    };\n\n    return textureOptions;\n}\n\nfunction getMipmapLevelBuffers(format: TEXTURE_FORMATS, width: number, height: number,\n    dataOffset: any, mipmapCount: number, arrayBuffer: ArrayBuffer)\n{\n    const levelBuffers = [];\n    const blockBytes = TEXTURE_FORMAT_BLOCK_SIZE[format];\n\n    let mipWidth = width;\n    let mipHeight = height;\n    let offset = dataOffset;\n\n    for (let level = 0; level < mipmapCount; ++level)\n    {\n        const byteLength = blockBytes\n            ? Math.max(4, mipWidth) / 4 * Math.max(4, mipHeight) / 4 * blockBytes\n            : mipWidth * mipHeight * 4;\n\n        const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);\n\n        levelBuffers.push(levelBuffer);\n\n        offset += byteLength;\n\n        mipWidth = Math.max(mipWidth >> 1, 1);\n        mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n\n    return levelBuffers;\n}\n\nfunction parseDDSHeader(buffer: ArrayBuffer)\n{\n    const header = new Uint32Array(buffer, 0, DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n\n    if (header[DDS.HEADER_FIELDS.MAGIC] !== DDS.MAGIC_VALUE)\n    {\n        throw new Error('Invalid magic number in DDS header');\n    }\n\n    // DDS header fields\n    const height = header[DDS.HEADER_FIELDS.HEIGHT];\n    const width = header[DDS.HEADER_FIELDS.WIDTH];\n    const mipmapCount = Math.max(1, header[DDS.HEADER_FIELDS.MIPMAP_COUNT]);\n    const flags = header[DDS.HEADER_FIELDS.PF_FLAGS];\n    const fourCC = header[DDS.HEADER_FIELDS.FOURCC];\n    const format = getTextureFormat(header, flags, fourCC, buffer);\n\n    const dataOffset = DDS.MAGIC_SIZE + DDS.HEADER_SIZE\n        + ((fourCC === DDS.D3DFMT.DX10) ? DDS.HEADER_DX10_SIZE : 0);\n\n    return {\n        format,\n        fourCC,\n        width,\n        height,\n        dataOffset,\n        mipmapCount\n    };\n}\n\nfunction getTextureFormat(header: Uint32Array, flags: number, fourCC: number, buffer: ArrayBuffer)\n{\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.FOURCC)\n    {\n        if (fourCC === DDS.D3DFMT.DX10)\n        {\n            const dx10Header = new Uint32Array(\n                buffer,\n                DDS.MAGIC_SIZE + DDS.HEADER_SIZE, // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER\n                DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n\n            const miscFlag = dx10Header[DDS.HEADER_DX10_FIELDS.MISC_FLAG];\n\n            if (miscFlag === DDS.RESOURCE_MISC_TEXTURECUBE)\n            {\n                throw new Error('DDSParser does not support cubemap textures');\n            }\n\n            const resourceDimension = dx10Header[DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];\n\n            if (resourceDimension === DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n            {\n                throw new Error('DDSParser does not supported 3D texture data');\n            }\n\n            const dxgiFormat = dx10Header[DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];\n\n            if (dxgiFormat in DXGI_TO_TEXTURE_FORMAT)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[dxgiFormat];\n            }\n\n            throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n        }\n\n        if (fourCC in FOURCC_TO_TEXTURE_FORMAT)\n        {\n            return FOURCC_TO_TEXTURE_FORMAT[fourCC];\n        }\n\n        throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);\n    }\n\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.RGB || flags & DDS.PIXEL_FORMAT_FLAGS.RGBA)\n    {\n        return getUncompressedTextureFormat(header);\n    }\n\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.YUV)\n    {\n        throw new Error('DDSParser does not supported YUV uncompressed texture data.');\n    }\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA)\n    {\n        throw new Error('DDSParser does not support single-channel (lumninance) texture data!');\n    }\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS)\n    {\n        throw new Error('DDSParser does not support single-channel (alpha) texture data!');\n    }\n\n    throw new Error('DDSParser failed to load a texture file due to an unknown reason!');\n}\n\nfunction getUncompressedTextureFormat(header: Uint32Array)\n{\n    const bitCount = header[DDS.HEADER_FIELDS.RGB_BITCOUNT];\n    const rBitMask = header[DDS.HEADER_FIELDS.R_BIT_MASK];\n    const gBitMask = header[DDS.HEADER_FIELDS.G_BIT_MASK];\n    const bBitMask = header[DDS.HEADER_FIELDS.B_BIT_MASK];\n    const aBitMask = header[DDS.HEADER_FIELDS.A_BIT_MASK];\n\n    // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide\n    // https://github.com/microsoft/DirectXTex/blob/main/DDSTextureLoader/DDSTextureLoader11.cpp#L892\n    switch (bitCount)\n    {\n        case 32:\n            if (rBitMask === 0x000000ff && gBitMask === 0x0000ff00 && bBitMask === 0x00ff0000 && aBitMask === 0xff000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];\n            }\n            if (rBitMask === 0x00ff0000 && gBitMask === 0x0000ff00 && bBitMask === 0x000000ff && aBitMask === 0xff000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];\n            }\n            if (rBitMask === 0x3ff00000 && gBitMask === 0x000ffc00 && bBitMask === 0x000003ff && aBitMask === 0xc0000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];\n            }\n            if (rBitMask === 0x0000ffff && gBitMask === 0xffff0000 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];\n            }\n            if (rBitMask === 0xffffffff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];\n            }\n            break;\n        case 24:\n            if (rBitMask === 0xff0000 && gBitMask === 0xff00 && bBitMask === 0xff && aBitMask === 0x8000)\n            {\n                // rgb8unorm not supported?\n                // return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];\n            }\n            break;\n        case 16:\n            if (rBitMask === 0x7c00 && gBitMask === 0x03e0 && bBitMask === 0x001f && aBitMask === 0x8000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];\n            }\n            if (rBitMask === 0xf800 && gBitMask === 0x07e0 && bBitMask === 0x001f && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];\n            }\n            if (rBitMask === 0x0f00 && gBitMask === 0x00f0 && bBitMask === 0x000f && aBitMask === 0xf000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];\n            }\n            if (rBitMask === 0x00ff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0xff00)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];\n            }\n            if (rBitMask === 0xffff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];\n            }\n            break;\n\n        case 8:\n            if (rBitMask === 0xff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];\n            }\n            break;\n    }\n\n    throw new Error(`DDSParser does not support uncompressed texture with configuration:\n                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);\n}\n", "import { LoaderParserPriority } from '../../assets/loader/parsers/LoaderParser';\nimport { createTexture } from '../../assets/loader/parsers/textures/utils/createTexture';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { CompressedSource } from '../../rendering/renderers/shared/texture/sources/CompressedSource';\nimport { getSupportedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats';\nimport { parseDDS } from './parseDDS';\n\nimport type { Loader } from '../../assets/loader/Loader';\nimport type { LoaderParser } from '../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../assets/types';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\n\n/** Loads KTX textures! */\nexport const loadDDS = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadDDS',\n    },\n\n    name: 'loadDDS',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, ['.dds']);\n    },\n\n    async load(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        const supportedTextures = await getSupportedTextureFormats();\n\n        const ddsResponse = await fetch(url);\n\n        const ddsArrayBuffer = await ddsResponse.arrayBuffer();\n\n        const textureOptions = parseDDS(ddsArrayBuffer, supportedTextures);\n\n        const compressedTextureSource = new CompressedSource(textureOptions);\n\n        return createTexture(compressedTextureSource, loader, url);\n    },\n\n    unload(texture: Texture | Texture[]): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} satisfies LoaderParser<Texture | Texture[], TextureSourceOptions>;\n\n", "import type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\n\nexport enum GL_INTERNAL_FORMAT\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    RGBA8_SNORM = 0x8F97,\n    RGBA = 0x1908,\n    RGBA8UI = 0x8D7C,\n    SRGB8_ALPHA8 = 0x8C43,\n    RGBA8I = 0x8D8E,\n    RGBA8 = 0x8058,\n\n    COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0,\n    COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1,\n    COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2,\n    COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919,\n    COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916,\n\n    COMPRESSED_RED_RGTC1_EXT = 0x8DBB,\n    COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC,\n    COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD,\n    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE,\n\n    COMPRESSED_R11_EAC = 0x9270,\n    COMPRESSED_SIGNED_R11_EAC = 0x9271,\n    COMPRESSED_RG11_EAC = 0x9272,\n    COMPRESSED_SIGNED_RG11_EAC = 0x9273,\n    COMPRESSED_RGB8_ETC2 = 0x9274,\n    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\n    COMPRESSED_SRGB8_ETC2 = 0x9275,\n    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,\n    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,\n    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,\n\n    COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0,\n    COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1,\n    COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2,\n    COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3,\n    COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4,\n    COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5,\n    COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6,\n    COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7,\n    COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8,\n    COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9,\n    COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA,\n    COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB,\n    COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC,\n    COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD,\n\n    COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C,\n    COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D,\n    COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E,\n    COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F\n}\n\nenum GL_FORMATS\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\nenum GL_TYPES\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    UNSIGNED_BYTE = 5121,\n    UNSIGNED_SHORT = 5123,\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    UNSIGNED_INT = 5125,\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    UNSIGNED_INT_24_8 = 34042,\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    BYTE = 5120,\n    SHORT = 5122,\n    INT = 5124,\n    FLOAT = 5126,\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    HALF_FLOAT = 36193,\n}\n\nconst INTERNAL_FORMAT_TO_TEXTURE_FORMATS: { [id: number]: TEXTURE_FORMATS } = {\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_S3TC_DXT1_EXT]: 'bc1-rgba-unorm', // TODO: ???\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT1_EXT]: 'bc1-rgba-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT3_EXT]: 'bc2-rgba-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT5_EXT]: 'bc3-rgba-unorm',\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_S3TC_DXT1_EXT]: 'bc1-rgba-unorm-srgb', // TODO: ???\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT]: 'bc1-rgba-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT]: 'bc2-rgba-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT]: 'bc3-rgba-unorm-srgb',\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RED_RGTC1_EXT]: 'bc4-r-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RED_RGTC1_EXT]: 'bc4-r-snorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RED_GREEN_RGTC2_EXT]: 'bc5-rg-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT]: 'bc5-rg-snorm',\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_R11_EAC]: 'eac-r11unorm',\n    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RG11_EAC]: 'eac-rg11snorm',\n    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB8_ETC2]: 'etc2-rgb8unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA8_ETC2_EAC]: 'etc2-rgba8unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ETC2]: 'etc2-rgb8unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: 'etc2-rgba8unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: 'etc2-rgb8a1unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: 'etc2-rgb8a1unorm-srgb',\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_4x4_KHR]: 'astc-4x4-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR]: 'astc-4x4-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_5x4_KHR]: 'astc-5x4-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR]: 'astc-5x4-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_5x5_KHR]: 'astc-5x5-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR]: 'astc-5x5-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_6x5_KHR]: 'astc-6x5-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR]: 'astc-6x5-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_6x6_KHR]: 'astc-6x6-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR]: 'astc-6x6-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x5_KHR]: 'astc-8x5-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR]: 'astc-8x5-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x6_KHR]: 'astc-8x6-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR]: 'astc-8x6-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x8_KHR]: 'astc-8x8-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR]: 'astc-8x8-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x5_KHR]: 'astc-10x5-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR]: 'astc-10x5-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x6_KHR]: 'astc-10x6-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR]: 'astc-10x6-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x8_KHR]: 'astc-10x8-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR]: 'astc-10x8-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x10_KHR]: 'astc-10x10-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR]: 'astc-10x10-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_12x10_KHR]: 'astc-12x10-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR]: 'astc-12x10-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_12x12_KHR]: 'astc-12x12-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR]: 'astc-12x12-unorm-srgb',\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_BPTC_UNORM_EXT]: 'bc7-rgba-unorm',\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT]: 'bc7-rgba-unorm-srgb',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT]: 'bc6h-rgb-float',\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT]: 'bc6h-rgb-ufloat',\n\n    [GL_INTERNAL_FORMAT.SRGB8_ALPHA8]: 'rgba8unorm-srgb',\n\n    [GL_INTERNAL_FORMAT.RGBA8_SNORM]: 'rgba8snorm',\n    [GL_INTERNAL_FORMAT.RGBA8UI]: 'rgba8uint',\n    [GL_INTERNAL_FORMAT.RGBA8I]: 'rgba8sint',\n    [GL_INTERNAL_FORMAT.RGBA]: 'rgba8unorm',\n    // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'\n};\n\n/**\n * The 12-byte KTX file identifier\n * @see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/#2.1\n * @ignore\n */\nconst FILE_IDENTIFIER = [0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A];\n\n/**\n * The value stored in the \"endianness\" field.\n * @see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/#2.2\n * @ignore\n */\n\nconst FIELDS = {\n    FILE_IDENTIFIER: 0,\n    ENDIANNESS: 12,\n    GL_TYPE: 16,\n    GL_TYPE_SIZE: 20,\n    GL_FORMAT: 24,\n    GL_INTERNAL_FORMAT: 28,\n    GL_BASE_INTERNAL_FORMAT: 32,\n    PIXEL_WIDTH: 36,\n    PIXEL_HEIGHT: 40,\n    PIXEL_DEPTH: 44,\n    NUMBER_OF_ARRAY_ELEMENTS: 48,\n    NUMBER_OF_FACES: 52,\n    NUMBER_OF_MIPMAP_LEVELS: 56,\n    BYTES_OF_KEY_VALUE_DATA: 60,\n};\n\nconst FILE_HEADER_SIZE = 64;\nconst ENDIANNESS = 0x04030201;\n\nconst TYPES_TO_BYTES_PER_COMPONENT: { [id: number]: number } = {\n    [GL_TYPES.UNSIGNED_BYTE]: 1,\n    [GL_TYPES.UNSIGNED_SHORT]: 2,\n    [GL_TYPES.INT]: 4,\n    [GL_TYPES.UNSIGNED_INT]: 4,\n    [GL_TYPES.FLOAT]: 4,\n    [GL_TYPES.HALF_FLOAT]: 8,\n};\n\nconst FORMATS_TO_COMPONENTS: { [id: number]: number } = {\n    [GL_FORMATS.RGBA]: 4,\n    [GL_FORMATS.RGB]: 3,\n    [GL_FORMATS.RG]: 2,\n    [GL_FORMATS.RED]: 1,\n    [GL_FORMATS.LUMINANCE]: 1,\n    [GL_FORMATS.LUMINANCE_ALPHA]: 2,\n    [GL_FORMATS.ALPHA]: 1,\n};\n\nconst TYPES_TO_BYTES_PER_PIXEL: { [id: number]: number } = {\n    [GL_TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,\n    [GL_TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,\n    [GL_TYPES.UNSIGNED_SHORT_5_6_5]: 2,\n};\n\nconst INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: { [id: number]: number } = {\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_S3TC_DXT1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT3_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_S3TC_DXT5_EXT]: 1,\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_S3TC_DXT1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT]: 1,\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RED_RGTC1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RED_RGTC1_EXT]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RED_GREEN_RGTC2_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT]: 1,\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_R11_EAC]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RG11_EAC]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB8_ETC2]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA8_ETC2_EAC]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ETC2]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: 0.5,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: 0.5,\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_4x4_KHR]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_5x4_KHR]: 0.8,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR]: 0.8,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_5x5_KHR]: 0.64,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR]: 0.64,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_6x5_KHR]: 0.53375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR]: 0.53375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_6x6_KHR]: 0.445,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR]: 0.445,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x5_KHR]: 0.4,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR]: 0.4,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x6_KHR]: 0.33375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR]: 0.33375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_8x8_KHR]: 0.25,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR]: 0.25,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x5_KHR]: 0.32,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR]: 0.32,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x6_KHR]: 0.26625,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR]: 0.26625,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x8_KHR]: 0.2,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR]: 0.2,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_10x10_KHR]: 0.16,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR]: 0.16,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_12x10_KHR]: 0.13375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR]: 0.13375,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_ASTC_12x12_KHR]: 0.11125,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR]: 0.11125,\n\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGBA_BPTC_UNORM_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT]: 1,\n    [GL_INTERNAL_FORMAT.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT]: 1,\n};\n\nexport const KTX = {\n    FILE_HEADER_SIZE,\n    FILE_IDENTIFIER,\n    FORMATS_TO_COMPONENTS,\n    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,\n    INTERNAL_FORMAT_TO_TEXTURE_FORMATS,\n    FIELDS,\n    TYPES_TO_BYTES_PER_COMPONENT,\n    TYPES_TO_BYTES_PER_PIXEL,\n    ENDIANNESS\n};\n", "import { KTX } from '../ktx2/const';\n\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\n\nexport function parseKTX(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>\n{\n    const dataView = new DataView(arrayBuffer);\n\n    if (!validate(dataView))\n    {\n        throw new Error('Invalid KTX identifier in header');\n    }\n\n    const {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset,\n    } = parseKTXHeader(dataView);\n\n    const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];\n\n    if (!textureFormat)\n    {\n        throw new Error(`Unknown texture format ${glInternalFormat}`);\n    }\n    if (!supportedFormats.includes(textureFormat))\n    {\n        throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);\n    }\n\n    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);\n\n    const imageBuffers = getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset,\n        numberOfMipmapLevels, littleEndian);\n\n    return {\n        format: textureFormat,\n        width: pixelWidth,\n        height: pixelHeight,\n        resource: imageBuffers,\n        alphaMode: 'no-premultiply-alpha'\n    };\n}\n\nfunction getImageBuffers(dataView: DataView, glType: number, imagePixelByteSize: number, pixelWidth: number,\n    pixelHeight: number, offset: number, numberOfMipmapLevels: number, littleEndian: boolean)\n{\n    const alignedWidth = (pixelWidth + 3) & ~3;\n    const alignedHeight = (pixelHeight + 3) & ~3;\n    let imagePixels = pixelWidth * pixelHeight;\n\n    if (glType === 0)\n    {\n        // Align to 16 pixels (4x4 blocks)\n        imagePixels = alignedWidth * alignedHeight;\n    }\n\n    let mipByteSize = imagePixels * imagePixelByteSize;\n    let mipWidth = pixelWidth;\n    let mipHeight = pixelHeight;\n    let alignedMipWidth = alignedWidth;\n    let alignedMipHeight = alignedHeight;\n    let imageOffset = offset;\n\n    const imageBuffers = new Array<Uint8Array>(numberOfMipmapLevels);\n\n    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++)\n    {\n        const imageSize = dataView.getUint32(imageOffset, littleEndian);\n        let elementOffset = imageOffset + 4;\n\n        imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);\n\n        elementOffset += mipByteSize;\n\n        // HINT: Aligns to 4-byte boundary after jumping imageSize (in lieu of mipPadding)\n        imageOffset += imageSize + 4;// (+4 to jump the imageSize field itself)\n        imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - (imageOffset % 4) : imageOffset;\n\n        // Calculate mipWidth, mipHeight for _next_ iteration\n        mipWidth = (mipWidth >> 1) || 1;\n        mipHeight = (mipHeight >> 1) || 1;\n        alignedMipWidth = (mipWidth + 4 - 1) & ~(4 - 1);\n        alignedMipHeight = (mipHeight + 4 - 1) & ~(4 - 1);\n\n        // Each mipmap level is 4-times smaller?\n        mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n    }\n\n    return imageBuffers;\n}\n\nfunction getImagePixelByteSize(glType: number, glFormat: number, glInternalFormat: number)\n{\n    let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n\n    if (glType !== 0)\n    {\n        // Uncompressed texture format\n        if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType])\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];\n        }\n        else\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];\n        }\n    }\n\n    if (imagePixelByteSize === undefined)\n    {\n        throw new Error('Unable to resolve the pixel format stored in the *.ktx file!');\n    }\n\n    return imagePixelByteSize;\n}\n\nfunction parseKTXHeader(dataView: DataView)\n{\n    const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;\n    const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);\n    const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);\n    const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n    const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);\n    const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;// \"pixelHeight = 0\" -> \"1\"\n    const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;// ^^\n    const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;// ^^\n    const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);\n    const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n    const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n\n    if (pixelHeight === 0 || pixelDepth !== 1)\n    {\n        throw new Error('Only 2D textures are supported');\n    }\n    if (numberOfFaces !== 1)\n    {\n        throw new Error('CubeTextures are not supported by KTXLoader yet!');\n    }\n    if (numberOfArrayElements !== 1)\n    {\n        throw new Error('WebGL does not support array textures');\n    }\n\n    return {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData\n    };\n}\n\n/**\n * Checks whether the arrayBuffer contains a valid *.ktx file.\n * @param dataView\n */\nfunction validate(dataView: DataView): boolean\n{\n    // NOTE: Do not optimize this into 3 32-bit integer comparison because the endianness\n    // of the data is not specified.\n    for (let i = 0; i < KTX.FILE_IDENTIFIER.length; i++)\n    {\n        if (dataView.getUint8(i) !== KTX.FILE_IDENTIFIER[i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "import { LoaderParserPriority } from '../../assets/loader/parsers/LoaderParser';\nimport { createTexture } from '../../assets/loader/parsers/textures/utils/createTexture';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { CompressedSource } from '../../rendering/renderers/shared/texture/sources/CompressedSource';\nimport { getSupportedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats';\nimport { parseKTX } from './parseKTX';\n\nimport type { Loader } from '../../assets/loader/Loader';\nimport type { LoaderParser } from '../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../assets/types';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\n\n/** Loads KTX textures! */\nexport const loadKTX = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadKTX',\n    },\n\n    name: 'loadKTX',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.ktx');\n    },\n\n    async load(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        const supportedTextures = await getSupportedTextureFormats();\n\n        const ktxResponse = await fetch(url);\n\n        const ktxArrayBuffer = await ktxResponse.arrayBuffer();\n\n        const textureOptions = parseKTX(ktxArrayBuffer, supportedTextures);\n\n        const compressedTextureSource = new CompressedSource(textureOptions);\n\n        return createTexture(compressedTextureSource, loader, url);\n    },\n\n    unload(texture: Texture | Texture[]): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} satisfies LoaderParser<Texture | Texture[], TextureSourceOptions>;\n\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const converters = {\\n      rgb8unorm: {\\n        convertedFormat: \\\"rgba8unorm\\\",\\n        convertFunction: convertRGBtoRGBA\\n      },\\n      \\\"rgb8unorm-srgb\\\": {\\n        convertedFormat: \\\"rgba8unorm-srgb\\\",\\n        convertFunction: convertRGBtoRGBA\\n      }\\n    };\\n    function convertFormatIfRequired(textureOptions) {\\n      const format = textureOptions.format;\\n      if (converters[format]) {\\n        const convertFunction = converters[format].convertFunction;\\n        const levelBuffers = textureOptions.resource;\\n        for (let i = 0; i < levelBuffers.length; i++) {\\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\\n        }\\n        textureOptions.format = converters[format].convertedFormat;\\n      }\\n    }\\n    function convertRGBtoRGBA(levelBuffer) {\\n      const pixelCount = levelBuffer.byteLength / 3;\\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\\n      for (let i = 0; i < pixelCount; ++i) {\\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\\n      }\\n      return new Uint8Array(levelBufferWithAlpha.buffer);\\n    }\\n\\n    function createLevelBuffersFromKTX(ktxTexture) {\\n      const levelBuffers = [];\\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\\n        const imageData = ktxTexture.getImageData(i, 0, 0);\\n        const levelBuffer = new Uint8Array(imageData.byteLength);\\n        levelBuffer.set(imageData);\\n        levelBuffers.push(levelBuffer);\\n      }\\n      return levelBuffers;\\n    }\\n\\n    const glFormatToGPUFormatMap = {\\n      6408: \\\"rgba8unorm\\\",\\n      32856: \\\"bgra8unorm\\\",\\n      //\\n      32857: \\\"rgb10a2unorm\\\",\\n      33189: \\\"depth16unorm\\\",\\n      33190: \\\"depth24plus\\\",\\n      33321: \\\"r8unorm\\\",\\n      33323: \\\"rg8unorm\\\",\\n      33325: \\\"r16float\\\",\\n      33326: \\\"r32float\\\",\\n      33327: \\\"rg16float\\\",\\n      33328: \\\"rg32float\\\",\\n      33329: \\\"r8sint\\\",\\n      33330: \\\"r8uint\\\",\\n      33331: \\\"r16sint\\\",\\n      33332: \\\"r16uint\\\",\\n      33333: \\\"r32sint\\\",\\n      33334: \\\"r32uint\\\",\\n      33335: \\\"rg8sint\\\",\\n      33336: \\\"rg8uint\\\",\\n      33337: \\\"rg16sint\\\",\\n      33338: \\\"rg16uint\\\",\\n      33339: \\\"rg32sint\\\",\\n      33340: \\\"rg32uint\\\",\\n      33778: \\\"bc2-rgba-unorm\\\",\\n      33779: \\\"bc3-rgba-unorm\\\",\\n      34836: \\\"rgba32float\\\",\\n      34842: \\\"rgba16float\\\",\\n      35056: \\\"depth24plus-stencil8\\\",\\n      35898: \\\"rg11b10ufloat\\\",\\n      35901: \\\"rgb9e5ufloat\\\",\\n      35907: \\\"rgba8unorm-srgb\\\",\\n      // bgra8unorm-srgb\\n      36012: \\\"depth32float\\\",\\n      36013: \\\"depth32float-stencil8\\\",\\n      36168: \\\"stencil8\\\",\\n      36208: \\\"rgba32uint\\\",\\n      36214: \\\"rgba16uint\\\",\\n      36220: \\\"rgba8uint\\\",\\n      36226: \\\"rgba32sint\\\",\\n      36232: \\\"rgba16sint\\\",\\n      36238: \\\"rgba8sint\\\",\\n      36492: \\\"bc7-rgba-unorm\\\",\\n      36756: \\\"r8snorm\\\",\\n      36757: \\\"rg8snorm\\\",\\n      36759: \\\"rgba8snorm\\\",\\n      37496: \\\"etc2-rgba8unorm\\\",\\n      37808: \\\"astc-4x4-unorm\\\"\\n    };\\n    function glFormatToGPUFormat(glInternalFormat) {\\n      const format = glFormatToGPUFormatMap[glInternalFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\\n    }\\n\\n    const vkFormatToGPUFormatMap = {\\n      23: \\\"rgb8unorm\\\",\\n      // VK_FORMAT_R8G8B8_UNORM\\n      37: \\\"rgba8unorm\\\",\\n      // VK_FORMAT_R8G8B8A8_UNORM\\n      43: \\\"rgba8unorm-srgb\\\"\\n      // VK_FORMAT_R8G8B8A8_SRGB\\n      // TODO add more!\\n    };\\n    function vkFormatToGPUFormat(vkFormat) {\\n      const format = vkFormatToGPUFormatMap[vkFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\\n    }\\n\\n    function getTextureFormatFromKTXTexture(ktxTexture) {\\n      if (ktxTexture.classId === 2) {\\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\\n      }\\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\\n    }\\n\\n    const gpuFormatToBasisTranscoderFormatMap = {\\n      \\\"bc3-rgba-unorm\\\": \\\"BC3_RGBA\\\",\\n      \\\"bc7-rgba-unorm\\\": \\\"BC7_M5_RGBA\\\",\\n      \\\"etc2-rgba8unorm\\\": \\\"ETC2_RGBA\\\",\\n      \\\"astc-4x4-unorm\\\": \\\"ASTC_4x4_RGBA\\\",\\n      // Uncompressed\\n      rgba8unorm: \\\"RGBA32\\\",\\n      rg11b10ufloat: \\\"R11F_G11F_B10F\\\"\\n    };\\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\\n      if (format) {\\n        return format;\\n      }\\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\\n    }\\n\\n    const settings = {\\n      jsUrl: \\\"\\\",\\n      wasmUrl: \\\"\\\"\\n    };\\n    let basisTranscoderFormat;\\n    let basisTranscodedTextureFormat;\\n    let ktxPromise;\\n    async function getKTX() {\\n      if (!ktxPromise) {\\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\\n        importScripts(absoluteJsUrl);\\n        ktxPromise = new Promise((resolve) => {\\n          LIBKTX({\\n            locateFile: (_file) => absoluteWasmUrl\\n          }).then((libktx) => {\\n            resolve(libktx);\\n          });\\n        });\\n      }\\n      return ktxPromise;\\n    }\\n    async function fetchKTXTexture(url, ktx) {\\n      const ktx2Response = await fetch(url);\\n      if (ktx2Response.ok) {\\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\\n      }\\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\\n    }\\n    const preferredTranscodedFormat = [\\n      \\\"bc7-rgba-unorm\\\",\\n      \\\"astc-4x4-unorm\\\",\\n      \\\"etc2-rgba8unorm\\\",\\n      \\\"bc3-rgba-unorm\\\",\\n      \\\"rgba8unorm\\\"\\n    ];\\n    async function load(url) {\\n      const ktx = await getKTX();\\n      const ktxTexture = await fetchKTXTexture(url, ktx);\\n      let format;\\n      if (ktxTexture.needsTranscoding) {\\n        format = basisTranscodedTextureFormat;\\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\\n        if (result !== ktx.ErrorCode.SUCCESS) {\\n          throw new Error(\\\"Unable to transcode basis texture.\\\");\\n        }\\n      } else {\\n        format = getTextureFormatFromKTXTexture(ktxTexture);\\n      }\\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\\n      const textureOptions = {\\n        width: ktxTexture.baseWidth,\\n        height: ktxTexture.baseHeight,\\n        format,\\n        mipLevelCount: ktxTexture.numLevels,\\n        resource: levelBuffers,\\n        alphaMode: \\\"no-premultiply-alpha\\\"\\n      };\\n      convertFormatIfRequired(textureOptions);\\n      return textureOptions;\\n    }\\n    async function init(jsUrl, wasmUrl, supportedTextures) {\\n      if (jsUrl)\\n        settings.jsUrl = jsUrl;\\n      if (wasmUrl)\\n        settings.wasmUrl = wasmUrl;\\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\\n      await getKTX();\\n    }\\n    const messageHandlers = {\\n      init: async (data) => {\\n        const { jsUrl, wasmUrl, supportedTextures } = data;\\n        await init(jsUrl, wasmUrl, supportedTextures);\\n      },\\n      load: async (data) => {\\n        try {\\n          const textureOptions = await load(data.url);\\n          return {\\n            type: \\\"load\\\",\\n            url: data.url,\\n            success: true,\\n            textureOptions,\\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\\n          };\\n        } catch (e) {\\n          throw e;\\n        }\\n      }\\n    };\\n    self.onmessage = async (messageEvent) => {\\n      const message = messageEvent.data;\\n      const response = await messageHandlers[message.type]?.(message);\\n      if (response) {\\n        self.postMessage(response, response.transferables);\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=ktx.worker.mjs.map\n", "export const ktxTranscoderUrls = {\n    jsUrl: 'https://files.pixijs.download/transcoders/ktx/libktx.js',\n    wasmUrl: 'https://files.pixijs.download/transcoders/ktx/libktx.wasm'\n};\n\nexport function setKTXTranscoderPath(config: Partial<typeof ktxTranscoderUrls>)\n{\n    Object.assign(ktxTranscoderUrls, config);\n}\n", "import KTXWorker from 'worker:./ktx.worker.ts';\nimport { ktxTranscoderUrls } from '../utils/setKTXTranscoderPath';\n\nimport type { TEXTURE_FORMATS } from '../../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\n\nlet ktxWorker: Worker;\nconst urlHash: Record<string, (value: any) => void> = {};\n\nfunction getKTX2Worker(supportedTextures: TEXTURE_FORMATS[]): Worker\n{\n    if (!ktxWorker)\n    {\n        ktxWorker = new KTXWorker().worker;\n\n        ktxWorker.onmessage = (messageEvent) =>\n        {\n            const { success, url, textureOptions } = messageEvent.data;\n\n            if (!success)\n            {\n                console.warn('Failed to load KTX texture', url);\n            }\n\n            urlHash[url](textureOptions);\n        };\n\n        ktxWorker.postMessage({\n            type: 'init',\n            jsUrl: ktxTranscoderUrls.jsUrl,\n            wasmUrl: ktxTranscoderUrls.wasmUrl,\n            supportedTextures\n        });\n    }\n\n    return ktxWorker;\n}\n\nexport function loadKTX2onWorker(\n    url: string,\n    supportedTextures: TEXTURE_FORMATS[]\n): Promise<TextureSourceOptions>\n{\n    const ktxWorker = getKTX2Worker(supportedTextures);\n\n    return new Promise((resolve) =>\n    {\n        urlHash[url] = resolve;\n\n        ktxWorker.postMessage({ type: 'load', url });\n    });\n}\n", "import { LoaderParserPriority } from '../../assets/loader/parsers/LoaderParser';\nimport { createTexture } from '../../assets/loader/parsers/textures/utils/createTexture';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { CompressedSource } from '../../rendering/renderers/shared/texture/sources/CompressedSource';\nimport { getSupportedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats';\nimport { loadKTX2onWorker } from './worker/loadKTX2onWorker';\n\nimport type { Loader } from '../../assets/loader/Loader';\nimport type { LoaderParser } from '../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../assets/types';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\n\n/** Loads KTX2 textures! */\nexport const loadKTX2 = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadKTX2',\n    },\n\n    name: 'loadKTX2',\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.ktx2');\n    },\n\n    async load(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        const supportedTextures = await getSupportedTextureFormats();\n\n        const textureOptions = await loadKTX2onWorker(url, supportedTextures);\n\n        const compressedTextureSource = new CompressedSource(textureOptions);\n\n        return createTexture(compressedTextureSource, loader, url);\n    },\n\n    async unload(texture: Texture | Texture[]): Promise<void>\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} satisfies LoaderParser<Texture | Texture[], TextureSourceOptions>;\n\n", "import type { TEXTURE_FORMATS } from '../../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\n\ninterface ColorConverter\n{\n    convertedFormat: TEXTURE_FORMATS,\n    convertFunction: (levelBuffer: Uint8Array) => Uint8Array\n}\n\nconst converters: Record<string, ColorConverter> = {\n    rgb8unorm: {\n        convertedFormat: 'rgba8unorm',\n        convertFunction: convertRGBtoRGBA,\n    },\n    'rgb8unorm-srgb': {\n        convertedFormat: 'rgba8unorm-srgb',\n        convertFunction: convertRGBtoRGBA,\n    }\n};\n\nexport function convertFormatIfRequired(textureOptions: TextureSourceOptions)\n{\n    const format = textureOptions.format;\n\n    if (converters[format])\n    {\n        const convertFunction = converters[format].convertFunction;\n\n        const levelBuffers = textureOptions.resource;\n\n        for (let i = 0; i < levelBuffers.length; i++)\n        {\n            levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n\n        textureOptions.format = converters[format].convertedFormat;\n    }\n}\n\nfunction convertRGBtoRGBA(levelBuffer: Uint8Array): Uint8Array\n{\n    const pixelCount = levelBuffer.byteLength / 3;\n\n    const levelBufferWithAlpha = new Uint32Array(pixelCount);\n\n    for (let i = 0; i < pixelCount; ++i)\n    {\n        levelBufferWithAlpha[i] = (levelBuffer[i * 3]) // R\n               + (levelBuffer[(i * 3) + 1] << 8) // G\n               + (levelBuffer[(i * 3) + 2] << 16) // B\n               + 0xff000000; // A (255)\n    }\n\n    return new Uint8Array(levelBufferWithAlpha.buffer);\n}\n", "import type { KTXTexture } from '../types';\n\nexport function createLevelBuffersFromKTX(ktxTexture: KTXTexture): Uint8Array[]\n{\n    const levelBuffers = [];\n\n    // create the levels..\n    for (let i = 0; i < ktxTexture.numLevels; i++)\n    {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n\n        levelBuffer.set(imageData);\n\n        levelBuffers.push(levelBuffer);\n    }\n\n    return levelBuffers;\n}\n", "import type { COMPRESSED_TEXTURE_FORMATS } from '../types';\n\nconst glFormatToGPUFormatMap: Record<number, COMPRESSED_TEXTURE_FORMATS> = {\n    6408: 'rgba8unorm',\n    32856: 'bgra8unorm', //\n    32857: 'rgb10a2unorm',\n    33189: 'depth16unorm',\n    33190: 'depth24plus',\n    33321: 'r8unorm',\n    33323: 'rg8unorm',\n    33325: 'r16float',\n    33326: 'r32float',\n    33327: 'rg16float',\n    33328: 'rg32float',\n    33329: 'r8sint',\n    33330: 'r8uint',\n    33331: 'r16sint',\n    33332: 'r16uint',\n    33333: 'r32sint',\n    33334: 'r32uint',\n    33335: 'rg8sint',\n    33336: 'rg8uint',\n    33337: 'rg16sint',\n    33338: 'rg16uint',\n    33339: 'rg32sint',\n    33340: 'rg32uint',\n    33778: 'bc2-rgba-unorm',\n    33779: 'bc3-rgba-unorm',\n    34836: 'rgba32float',\n    34842: 'rgba16float',\n    35056: 'depth24plus-stencil8',\n    35898: 'rg11b10ufloat',\n    35901: 'rgb9e5ufloat',\n    35907: 'rgba8unorm-srgb', // bgra8unorm-srgb\n    36012: 'depth32float',\n    36013: 'depth32float-stencil8',\n    36168: 'stencil8',\n    36208: 'rgba32uint',\n    36214: 'rgba16uint',\n    36220: 'rgba8uint',\n    36226: 'rgba32sint',\n    36232: 'rgba16sint',\n    36238: 'rgba8sint',\n    36492: 'bc7-rgba-unorm',\n    36756: 'r8snorm',\n    36757: 'rg8snorm',\n    36759: 'rgba8snorm',\n    37496: 'etc2-rgba8unorm',\n    37808: 'astc-4x4-unorm'\n};\n\nexport function glFormatToGPUFormat(glInternalFormat: number): COMPRESSED_TEXTURE_FORMATS\n{\n    const format = glFormatToGPUFormatMap[glInternalFormat];\n\n    if (format)\n    {\n        return format;\n    }\n\n    throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n}\n", "import type { COMPRESSED_TEXTURE_FORMATS } from '../types';\n\nconst vkFormatToGPUFormatMap: Record<number, COMPRESSED_TEXTURE_FORMATS> = {\n    23: 'rgb8unorm', // VK_FORMAT_R8G8B8_UNORM\n    37: 'rgba8unorm', // VK_FORMAT_R8G8B8A8_UNORM\n    43: 'rgba8unorm-srgb', // VK_FORMAT_R8G8B8A8_SRGB\n    // TODO add more!\n};\n\nexport function vkFormatToGPUFormat(vkFormat: number): COMPRESSED_TEXTURE_FORMATS\n{\n    const format = vkFormatToGPUFormatMap[vkFormat];\n\n    if (format)\n    {\n        return format;\n    }\n\n    throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n}\n", "import { glFormatToGPUFormat } from './glFormatToGPUFormat';\nimport { vkFormatToGPUFormat } from './vkFormatToGPUFormat';\n\nimport type { COMPRESSED_TEXTURE_FORMATS, KTXTexture } from '../types';\n\nexport function getTextureFormatFromKTXTexture(ktxTexture: KTXTexture): COMPRESSED_TEXTURE_FORMATS\n{\n    if (ktxTexture.classId === 2)\n    {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n    }\n\n    return glFormatToGPUFormat(ktxTexture.glInternalformat);\n}\n", "const gpuFormatToBasisTranscoderFormatMap: Record<string, string> = {\n    'bc3-rgba-unorm': 'BC3_RGBA',\n    'bc7-rgba-unorm': 'BC7_M5_RGBA',\n    'etc2-rgba8unorm': 'ETC2_RGBA',\n    'astc-4x4-unorm': 'ASTC_4x4_RGBA',\n    // Uncompressed\n    rgba8unorm: 'RGBA32',\n    rg11b10ufloat: 'R11F_G11F_B10F',\n};\n\nexport function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat: string): string\n{\n    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n\n    if (format)\n    {\n        return format;\n    }\n\n    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n}\n", "import { Resolver } from '../../assets/resolver/Resolver';\nimport { checkExtension } from '../../assets/utils/checkExtension';\nimport { ExtensionType } from '../../extensions/Extensions';\n\nimport type { ResolveURLParser } from '../../assets/resolver/types';\n\nexport const validFormats = ['basis', 'bc7', 'bc6h', 'astc', 'etc2', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac'];\n\nexport const resolveCompressedTextureUrl = {\n    extension: ExtensionType.ResolveParser,\n    test: (value: string) =>\n        checkExtension(value, ['.ktx', '.ktx2', '.dds']),\n    parse: (value: string) =>\n    {\n        let format;\n\n        const splitValue = value.split('.');\n\n        if (splitValue.length > 2)\n        {\n            const newFormat = splitValue[splitValue.length - 2];\n\n            if (validFormats.includes(newFormat))\n            {\n                format = newFormat;\n            }\n        }\n        else\n        {\n            format = splitValue[splitValue.length - 1];\n        }\n\n        return {\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format,\n            src: value,\n        };\n    }\n} satisfies ResolveURLParser;\n", "import { ExtensionType } from '../../extensions/Extensions';\n// eslint-disable-next-line max-len\nimport { getSupportedCompressedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { validFormats } from './resolveCompressedTextureUrl';\n\nimport type { FormatDetectionParser } from '../../assets/detections/types';\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\n\nlet compressedTextureExtensions: string[];\n\nexport const detectCompressed = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (await isWebGPUSupported()) return true;\n        if (isWebGLSupported()) return true;\n\n        return false;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        const supportedCompressedTextureFormats = await getSupportedCompressedTextureFormats();\n\n        compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);\n\n        return [...compressedTextureExtensions, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (compressedTextureExtensions)\n        {\n            return formats.filter((f) => !(f in compressedTextureExtensions));\n        }\n\n        return formats;\n    },\n} as FormatDetectionParser;\n\nfunction extractExtensionsForCompressedTextureFormats(formats: TEXTURE_FORMATS[]): string[]\n{\n    const extensions: string[] = ['basis'];\n\n    const dupeMap: Record<string, boolean> = {};\n\n    formats.forEach((format) =>\n    {\n        const extension = format.split('-')[0];\n\n        if (extension && !dupeMap[extension])\n        {\n            dupeMap[extension] = true;\n            extensions.push(extension);\n        }\n    });\n\n    // sort extensions by priority\n    extensions.sort((a, b) =>\n    {\n        const aIndex = validFormats.indexOf(a);\n        const bIndex = validFormats.indexOf(b);\n\n        if (aIndex === -1)\n        {\n            return 1;\n        }\n        if (bIndex === -1)\n        {\n            return -1;\n        }\n\n        return aIndex - bIndex;\n    });\n\n    return extensions;\n}\n", "import { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\ntype RectangleLike = {x: number, y: number, width: number, height: number};\n\n/**\n * The Culler class is responsible for managing and culling containers.\n *\n *\n * Culled containers will not be rendered, and their children will not be processed. This can be useful for\n * performance optimization when dealing with large scenes.\n * @example\n * import { Culler, Container } from 'pixi.js';\n *\n * const culler = new Culler();\n * const stage = new Container();\n *\n * ... set up stage ...\n *\n * culler.cull(stage, { x: 0, y: 0, width: 800, height: 600 });\n * renderer.render(stage);\n * @memberof scene\n */\nexport class Culler\n{\n    /**\n     * Culls the children of a specific container based on the given view. This will also cull items that are not\n     * being explicitly managed by the culler.\n     * @param container - The container to cull.\n     * @param view - The view rectangle.\n     * @param skipUpdateTransform - Whether to skip updating the transform.\n     */\n    public cull(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        this._cullRecursive(container, view, skipUpdateTransform);\n    }\n\n    private _cullRecursive(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        if (container.cullable && container.measurable && container.includeInBuild)\n        {\n            const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds);\n\n            // check view intersection..\n            container.culled = bounds.x >= view.x + view.width\n                || bounds.y >= view.y + view.height\n                || bounds.x + bounds.width <= view.x\n                || bounds.y + bounds.height <= view.y;\n        }\n        else\n        {\n            container.culled = false;\n        }\n\n        // dont process children if not needed\n        if (\n            !container.cullableChildren\n            || container.culled\n            || !container.renderable\n            || !container.measurable\n            || !container.includeInBuild\n        ) return;\n\n        for (let i = 0; i < container.children.length; i++)\n        {\n            this._cullRecursive(container.children[i], view, skipUpdateTransform);\n        }\n    }\n\n    /** A shared instance of the Culler class. */\n    public static shared = new Culler();\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { Culler } from './Culler';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\n\n/**\n * An {@link app.Application} plugin that will automatically cull your stage using the renderers screen size.\n * @example\n * import { extensions, CullerPlugin } from 'pixi.js';\n *\n * extensions.add(CullerPlugin);\n * @memberof app\n * @see {@link scene.Culler}\n */\nexport class CullerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        priority: 10,\n        type: ExtensionType.Application,\n        name: 'culler',\n    };\n\n    public static renderer: Renderer;\n    public static stage: Container;\n    public static render: () => void;\n    private static _renderRef: () => void;\n\n    public static init(): void\n    {\n        this._renderRef = this.render.bind(this);\n\n        this.render = (): void =>\n        {\n            Culler.shared.cull(this.stage, this.renderer.screen);\n            this.renderer.render({ container: this.stage });\n        };\n    }\n\n    public static destroy(): void\n    {\n        this.render = this._renderRef;\n    }\n}\n", "import { type Adapter } from '../environment/adapter';\nimport { DOMParser } from '@xmldom/xmldom';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in a Web Worker.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size using the browser's native OffscreenCanvas.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL of the worker, which is globalThis.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n * @memberof environment\n */\nexport const WebWorkerAdapter = {\n    createCanvas: (width?: number, height?: number) => new OffscreenCanvas(width ?? 0, height ?? 0),\n    getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => globalThis.location.href,\n    getFontFaceSet: () => (globalThis as unknown as WorkerGlobalScope).fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n", "var fragment = \"\\nin vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform float uAlpha;\\nuniform sampler2D uTexture;\\n\\nvoid main()\\n{\\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=alpha.frag.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct AlphaUniforms {\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    \\n    return sample * alphaUniforms.uAlpha;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=alpha.wgsl.mjs.map\n", "import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './alpha.frag';\nimport source from './alpha.wgsl';\n\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * Options for AlphaFilter\n * @memberof filters\n */\nexport interface AlphaFilterOptions extends FilterOptions\n{\n    /**\n     * Amount of alpha from 0 to 1, where 0 is transparent\n     * @default 1\n     */\n    alpha: number;\n}\n\n/**\n * Simplest filter - applies alpha.\n *\n * Use this instead of Container's alpha property to avoid visual layering of individual elements.\n * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.\n * If elements are not opaque, they will blend with each other anyway.\n *\n * Very handy if you want to use common features of all filters:\n *\n * 1. Assign a blendMode to this filter, blend all elements inside display object with background.\n *\n * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.\n * @memberof filters\n */\nexport class AlphaFilter extends Filter\n{\n    /** Default filter options */\n    public static readonly defaultOptions: AlphaFilterOptions = {\n        /** Amount of alpha from 0 to 1, where 0 is transparent */\n        alpha: 1,\n    };\n\n    constructor(options?: AlphaFilterOptions)\n    {\n        options = { ...AlphaFilter.defaultOptions, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'alpha-filter'\n        });\n\n        const { alpha, ...rest } = options;\n\n        const alphaUniforms = new UniformGroup({\n            uAlpha: { value: alpha, type: 'f32' },\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                alphaUniforms\n            },\n        });\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.resources.alphaUniforms.uniforms.uAlpha; }\n    set alpha(value: number) { this.resources.alphaUniforms.uniforms.uAlpha = value; }\n}\n", "export interface IGAUSSIAN_VALUES\n{\n    [x: number]: number[];\n}\n\nexport const GAUSSIAN_VALUES: IGAUSSIAN_VALUES = {\n    5: [0.153388, 0.221461, 0.250301],\n    7: [0.071303, 0.131514, 0.189879, 0.214607],\n    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],\n};\n", "import { GAUSSIAN_VALUES } from '../const';\n\nconst fragTemplate = [\n    'in vec2 vBlurTexCoords[%size%];',\n    'uniform sampler2D uTexture;',\n    'out vec4 finalColor;',\n\n    'void main(void)',\n    '{',\n    '    finalColor = vec4(0.0);',\n    '    %blur%',\n    '}',\n\n].join('\\n');\n\nexport function generateBlurFragSource(kernelSize: number): string\n{\n    const kernel = GAUSSIAN_VALUES[kernelSize];\n    const halfLength = kernel.length;\n\n    let fragSource = fragTemplate;\n\n    let blurLoop = '';\n    const template = 'finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;';\n    let value: number;\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        let blur = template.replace('%index%', i.toString());\n\n        value = i;\n\n        if (i >= halfLength)\n        {\n            value = kernelSize - i - 1;\n        }\n\n        blur = blur.replace('%value%', kernel[value].toString());\n\n        blurLoop += blur;\n        blurLoop += '\\n';\n    }\n\n    fragSource = fragSource.replace('%blur%', blurLoop);\n    fragSource = fragSource.replace('%size%', kernelSize.toString());\n\n    return fragSource;\n}\n", "const vertTemplate = `\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\n\nexport function generateBlurVertSource(kernelSize: number, x: boolean): string\n{\n    const halfLength = Math.ceil(kernelSize / 2);\n\n    let vertSource = vertTemplate;\n\n    let blurLoop = '';\n    let template;\n\n    if (x)\n    {\n        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);';\n    }\n    else\n    {\n        template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);';\n    }\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        let blur = template.replace('%index%', i.toString());\n\n        blur = blur.replace('%sampleIndex%', `${i - (halfLength - 1)}.0`);\n\n        blurLoop += blur;\n        blurLoop += '\\n';\n    }\n\n    vertSource = vertSource.replace('%blur%', blurLoop);\n    vertSource = vertSource.replace('%size%', kernelSize.toString());\n    vertSource = vertSource.replace('%dimension%', x ? 'z' : 'w');\n\n    return vertSource;\n}\n", "import { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { generateBlurFragSource } from './generateBlurFragSource';\nimport { generateBlurVertSource } from './generateBlurVertSource';\n\nexport function generateBlurGlProgram(horizontal: boolean, kernelSize: number)\n{\n    const vertex = generateBlurVertSource(kernelSize, horizontal);\n    const fragment = generateBlurFragSource(kernelSize);\n\n    return GlProgram.from({\n        vertex,\n        fragment,\n        name: `blur-${horizontal ? 'horizontal' : 'vertical'}-pass-filter`\n    });\n}\n", "var source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlurUniforms {\\n  uStrength:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    %blur-struct%\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n\\n  let filteredCord = filterTextureCoord(aPosition);\\n\\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\\n\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n    %blur-vertex-out%\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  %blur-fragment-in%\\n) -> @location(0) vec4<f32> {\\n\\n    var   finalColor = vec4(0.0);\\n\\n    %blur-sampling%\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=blur-template.wgsl.mjs.map\n", "import { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { GAUSSIAN_VALUES } from '../const';\nimport source from './blur-template.wgsl';\n\nexport function generateBlurProgram(horizontal: boolean, kernelSize: number)\n{\n    const kernel = GAUSSIAN_VALUES[kernelSize];\n    const halfLength = kernel.length;\n\n    const blurStructSource: string[] = [];\n    const blurOutSource: string[] = [];\n    const blurSamplingSource: string[] = [];\n\n    for (let i = 0; i < kernelSize; i++)\n    {\n        blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;\n\n        if (horizontal)\n        {\n            blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;\n        }\n        else\n        {\n            blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;\n        }\n\n        const kernelIndex = i < halfLength ? i : (kernelSize - i - 1);\n        const kernelValue = kernel[kernelIndex].toString();\n\n        blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;\n    }\n\n    const blurStruct = blurStructSource.join('\\n');\n    const blurOut = blurOutSource.join('\\n');\n    const blurSampling = blurSamplingSource.join('\\n');\n\n    const finalSource = source\n        .replace('%blur-struct%', blurStruct)\n        .replace('%blur-vertex-out%', blurOut)\n        .replace('%blur-fragment-in%', blurStruct)\n        .replace('%blur-sampling%', blurSampling)\n        .replace('%dimension%', horizontal ? 'z' : 'w');\n\n    return GpuProgram.from({\n        vertex: {\n            source: finalSource,\n            entryPoint: 'mainVertex',\n        },\n        fragment: {\n            source: finalSource,\n            entryPoint: 'mainFragment',\n        },\n    });\n}\n\n", "import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../../rendering/renderers/types';\nimport { Filter } from '../../Filter';\nimport { generateBlurGlProgram } from './gl/generateBlurGlProgram';\nimport { generateBlurProgram } from './gpu/generateBlurProgram';\n\nimport type { RenderSurface } from '../../../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from '../../FilterSystem';\nimport type { BlurFilterOptions } from './BlurFilter';\n\n/**\n * Options for BlurFilterPass\n * @memberof filters\n */\nexport interface BlurFilterPassOptions extends BlurFilterOptions\n{\n    /** Do pass along the x-axis (`true`) or y-axis (`false`). */\n    horizontal: boolean;\n}\n\n/**\n * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.\n * @memberof filters\n */\nexport class BlurFilterPass extends Filter\n{\n    /** Default blur filter pass options */\n    public static defaultOptions: Partial<BlurFilterPassOptions> = {\n        /** The strength of the blur filter. */\n        strength: 8,\n        /** The quality of the blur filter. */\n        quality: 4,\n        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n        kernelSize: 5,\n    };\n\n    /** Do pass along the x-axis (`true`) or y-axis (`false`). */\n    public horizontal: boolean;\n    /** The number of passes to run the filter. */\n    public passes!: number;\n    /** The strength of the blur filter. */\n    public strength!: number;\n\n    private _quality: number;\n    private readonly _uniforms: any;\n\n    /**\n     * @param options\n     * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n     * @param options.strength - The strength of the blur filter.\n     * @param options.quality - The quality of the blur filter.\n     * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n     */\n    constructor(options: BlurFilterPassOptions)\n    {\n        options = { ...BlurFilterPass.defaultOptions, ...options };\n\n        const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);\n        const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                blurUniforms: {\n                    uStrength: { value: 0, type: 'f32' },\n                }\n            },\n            ...options\n        });\n\n        this.horizontal = options.horizontal;\n\n        this._quality = 0;\n\n        this.quality = options.quality;\n\n        this.blur = options.strength;\n\n        this._uniforms = this.resources.blurUniforms.uniforms;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - How to clear\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this._uniforms.uStrength = this.strength / this.passes;\n\n        if (this.passes === 1)\n        {\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const tempTexture = TexturePool.getSameSizeTexture(input);\n\n            let flip = input;\n            let flop = tempTexture;\n\n            this._state.blend = false;\n\n            const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;\n\n            for (let i = 0; i < this.passes - 1; i++)\n            {\n                filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);\n\n                const temp = flop;\n\n                flop = flip;\n                flip = temp;\n            }\n\n            this._state.blend = true;\n            filterManager.applyFilter(this, flip, output, clearMode);\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    /**\n     * Sets the strength of both the blur.\n     * @default 16\n     */\n    get blur(): number\n    {\n        return this.strength;\n    }\n\n    set blur(value: number)\n    {\n        this.padding = 1 + (Math.abs(value) * 2);\n        this.strength = value;\n    }\n\n    /**\n     * Sets the quality of the blur by modifying the number of passes. More passes means higher\n     * quality blurring but the lower the performance.\n     * @default 4\n     */\n    get quality(): number\n    {\n        return this._quality;\n    }\n\n    set quality(value: number)\n    {\n        this._quality = value;\n        this.passes = value;\n    }\n}\n", "import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../../rendering/renderers/types';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Filter } from '../../Filter';\nimport { BlurFilterPass } from './BlurFilterPass';\n\nimport type { RenderSurface } from '../../../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterOptions } from '../../Filter';\nimport type { FilterSystem } from '../../FilterSystem';\n\n/**\n * Options for BlurFilter\n * @memberof filters\n */\nexport interface BlurFilterOptions extends FilterOptions\n{\n    /**\n     * The strength of the blur filter.\n     * @default 8\n     */\n    strength?: number;\n    /**\n     * The horizontal strength of the blur.\n     * @default 8\n     */\n    strengthX?: number;\n    /**\n     * The vertical strength of the blur.\n     * @default 8\n     */\n    strengthY?: number;\n    /**\n     * The quality of the blur filter.\n     * @default 4\n     */\n    quality?: number;\n    /**\n     * The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n     * @default 5\n     */\n    kernelSize?: number;\n}\n\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n *\n * The strength of the blur can be set for the x-axis and y-axis separately.\n * @memberof filters\n */\nexport class BlurFilter extends Filter\n{\n    /** Default blur filter options */\n    public static defaultOptions: Partial<BlurFilterOptions> = {\n        /** The strength of the blur filter. */\n        strength: 8,\n        /** The quality of the blur filter. */\n        quality: 4,\n        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n        kernelSize: 5,\n    };\n\n    /** The horizontal blur filter */\n    public blurXFilter: BlurFilterPass;\n    /** The vertical blur filter */\n    public blurYFilter: BlurFilterPass;\n\n    private _repeatEdgePixels = false;\n\n    /**\n     * @param {filters.BlurFilterOptions} options - The options of the blur filter.\n     */\n    constructor(options?: BlurFilterOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(strength?: number, quality?: number, resolution?: number | null, kernelSize?: number);\n    constructor(...args: [BlurFilterOptions?] | [number?, number?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        // if options is a number)\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }');\n            // #endif\n\n            options = { strength: options };\n\n            if (args[1] !== undefined)options.quality = args[1];\n            if (args[2] !== undefined)options.resolution = args[2] || 'inherit';\n            if (args[3] !== undefined)options.kernelSize = args[3];\n        }\n\n        options = { ...BlurFilterPass.defaultOptions, ...options };\n\n        const { strength, strengthX, strengthY, quality, ...rest } = options;\n\n        super({\n            ...rest,\n            compatibleRenderers: RendererType.BOTH,\n            resources: {}\n        });\n\n        this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });\n        this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });\n\n        this.quality = quality;\n        this.strengthX = strengthX ?? strength;\n        this.strengthY = strengthY ?? strength;\n        this.repeatEdgePixels = false;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - How to clear\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const xStrength = Math.abs(this.blurXFilter.strength);\n        const yStrength = Math.abs(this.blurYFilter.strength);\n\n        if (xStrength && yStrength)\n        {\n            const tempTexture = TexturePool.getSameSizeTexture(input);\n\n            this.blurXFilter.blendMode = 'normal';\n            this.blurXFilter.apply(filterManager, input, tempTexture, true);\n            this.blurYFilter.blendMode = this.blendMode;\n            this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);\n\n            TexturePool.returnTexture(tempTexture);\n        }\n        else if (yStrength)\n        {\n            this.blurYFilter.blendMode = this.blendMode;\n            this.blurYFilter.apply(filterManager, input, output, clearMode);\n        }\n        else\n        {\n            this.blurXFilter.blendMode = this.blendMode;\n            this.blurXFilter.apply(filterManager, input, output, clearMode);\n        }\n    }\n\n    protected updatePadding(): void\n    {\n        if (this._repeatEdgePixels)\n        {\n            this.padding = 0;\n        }\n        else\n        {\n            this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;\n        }\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 8\n     */\n    get strength(): number\n    {\n        if (this.strengthX !== this.strengthY)\n        {\n            throw new Error('BlurFilter\\'s strengthX and strengthY are different');\n        }\n\n        return this.strengthX;\n    }\n\n    set strength(value: number)\n    {\n        this.blurXFilter.blur = this.blurYFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the number of passes for blur. More passes means higher quality bluring.\n     * @default 1\n     */\n    get quality(): number\n    {\n        return this.blurXFilter.quality;\n    }\n\n    set quality(value: number)\n    {\n        this.blurXFilter.quality = this.blurYFilter.quality = value;\n    }\n\n    /**\n     * Sets the strength of horizontal blur\n     * @default 8\n     */\n    get strengthX(): number\n    {\n        return this.blurXFilter.blur;\n    }\n\n    set strengthX(value: number)\n    {\n        this.blurXFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the strength of the vertical blur\n     * @default 8\n     */\n    get strengthY(): number\n    {\n        return this.blurYFilter.blur;\n    }\n\n    set strengthY(value: number)\n    {\n        this.blurYFilter.blur = value;\n        this.updatePadding();\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strength\n     */\n    get blur(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blur is deprecated, please use BlurFilter.strength instead.');\n        // #endif\n\n        return this.strength;\n    }\n\n    set blur(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blur is deprecated, please use BlurFilter.strength instead.');\n        // #endif\n        this.strength = value;\n    }\n\n    /**\n     * Sets the strength of the blurX property\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strengthX\n     */\n    get blurX(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.');\n        // #endif\n\n        return this.strengthX;\n    }\n\n    set blurX(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.');\n        // #endif\n        this.strengthX = value;\n    }\n\n    /**\n     * Sets the strength of the blurY property\n     * @default 2\n     * @deprecated since 8.3.0\n     * @see BlurFilter.strengthY\n     */\n    get blurY(): number\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.');\n        // #endif\n\n        return this.strengthY;\n    }\n\n    set blurY(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.3.0', 'BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.');\n        // #endif\n        this.strengthY = value;\n    }\n\n    /**\n     * If set to true the edge of the target will be clamped\n     * @default false\n     */\n    get repeatEdgePixels(): boolean\n    {\n        return this._repeatEdgePixels;\n    }\n\n    set repeatEdgePixels(value: boolean)\n    {\n        this._repeatEdgePixels = value;\n        this.updatePadding();\n    }\n}\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uColorMatrix[20];\\nuniform float uAlpha;\\n\\nuniform sampler2D uTexture;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\\n    float diff = (randomValue - 0.5) *  0.5;\\n\\n    if (uAlpha == 0.0) {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    vec4 result;\\n\\n    result.r = (uColorMatrix[0] * color.r);\\n        result.r += (uColorMatrix[1] * color.g);\\n        result.r += (uColorMatrix[2] * color.b);\\n        result.r += (uColorMatrix[3] * color.a);\\n        result.r += uColorMatrix[4];\\n\\n    result.g = (uColorMatrix[5] * color.r);\\n        result.g += (uColorMatrix[6] * color.g);\\n        result.g += (uColorMatrix[7] * color.b);\\n        result.g += (uColorMatrix[8] * color.a);\\n        result.g += uColorMatrix[9];\\n\\n    result.b = (uColorMatrix[10] * color.r);\\n       result.b += (uColorMatrix[11] * color.g);\\n       result.b += (uColorMatrix[12] * color.b);\\n       result.b += (uColorMatrix[13] * color.a);\\n       result.b += uColorMatrix[14];\\n\\n    result.a = (uColorMatrix[15] * color.r);\\n       result.a += (uColorMatrix[16] * color.g);\\n       result.a += (uColorMatrix[17] * color.b);\\n       result.a += (uColorMatrix[18] * color.a);\\n       result.a += uColorMatrix[19];\\n\\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\\n\\n    // Premultiply alpha again.\\n    rgb *= result.a;\\n\\n    finalColor = vec4(rgb, result.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=colorMatrixFilter.frag.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct ColorMatrixUniforms {\\n  uColorMatrix:array<vec4<f32>, 5>,\\n  uAlpha:f32,\\n};\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n  };\\n  \\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n  );\\n}\\n\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n\\n  var c = textureSample(uTexture, uSampler, uv);\\n  \\n  if (colorMatrixUniforms.uAlpha == 0.0) {\\n    return c;\\n  }\\n\\n \\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (c.a > 0.0) {\\n      c.r /= c.a;\\n      c.g /= c.a;\\n      c.b /= c.a;\\n    }\\n\\n    var cm = colorMatrixUniforms.uColorMatrix;\\n\\n\\n    var result = vec4<f32>(0.);\\n\\n    result.r = (cm[0][0] * c.r);\\n    result.r += (cm[0][1] * c.g);\\n    result.r += (cm[0][2] * c.b);\\n    result.r += (cm[0][3] * c.a);\\n    result.r += cm[1][0];\\n\\n    result.g = (cm[1][1] * c.r);\\n    result.g += (cm[1][2] * c.g);\\n    result.g += (cm[1][3] * c.b);\\n    result.g += (cm[2][0] * c.a);\\n    result.g += cm[2][1];\\n\\n    result.b = (cm[2][2] * c.r);\\n    result.b += (cm[2][3] * c.g);\\n    result.b += (cm[3][0] * c.b);\\n    result.b += (cm[3][1] * c.a);\\n    result.b += cm[3][2];\\n\\n    result.a = (cm[3][3] * c.r);\\n    result.a += (cm[4][0] * c.g);\\n    result.a += (cm[4][1] * c.b);\\n    result.a += (cm[4][2] * c.a);\\n    result.a += cm[4][3];\\n\\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\\n\\n    rgb.r *= result.a;\\n    rgb.g *= result.a;\\n    rgb.b *= result.a;\\n\\n    return vec4(rgb, result.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=colorMatrixFilter.wgsl.mjs.map\n", "import { Color } from '../../../color/Color';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './colorMatrixFilter.frag';\nimport source from './colorMatrixFilter.wgsl';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { ArrayFixed } from '../../../utils/types';\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * 5x4 matrix for transforming RGBA color and alpha\n * @memberof filters\n */\nexport type ColorMatrix = ArrayFixed<number, 20>;\n\n/**\n * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA\n * color and alpha values of every pixel on your container to produce a result\n * with a new set of RGBA color and alpha values. It's pretty powerful!\n *\n * ```js\n *  let colorMatrix = new filters.ColorMatrixFilter();\n *  container.filters = [colorMatrix];\n *  colorMatrix.contrast(2);\n * ```\n * @author Clment Chenebault <clement@goodboydigital.com>\n * @memberof filters\n */\nexport class ColorMatrixFilter extends Filter\n{\n    constructor(options: FilterOptions = {})\n    {\n        const colorMatrixUniforms = new UniformGroup({\n            uColorMatrix: {\n                value: [\n                    1, 0, 0, 0, 0,\n                    0, 1, 0, 0, 0,\n                    0, 0, 1, 0, 0,\n                    0, 0, 0, 1, 0,\n                ],\n                type: 'f32',\n                size: 20,\n            },\n            uAlpha: {\n                value: 1,\n                type: 'f32'\n            }\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-matrix-filter'\n        });\n\n        super({\n            ...options,\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorMatrixUniforms\n            },\n        });\n\n        this.alpha = 1;\n    }\n\n    /**\n     * Transforms current matrix and set the new one\n     * @param {number[]} matrix - 5x4 matrix\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    private _loadMatrix(matrix: ColorMatrix, multiply = false): void\n    {\n        let newMatrix = matrix;\n\n        if (multiply)\n        {\n            this._multiply(newMatrix, this.matrix, matrix);\n            newMatrix = this._colorMatrix(newMatrix) as any;\n        }\n\n        // set the new matrix\n\n        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;\n        this.resources.colorMatrixUniforms.update();\n    }\n\n    /**\n     * Multiplies two mat5's\n     * @private\n     * @param out - 5x4 matrix the receiving matrix\n     * @param a - 5x4 matrix the first operand\n     * @param b - 5x4 matrix the second operand\n     * @returns {number[]} 5x4 matrix\n     */\n    private _multiply(out: ColorMatrix, a: ColorMatrix, b: ColorMatrix): ColorMatrix\n    {\n        // Red Channel\n        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);\n        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);\n        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);\n        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);\n        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];\n\n        // Green Channel\n        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);\n        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);\n        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);\n        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);\n        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];\n\n        // Blue Channel\n        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);\n        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);\n        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);\n        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);\n        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];\n\n        // Alpha Channel\n        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);\n        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);\n        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);\n        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);\n        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];\n\n        return out;\n    }\n\n    /**\n     * Create a Float32 Array and normalize the offset component to 0-1\n     * @param {number[]} matrix - 5x4 matrix\n     * @returns {number[]} 5x4 matrix with all values between 0-1\n     */\n    private _colorMatrix(matrix: ColorMatrix): ColorMatrix\n    {\n        // Create a Float32 Array and normalize the offset component to 0-1\n        const m = new Float32Array(matrix);\n\n        m[4] /= 255;\n        m[9] /= 255;\n        m[14] /= 255;\n        m[19] /= 255;\n\n        return m as any;\n    }\n\n    /**\n     * Adjusts brightness\n     * @param b - value of the brightness (0-1, where 0 is black)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public brightness(b: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            b, 0, 0, 0, 0,\n            0, b, 0, 0, 0,\n            0, 0, b, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Sets each channel on the diagonal of the color matrix.\n     * This can be used to achieve a tinting effect on Containers similar to the tint field of some\n     * display objects like Sprite, Text, Graphics, and Mesh.\n     * @param color - Color of the tint. This is a hex value.\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public tint(color: ColorSource, multiply?: boolean): void\n    {\n        const [r, g, b] = Color.shared.setValue(color).toArray();\n        const matrix: ColorMatrix = [\n            r, 0, 0, 0, 0,\n            0, g, 0, 0, 0,\n            0, 0, b, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Set the matrices in grey scales\n     * @param scale - value of the grey (0-1, where 0 is black)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public greyscale(scale: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            scale, scale, scale, 0, 0,\n            scale, scale, scale, 0, 0,\n            scale, scale, scale, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * for our american friends!\n     * @param scale\n     * @param multiply\n     */\n    public grayscale(scale: number, multiply: boolean): void\n    {\n        this.greyscale(scale, multiply);\n    }\n\n    /**\n     * Set the black and white matrice.\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public blackAndWhite(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.3, 0.6, 0.1, 0, 0,\n            0.3, 0.6, 0.1, 0, 0,\n            0.3, 0.6, 0.1, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Set the hue property of the color\n     * @param rotation - in degrees\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public hue(rotation: number, multiply: boolean): void\n    {\n        rotation = (rotation || 0) / 180 * Math.PI;\n\n        const cosR = Math.cos(rotation);\n        const sinR = Math.sin(rotation);\n        const sqrt = Math.sqrt;\n\n        /* a good approximation for hue rotation\n         This matrix is far better than the versions with magic luminance constants\n         formerly used here, but also used in the starling framework (flash) and known from this\n         old part of the internet: quasimondo.com/archives/000565.php\n\n         This new matrix is based on rgb cube rotation in space. Look here for a more descriptive\n         implementation as a shader not a general matrix:\n         https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js\n\n         This is the source for the code:\n         see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751\n         */\n\n        const w = 1 / 3;\n        const sqrW = sqrt(w); // weight is\n\n        const a00 = cosR + ((1.0 - cosR) * w);\n        const a01 = (w * (1.0 - cosR)) - (sqrW * sinR);\n        const a02 = (w * (1.0 - cosR)) + (sqrW * sinR);\n\n        const a10 = (w * (1.0 - cosR)) + (sqrW * sinR);\n        const a11 = cosR + (w * (1.0 - cosR));\n        const a12 = (w * (1.0 - cosR)) - (sqrW * sinR);\n\n        const a20 = (w * (1.0 - cosR)) - (sqrW * sinR);\n        const a21 = (w * (1.0 - cosR)) + (sqrW * sinR);\n        const a22 = cosR + (w * (1.0 - cosR));\n\n        const matrix: ColorMatrix = [\n            a00, a01, a02, 0, 0,\n            a10, a11, a12, 0, 0,\n            a20, a21, a22, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Set the contrast matrix, increase the separation between dark and bright\n     * Increase contrast : shadows darker and highlights brighter\n     * Decrease contrast : bring the shadows up and the highlights down\n     * @param amount - value of the contrast (0-1)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public contrast(amount: number, multiply: boolean): void\n    {\n        const v = (amount || 0) + 1;\n        const o = -0.5 * (v - 1);\n\n        const matrix: ColorMatrix = [\n            v, 0, 0, 0, o,\n            0, v, 0, 0, o,\n            0, 0, v, 0, o,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Set the saturation matrix, increase the separation between colors\n     * Increase saturation : increase contrast, brightness, and sharpness\n     * @param amount - The saturation amount (0-1)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public saturate(amount = 0, multiply?: boolean): void\n    {\n        const x = (amount * 2 / 3) + 1;\n        const y = ((x - 1) * -0.5);\n\n        const matrix: ColorMatrix = [\n            x, y, y, 0, 0,\n            y, x, y, 0, 0,\n            y, y, x, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /** Desaturate image (remove color) Call the saturate function */\n    public desaturate(): void // eslint-disable-line no-unused-vars\n    {\n        this.saturate(-1);\n    }\n\n    /**\n     * Negative image (inverse of classic rgb matrix)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public negative(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            -1, 0, 0, 1, 0,\n            0, -1, 0, 1, 0,\n            0, 0, -1, 1, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Sepia image\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public sepia(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.393, 0.7689999, 0.18899999, 0, 0,\n            0.349, 0.6859999, 0.16799999, 0, 0,\n            0.272, 0.5339999, 0.13099999, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public technicolor(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,\n            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,\n            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Polaroid filter\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public polaroid(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.438, -0.062, -0.062, 0, 0,\n            -0.122, 1.378, -0.122, 0, 0,\n            -0.016, -0.016, 1.483, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Filter who transforms : Red -> Blue and Blue -> Red\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public toBGR(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0, 0, 1, 0, 0,\n            0, 1, 0, 0, 0,\n            1, 0, 0, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public kodachrome(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Brown delicious browni filter (thanks Dominic Szablewski)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public browni(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,\n            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,\n            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Vintage filter (thanks Dominic Szablewski)\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public vintage(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,\n            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,\n            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * We don't know exactly what it does, kind of gradient map, but funny to play with!\n     * @param desaturation - Tone values.\n     * @param toned - Tone values.\n     * @param lightColor - Tone values, example: `0xFFE580`\n     * @param darkColor - Tone values, example: `0xFFE580`\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public colorTone(\n        desaturation: number,\n        toned: number,\n        lightColor: ColorSource,\n        darkColor: ColorSource,\n        multiply: boolean\n    ): void\n    {\n        desaturation ||= 0.2;\n        toned ||= 0.15;\n        lightColor ||= 0xFFE580;\n        darkColor ||= 0x338000;\n\n        const temp = Color.shared;\n        const [lR, lG, lB] = temp.setValue(lightColor).toArray();\n        const [dR, dG, dB] = temp.setValue(darkColor).toArray();\n\n        const matrix: ColorMatrix = [\n            0.3, 0.59, 0.11, 0, 0,\n            lR, lG, lB, desaturation, 0,\n            dR, dG, dB, toned, 0,\n            lR - dR, lG - dG, lB - dB, 0, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Night effect\n     * @param intensity - The intensity of the night effect.\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public night(intensity: number, multiply: boolean): void\n    {\n        intensity ||= 0.1;\n\n        const matrix: ColorMatrix = [\n            intensity * (-2.0), -intensity, 0, 0, 0,\n            -intensity, 0, intensity, 0, 0,\n            0, intensity, intensity * 2.0, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * Predator effect\n     *\n     * Erase the current matrix by setting a new independent one\n     * @param amount - how much the predator feels his future victim\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public predator(amount: number, multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            // row 1\n            11.224130630493164 * amount,\n            -4.794486999511719 * amount,\n            -2.8746118545532227 * amount,\n            0 * amount,\n            0.40342438220977783 * amount,\n            // row 2\n            -3.6330697536468506 * amount,\n            9.193157196044922 * amount,\n            -2.951810836791992 * amount,\n            0 * amount,\n            -1.316135048866272 * amount,\n            // row 3\n            -3.2184197902679443 * amount,\n            -4.2375030517578125 * amount,\n            7.476448059082031 * amount,\n            0 * amount,\n            0.8044459223747253 * amount,\n            // row 4\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /**\n     * LSD effect\n     *\n     * Multiply the current matrix\n     * @param multiply - if true, current matrix and matrix are multiplied. If false,\n     *  just set the current matrix with @param matrix\n     */\n    public lsd(multiply: boolean): void\n    {\n        const matrix: ColorMatrix = [\n            2, -0.4, 0.5, 0, 0,\n            -0.5, 2, -0.4, 0, 0,\n            -0.4, -0.5, 3, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, multiply);\n    }\n\n    /** Erase the current matrix by setting the default one. */\n    public reset(): void\n    {\n        const matrix: ColorMatrix = [\n            1, 0, 0, 0, 0,\n            0, 1, 0, 0, 0,\n            0, 0, 1, 0, 0,\n            0, 0, 0, 1, 0,\n        ];\n\n        this._loadMatrix(matrix, false);\n    }\n\n    /**\n     * The matrix of the color matrix filter\n     * @member {number[]}\n     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n     */\n    get matrix(): ColorMatrix\n    {\n        return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;\n    }\n\n    set matrix(value: ColorMatrix)\n    {\n        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;\n    }\n\n    /**\n     * The opacity value to use when mixing the original and resultant colors.\n     *\n     * When the value is 0, the original color is used without modification.\n     * When the value is 1, the result color is used.\n     * When in the range (0, 1) the color is interpolated between the original and result by this amount.\n     * @default 1\n     */\n    get alpha(): number\n    {\n        return this.resources.colorMatrixUniforms.uniforms.uAlpha;\n    }\n\n    set alpha(value: number)\n    {\n        this.resources.colorMatrixUniforms.uniforms.uAlpha = value;\n    }\n}\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nin vec2 vFilterUv;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\n\\nuniform vec4 uInputClamp;\\nuniform highp vec4 uInputSize;\\nuniform mat2 uRotation;\\nuniform vec2 uScale;\\n\\nvoid main()\\n{\\n    vec4 map = texture(uMapTexture, vFilterUv);\\n    \\n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \\n\\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=displacement.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterUv;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( void )\\n{\\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\\n}\\n\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterUv = getFilterCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=displacement.vert.mjs.map\n", "var source = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct DisplacementUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uScale:vec2<f32>,\\n  uRotation:mat2x2<f32>\\n};\\n\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\\n\\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \\n   \\n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=displacement.wgsl.mjs.map\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Filter } from '../../Filter';\nimport fragment from './displacement.frag';\nimport vertex from './displacement.vert';\nimport source from './displacement.wgsl';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterOptions } from '../../Filter';\nimport type { FilterSystem } from '../../FilterSystem';\n\n/**\n * Options for DisplacementFilter\n * @memberof filters\n */\nexport interface DisplacementFilterOptions extends FilterOptions\n{\n    /** The texture used for the displacement map. */\n    sprite: Sprite,\n    /** The scale of the displacement. */\n    scale?: number | PointData,\n}\n\n/**\n * A Noise effect filter.\n *\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n * @memberof filters\n * @author Vico @vicocotea\n */\nexport class DisplacementFilter extends Filter\n{\n    private readonly _sprite: Sprite;\n\n    /**\n     * **Note:** Our docs parser struggles to properly understand the constructor signature.\n     * This is the correct signature.\n     * ```ts\n     * new DisplacementFilter(options?: DisplacementFilterOptions);\n     * ```\n     * @param options - The options for the filter.\n     * @param options.sprite - The texture used for the displacement map.\n     * @param options.scale - The scale of the displacement.\n     */\n    constructor(options: Sprite | DisplacementFilterOptions);\n    constructor(sprite: Sprite, scale?: number | PointData);\n    constructor(...args: [Sprite | DisplacementFilterOptions] | [Sprite, (number | PointData)?])\n    {\n        let options = args[0];\n\n        if (options instanceof Sprite)\n        {\n            // #if _DEBUG\n            if (args[1])\n            {\n                deprecation(v8_0_0, 'DisplacementFilter now uses options object instead of params. {sprite, scale}');\n            }\n            // #endif\n\n            options = { sprite: options, scale: args[1] };\n        }\n\n        const { sprite, scale: scaleOption, ...rest } = options;\n\n        let scale = scaleOption ?? 20;\n\n        // check if is a number or a point\n        if (typeof scale === 'number')\n        {\n            scale = new Point(scale, scale);\n        }\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uScale: { value: scale, type: 'vec2<f32>' },\n            uRotation: { value: new Float32Array([0, 0, 0, 0]), type: 'mat2x2<f32>' },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'displacement-filter'\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const textureSource = sprite.texture.source;\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMapTexture: textureSource,\n                uMapSampler: textureSource.style,\n            },\n        });\n\n        this._sprite = options.sprite;\n        this._sprite.renderable = false;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - clearMode.\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        const uniforms = this.resources.filterUniforms.uniforms;\n\n        filterManager.calculateSpriteMatrix(\n            uniforms.uFilterMatrix,\n            this._sprite\n        );\n\n        // Extract rotation from world transform\n        const wt = this._sprite.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            uniforms.uRotation[0] = wt.a / lenX;\n            uniforms.uRotation[1] = wt.b / lenX;\n            uniforms.uRotation[2] = wt.c / lenY;\n            uniforms.uRotation[3] = wt.d / lenY;\n        }\n\n        this.resources.uMapTexture = this._sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /** scaleX, scaleY for displacements */\n    get scale(): Point\n    {\n        return this.resources.filterUniforms.uniforms.uScale as Point;\n    }\n}\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nin vec4 vColor;\\n\\nout vec4 finalColor;\\n\\nuniform float uNoise;\\nuniform float uSeed;\\nuniform sampler2D uTexture;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\\n    float diff = (randomValue - 0.5) *  uNoise;\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    // Premultiply alpha again.\\n    color.rgb *= color.a;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=noise.frag.mjs.map\n", "var source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct NoiseUniforms {\\n  uNoise:f32,\\n  uSeed:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\nfn rand(co:vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\n\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\\n  \\n    \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\\n  \\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (sample.a > 0.0) {\\n      sample.r /= sample.a;\\n      sample.g /= sample.a;\\n      sample.b /= sample.a;\\n    }\\n\\n    sample.r += diff;\\n    sample.g += diff;\\n    sample.b += diff;\\n\\n    // Premultiply alpha again.\\n    sample.r *= sample.a;\\n    sample.g *= sample.a;\\n    sample.b *= sample.a;\\n    \\n    return sample;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=noise.wgsl.mjs.map\n", "import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './noise.frag';\nimport source from './noise.wgsl';\n\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * Options for NoiseFilter\n * @memberof filters\n */\nexport interface NoiseFilterOptions extends FilterOptions\n{\n    /** The amount of noise to apply, this value should be in the range (0, 1]. */\n    noise?: number;\n    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */\n    seed?: number;\n}\n\n/**\n * A Noise effect filter.\n *\n * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n * @memberof filters\n * @author Vico @vicocotea\n */\nexport class NoiseFilter extends Filter\n{\n    public static readonly defaultOptions: NoiseFilterOptions = {\n        noise: 0.5,\n    };\n\n    /**\n     * @param options - The options of the noise filter.\n     */\n    constructor(options: NoiseFilterOptions = {})\n    {\n        options = { ...NoiseFilter.defaultOptions, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'noise-filter'\n        });\n\n        const { noise, seed, ...rest } = options;\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                noiseUniforms: new UniformGroup({\n                    uNoise: { value: 1, type: 'f32' },\n                    uSeed: { value: 1, type: 'f32' },\n                })\n            },\n        });\n\n        this.noise = noise;\n        this.seed = seed ?? Math.random();\n    }\n\n    /**\n     * The amount of noise to apply, this value should be in the range (0, 1].\n     * @default 0.5\n     */\n    get noise(): number\n    {\n        return this.resources.noiseUniforms.uniforms.uNoise;\n    }\n\n    set noise(value: number)\n    {\n        this.resources.noiseUniforms.uniforms.uNoise = value;\n    }\n\n    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */\n    get seed(): number\n    {\n        return this.resources.noiseUniforms.uniforms.uSeed;\n    }\n\n    set seed(value: number)\n    {\n        this.resources.noiseUniforms.uniforms.uSeed = value;\n    }\n}\n", "var hsl = \"fn getLuminosity(c: vec3<f32>) -> f32 {\\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\\n}\\n\\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\\n  let d: f32 = lum - getLuminosity(c);\\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\\n\\n  // clip back into legal range\\n  let newLum: f32 = getLuminosity(newColor);\\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\\n\\n  let t1: f32 = newLum / (newLum - cMin);\\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\\n\\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\\n\\n  return finalColor;\\n}\\n\\nfn getSaturation(c: vec3<f32>) -> f32 {\\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\\n}\\n\\n// Set saturation if color components are sorted in ascending order.\\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\\n  var result: vec3<f32>;\\n  if (cSorted.z > cSorted.x) {\\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\\n    result = vec3<f32>(0.0, newY, s);\\n  } else {\\n    result = vec3<f32>(0.0, 0.0, 0.0);\\n  }\\n  return vec3<f32>(result.x, result.y, result.z);\\n}\\n\\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\\n    var result: vec3<f32> = c;\\n\\n    if (c.r <= c.g && c.r <= c.b) {\\n        if (c.g <= c.b) {\\n            result = setSaturationMinMidMax(result, s);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.r, temp.b, temp.g);\\n        }\\n    } else if (c.g <= c.r && c.g <= c.b) {\\n        if (c.r <= c.b) {\\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.g, temp.r, temp.b);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.g, temp.b, temp.r);\\n        }\\n    } else {\\n        if (c.r <= c.g) {\\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.b, temp.r, temp.g);\\n        } else {\\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\\n            temp = setSaturationMinMidMax(temp, s);\\n            result = vec3<f32>(temp.b, temp.g, temp.r);\\n        }\\n    }\\n\\n    return result;\\n}\";\n\nexport { hsl as default };\n//# sourceMappingURL=hsl.wgsl.mjs.map\n", "/**\n * Check if a point is inside a triangle.\n * @param px - x coordinate of the point\n * @param py - y coordinate of the point\n * @param x1 - x coordinate of the first vertex of the triangle\n * @param y1 - y coordinate of the first vertex of the triangle\n * @param x2 - x coordinate of the second vertex of the triangle\n * @param y2 - y coordinate of the second vertex of the triangle\n * @param x3 - x coordinate of the third vertex of the triangle\n * @param y3 - y coordinate of the third vertex of the triangle\n * @returns `true` if the point is inside the triangle, `false` otherwise\n */\nexport function pointInTriangle(\n    px: number, py: number,\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number\n)\n{\n    // Calculate vectors from point p to each vertex of the triangle\n    const v2x = x3 - x1;\n    const v2y = y3 - y1;\n    const v1x = x2 - x1;\n    const v1y = y2 - y1;\n    const v0x = px - x1;\n    const v0y = py - y1;\n\n    // Compute dot products\n    const dot00 = (v2x * v2x) + (v2y * v2y);\n    const dot01 = (v2x * v1x) + (v2y * v1y);\n    const dot02 = (v2x * v0x) + (v2y * v0y);\n    const dot11 = (v1x * v1x) + (v1y * v1y);\n    const dot12 = (v1x * v0x) + (v1y * v0y);\n\n    // Calculate barycentric coordinates\n    const invDenom = 1 / ((dot00 * dot11) - (dot01 * dot01));\n    const u = ((dot11 * dot02) - (dot01 * dot12)) * invDenom;\n    const v = ((dot00 * dot12) - (dot01 * dot02)) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n}\n", "import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape of a triangle via user defined coordinates.\n *\n * Create a `Triangle` object with the `x`, `y`, `x2`, `y2`, `x3`, `y3` properties.\n *\n * ```js\n * import { Triangle } from 'pixi.js';\n *\n * const triangle = new Triangle(0, 0, 100, 0, 50, 50);\n * ```\n * @memberof maths\n */\nexport class Triangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'triangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'triangle';\n\n    /**\n     * The X coord of the first point.\n     * @default 0\n     */\n    public x: number;\n    /**\n     * The Y coord of the first point.\n     * @default 0\n     */\n    public y: number;\n    /**\n     * The X coord of the second point.\n     * @default 0\n     */\n    public x2: number;\n    /**\n     * The Y coord of the second point.\n     * @default 0\n     */\n    public y2: number;\n    /**\n     * The X coord of the third point.\n     * @default 0\n     */\n    public x3: number;\n    /**\n     * The Y coord of the third point.\n     * @default 0\n     */\n    public y3: number;\n\n    /**\n     * @param x - The X coord of the first point.\n     * @param y - The Y coord of the first point.\n     * @param x2 - The X coord of the second point.\n     * @param y2 - The Y coord of the second point.\n     * @param x3 - The X coord of the third point.\n     * @param y3 - The Y coord of the third point.\n     */\n    constructor(x = 0, y = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.x3 = x3;\n        this.y3 = y3;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this triangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Triangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        const s = ((this.x - this.x3) * (y - this.y3)) - ((this.y - this.y3) * (x - this.x3));\n        const t = ((this.x2 - this.x) * (y - this.y)) - ((this.y2 - this.y) * (x - this.x));\n\n        if ((s < 0) !== (t < 0) && s !== 0 && t !== 0)\n        { return false; }\n\n        const d = ((this.x3 - this.x2) * (y - this.y2)) - ((this.y3 - this.y2) * (x - this.x2));\n\n        return d === 0 || (d < 0) === (s + t <= 0);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this triangle including the stroke.\n     * @param pointX - The X coordinate of the point to test\n     * @param pointY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this triangle\n     */\n    public strokeContains(pointX: number, pointY: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;\n\n        const { x, x2, x3, y, y2, y3 } = this;\n\n        if (squaredDistanceToLineSegment(pointX, pointY, x, y, x2, y3) <= halfStrokeWidthSquared\n            || squaredDistanceToLineSegment(pointX, pointY, x2, y2, x3, y3) <= halfStrokeWidthSquared\n            || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x, y) <= halfStrokeWidthSquared)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates a clone of this Triangle\n     * @returns a copy of the triangle\n     */\n    public clone(): ShapePrimitive\n    {\n        const triangle = new Triangle(\n            this.x,\n            this.y,\n            this.x2,\n            this.y2,\n            this.x3,\n            this.y3\n        );\n\n        return triangle;\n    }\n\n    /**\n     * Copies another triangle to this one.\n     * @param triangle - The triangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(triangle: Triangle): this\n    {\n        this.x = triangle.x;\n        this.y = triangle.y;\n        this.x2 = triangle.x2;\n        this.y2 = triangle.y2;\n        this.x3 = triangle.x3;\n        this.y3 = triangle.y3;\n\n        return this;\n    }\n\n    /**\n     * Copies this triangle to another one.\n     * @param triangle - The triangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(triangle: Triangle): Triangle\n    {\n        triangle.copyFrom(this);\n\n        return triangle;\n    }\n\n    /**\n     * Returns the framing rectangle of the triangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const minX = Math.min(this.x, this.x2, this.x3);\n        const maxX = Math.max(this.x, this.x2, this.x3);\n        const minY = Math.min(this.y, this.y2, this.y3);\n        const maxY = Math.max(this.y, this.y2, this.y3);\n\n        out.x = minX;\n        out.y = minY;\n        out.width = maxX - minX;\n        out.height = maxY - minY;\n\n        return out;\n    }\n}\n", "import { Container } from '../scene/container/Container';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport type { Text } from '../scene/text/Text';\n\n/** The accepted types to pass to the prepare system */\nexport type PrepareSourceItem = Container | TextureSource | Texture | GraphicsContext;\n\n/** The valid types resolved to the queue ready for upload */\nexport type PrepareQueueItem = TextureSource | Text | GraphicsContext;\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class provides the base functionality and handles processing the queue asynchronously.\n * @memberof rendering\n */\nexport abstract class PrepareBase\n{\n    /** The number of uploads to process per frame */\n    public static uploadsPerFrame = 4;\n\n    /** Reference to the renderer */\n    protected renderer: Renderer;\n\n    /** The queue to process over a async timer */\n    protected queue: PrepareQueueItem[];\n\n    /** Collection of callbacks to call when the uploads are finished */\n    protected resolves: ((value: void | PromiseLike<void>) => void)[];\n\n    /** Timeout id for next processing call */\n    protected timeout?: number;\n\n    /**\n     * @param {rendering.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.queue = [];\n        this.resolves = [];\n    }\n\n    /** Resolve the given resource type and return an item for the queue */\n    protected abstract resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void;\n    protected abstract uploadQueueItem(item: PrepareQueueItem): void;\n\n    /**\n     * Return a copy of the queue\n     * @returns {PrepareQueueItem[]} The queue\n     */\n    public getQueue(): PrepareQueueItem[]\n    {\n        return [...this.queue];\n    }\n\n    /**\n     * Add a textures or graphics resource to the queue\n     * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n     */\n    public add(resource: PrepareSourceItem | PrepareSourceItem[]): this\n    {\n        const resourceArray = Array.isArray(resource) ? resource : [resource];\n\n        for (const resourceItem of resourceArray)\n        {\n            // handle containers and their children\n            if (resourceItem instanceof Container)\n            {\n                this._addContainer(resourceItem);\n            }\n            else\n            {\n                this.resolveQueueItem(resourceItem, this.queue);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Recursively add a container and its children to the queue\n     * @param {Container} container - The container to add to the queue\n     */\n    private _addContainer(container: Container): void\n    {\n        this.resolveQueueItem(container, this.queue);\n\n        // recursively add children\n        for (const child of container.children)\n        {\n            this._addContainer(child);\n        }\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n     * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n     */\n    public upload(resource?: PrepareSourceItem | PrepareSourceItem[]): Promise<void>\n    {\n        if (resource)\n        {\n            this.add(resource);\n        }\n\n        return new Promise((resolve) =>\n        {\n            if (this.queue.length)\n            {\n                // add resolve callback to the collection\n                this.resolves.push(resolve);\n\n                // eliminate duplicates first\n                this.dedupeQueue();\n\n                // launch first tick\n                Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n            else\n            {\n                // queue is empty, resolve immediately\n                resolve();\n            }\n        });\n    }\n\n    /** eliminate duplicates before processing */\n    public dedupeQueue(): void\n    {\n        const hash = Object.create(null);\n        let nextUnique = 0;\n\n        for (let i = 0; i < this.queue.length; i++)\n        {\n            const current = this.queue[i];\n\n            if (!hash[current.uid])\n            {\n                hash[current.uid] = true;\n                this.queue[nextUnique++] = current;\n            }\n        }\n\n        this.queue.length = nextUnique;\n    }\n\n    /** called per frame by the ticker, defer processing to next tick */\n    private readonly _tick = () =>\n    {\n        this.timeout = setTimeout(this._processQueue, 0) as unknown as number;\n    };\n\n    /** process the queue up to max item limit per frame */\n    private readonly _processQueue = () =>\n    {\n        const { queue } = this;\n        let itemsProcessed = 0;\n\n        // process the maximum number of items per frame\n        while (queue.length && itemsProcessed < PrepareBase.uploadsPerFrame)\n        {\n            const queueItem = queue.shift();\n\n            this.uploadQueueItem(queueItem);\n\n            itemsProcessed++;\n        }\n\n        if (queue.length)\n        {\n            // queue is not empty, continue processing on next frame\n            Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n        else\n        {\n            // queue is empty, resolve immediately\n            this._resolve();\n        }\n    };\n\n    /** Call all the resolve callbacks */\n    private _resolve(): void\n    {\n        const { resolves } = this;\n\n        // call all resolve callbacks\n        const array = resolves.slice(0);\n\n        resolves.length = 0;\n\n        for (const resolve of array)\n        {\n            resolve();\n        }\n    }\n}\n", "import { pointInTriangle } from '../../../maths/point/pointInTriangle';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { MeshGeometry } from './MeshGeometry';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\n\nexport interface TextureShader extends Shader\n{\n    texture: Texture;\n}\n\n/**\n * Constructor options used for `Mesh` instances. Extends {@link scene.MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link scene.Mesh}\n * @see {@link scene.MeshViewOptions}\n * @memberof scene\n */\n\n/**\n * @memberof scene\n */\nexport interface MeshOptions<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ContainerOptions\n{\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    geometry: GEOMETRY;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    shader?: SHADER | null;\n    /** The state of WebGL required to render the mesh. */\n    state?: State;\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    texture?: Texture;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof scene\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ViewContainer implements View, Instruction\n{\n    public override readonly renderPipeId: string = 'mesh';\n    public state: State;\n\n    /** @ignore */\n    public _texture: Texture;\n    /** @ignore */\n    public _geometry: GEOMETRY;\n    /** @ignore */\n    public _shader: SHADER | null = null;\n\n    /**\n     * @param {scene.MeshOptions} options - options for the mesh instance\n     */\n    constructor(options: MeshOptions<GEOMETRY, SHADER>);\n    /** @deprecated since 8.0.0 */\n    constructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n    constructor(...args: [MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0];\n\n        if (options instanceof Geometry)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'Mesh: use new Mesh({ geometry, shader }) instead');\n            // #endif\n\n            options = {\n                geometry: options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>;\n\n            if (args[3])\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'Mesh: drawMode argument has been removed, use geometry.topology instead');\n                // #endif\n\n                options.geometry.topology = args[3];\n            }\n        }\n\n        const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n\n        super({\n            label: 'Mesh',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this.shader = shader ?? null;\n        this.texture = texture ?? (shader as unknown as TextureShader)?.texture ?? Texture.WHITE;\n        this.state = state ?? State.for2d();\n\n        this._geometry = geometry;\n        this._geometry.on('update', this.onViewUpdate, this);\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /** Alias for {@link scene.Mesh#shader}. */\n    get material()\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'mesh.material property has been removed, use mesh.shader instead');\n        // #endif\n\n        return this._shader;\n    }\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    set shader(value: SHADER | null)\n    {\n        if (this._shader === value) return;\n\n        this._shader = value;\n        this.onViewUpdate();\n    }\n\n    get shader(): SHADER | null\n    {\n        return this._shader;\n    }\n\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    set geometry(value: GEOMETRY)\n    {\n        if (this._geometry === value) return;\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n        value.on('update', this.onViewUpdate, this);\n\n        this._geometry = value;\n        this.onViewUpdate();\n    }\n\n    get geometry()\n    {\n        return this._geometry;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        if (this.shader)\n        {\n            (this.shader as unknown as TextureShader).texture = value;\n        }\n\n        this._texture = value;\n        this.onViewUpdate();\n    }\n\n    get texture()\n    {\n        return this._texture;\n    }\n\n    get batched()\n    {\n        if (this._shader) return false;\n\n        // The state must be compatible with the batcher pipe.\n        // It isn't compatible if depth test or culling is enabled.\n        if ((this.state.data & 0b001100) !== 0) return false;\n\n        if (this._geometry instanceof MeshGeometry)\n        {\n            if (this._geometry.batchMode === 'auto')\n            {\n                return this._geometry.positions.length / 2 <= 100;\n            }\n\n            return this._geometry.batchMode === 'batch';\n        }\n\n        return false;\n    }\n\n    /**\n     * The local bounds of the mesh.\n     * @type {rendering.Bounds}\n     */\n    override get bounds()\n    {\n        return this._geometry.bounds;\n    }\n\n    /**\n     * Update local bounds of the mesh.\n     * @private\n     */\n    protected updateBounds()\n    {\n        this._bounds = this._geometry.bounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const { x, y } = point;\n\n        if (!this.bounds.containsPoint(x, y)) return false;\n\n        const vertices = this.geometry.getBuffer('aPosition').data;\n\n        const step = this.geometry.topology === 'triangle-strip' ? 3 : 1;\n\n        if (this.geometry.getIndex())\n        {\n            const indices = this.geometry.getIndex().data;\n            const len = indices.length;\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = indices[i] * 2;\n                const ind1 = indices[i + 1] * 2;\n                const ind2 = indices[i + 2] * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            const len = vertices.length / 2; // Each vertex has 2 coordinates, x and y\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = i * 2;\n                const ind1 = (i + 1) * 2;\n                const ind2 = (i + 2) * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n\n        this._texture = null;\n        this._geometry = null;\n        this._shader = null;\n    }\n}\n", "import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { UPDATE_PRIORITY } from '../../ticker/const';\nimport { Ticker } from '../../ticker/Ticker';\nimport { Sprite } from '../sprite/Sprite';\n\nimport type { SpriteOptions } from '../sprite/Sprite';\n\nexport type AnimatedSpriteFrames = Texture[] | FrameObject[];\n\n/**\n * Constructor options used for `AnimatedSprite` instances.\n * @see {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface AnimatedSpriteOptions extends SpriteOptions\n{\n    /** An array of {@link Texture} or frame objects that make up the animation. */\n    textures: AnimatedSpriteFrames;\n    /** Whether to use Ticker.shared to auto update animation time. */\n    autoUpdate?: boolean;\n}\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof scene\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n    /**\n     * @param frames - Collection of textures or frames to use.\n     * @param autoUpdate - Whether to use Ticker.shared to auto update animation time.\n     */\n    constructor(frames: AnimatedSpriteFrames, autoUpdate?: boolean);\n    /**\n     * @param options - The options for the AnimatedSprite.\n     */\n    constructor(options: AnimatedSpriteOptions);\n    /** @ignore */\n    constructor(...args: [AnimatedSpriteOptions?] | [AnimatedSpriteFrames?] | [AnimatedSpriteFrames?, boolean?])\n    {\n        let options = args[0] as AnimatedSpriteOptions;\n\n        if (Array.isArray(args[0]))\n        {\n            options = {\n                textures: args[0] as AnimatedSpriteFrames,\n                autoUpdate: args[1] as boolean,\n            };\n        }\n\n        const { textures, autoUpdate, ...rest } = options;\n        const [firstFrame] = textures;\n\n        super({\n            ...rest,\n            texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture,\n        });\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate ?? true;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = 1;\n        this.loop = true;\n        this.updateAnchor = false;\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param ticker - the ticker to use to update the object.\n     */\n    public update(ticker: Ticker): void\n    {\n        // If the animation isn't playing, no update is needed.\n        if (!this._playing)\n        {\n            return;\n        }\n\n        // Calculate elapsed time based on ticker's deltaTime and animation speed.\n        const deltaTime = ticker.deltaTime;\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        // If there are specific durations set for each frame:\n        if (this._durations !== null)\n        {\n            // Calculate the lag for the current frame based on the current time.\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            // Adjust the lag based on elapsed time.\n            lag += elapsed / 60 * 1000;\n\n            // If the lag is negative, adjust the current time and the lag.\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            // Floor the current time to get a whole number frame.\n            this._currentTime = Math.floor(this._currentTime);\n\n            // Adjust the current time and the lag until the lag is less than the current frame's duration.\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            // Adjust the current time based on the lag and current frame's duration.\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            // If no specific durations set, simply adjust the current time by elapsed time.\n            this._currentTime += elapsed;\n        }\n\n        // Handle scenarios when animation reaches the start or the end.\n        if (this._currentTime < 0 && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the start, go to the first frame.\n            this.gotoAndStop(0);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the end, go to the last frame.\n            this.gotoAndStop(this._textures.length - 1);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            // If the current frame is different from the last update, handle loop scenarios.\n            if (this.loop && this.onLoop)\n            {\n                if ((this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                    || (this.animationSpeed < 0 && this.currentFrame > previousFrame))\n                {\n                    // If the animation loops, and there's an onLoop callback, call it.\n                    this.onLoop();\n                }\n            }\n\n            // Update the texture for the current frame.\n            this._updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private _updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this.texture = this._textures[currentFrame];\n\n        if (this.updateAnchor)\n        {\n            this.anchor.copyFrom(this.texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /** Stops the AnimatedSprite and destroys it. */\n    public destroy(): void\n    {\n        this.stop();\n        super.destroy();\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): AnimatedSpriteFrames\n    {\n        return this._textures;\n    }\n\n    set textures(value: AnimatedSpriteFrames)\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this._updateTexture();\n    }\n\n    /** The AnimatedSprite's current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this._updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/**\n * A reference to a frame in an {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface FrameObject\n{\n    /** The {@link Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\n\nimport type { Observer } from '../../maths/point/ObservablePoint';\n\n/**\n * Options for the {@link utils.Transform} constructor.\n * @memberof utils.Transform\n */\nexport interface TransformOptions\n{\n    /** The matrix to use. */\n    matrix?: Matrix;\n    /** The observer to use. */\n    observer?: {_onUpdate: (transform: Transform) => void}\n}\n\n/**\n * The Transform class facilitates the manipulation of a 2D transformation matrix through\n * user-friendly properties: position, scale, rotation, skew, and pivot.\n * @memberof utils\n */\nexport class Transform\n{\n    /**\n     * The local transformation matrix.\n     * @internal\n     * @private\n     */\n    public _matrix: Matrix;\n\n    /** The coordinate of the object relative to the local coordinates of the parent. */\n    public position: ObservablePoint;\n\n    /** The scale factor of the object. */\n    public scale: ObservablePoint;\n\n    /** The pivot point of the container that it rotates around. */\n    public pivot: ObservablePoint;\n\n    /** The skew amount, on the x and y axis. */\n    public skew: ObservablePoint;\n\n    /** The rotation amount. */\n    protected _rotation: number;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _cx: number;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _sx: number;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _cy: number;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _sy: number;\n\n    protected dirty = true;\n    protected observer: Observer<Transform>;\n\n    /**\n     * @param options - Options for the transform.\n     * @param options.matrix - The matrix to use.\n     * @param options.observer - The observer to use.\n     */\n    constructor({ matrix, observer }: TransformOptions = {})\n    {\n        this._matrix = matrix ?? new Matrix();\n        this.observer = observer;\n\n        this.position = new ObservablePoint(this, 0, 0);\n        this.scale = new ObservablePoint(this, 1, 1);\n        this.pivot = new ObservablePoint(this, 0, 0);\n        this.skew = new ObservablePoint(this, 0, 0);\n\n        this._rotation = 0;\n        this._cx = 1;\n        this._sx = 0;\n        this._cy = 0;\n        this._sy = 1;\n    }\n\n    /**\n     * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot\n     * properties into a single matrix.\n     * @readonly\n     */\n    get matrix(): Matrix\n    {\n        const lt = this._matrix;\n\n        if (!this.dirty) return lt;\n\n        lt.a = this._cx * this.scale.x;\n        lt.b = this._sx * this.scale.x;\n        lt.c = this._cy * this.scale.y;\n        lt.d = this._sy * this.scale.y;\n\n        lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n        lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n\n        this.dirty = false;\n\n        return lt;\n    }\n    /**\n     * Called when a value changes.\n     * @param point\n     * @internal\n     * @private\n     */\n    public _onUpdate(point?: ObservablePoint): void\n    {\n        this.dirty = true;\n\n        if (point === this.skew)\n        {\n            this.updateSkew();\n        }\n\n        this.observer?._onUpdate(this);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    protected updateSkew(): void\n    {\n        this._cx = Math.cos(this._rotation + this.skew.y);\n        this._sx = Math.sin(this._rotation + this.skew.y);\n        this._cy = -Math.sin(this._rotation - this.skew.x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew.x); // sin, added PI/2\n\n        this.dirty = true;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Transform `\n            + `position=(${this.position.x}, ${this.position.y}) `\n            + `rotation=${this.rotation} `\n            + `scale=(${this.scale.x}, ${this.scale.y}) `\n            + `skew=(${this.skew.x}, ${this.skew.y}) `\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     * @param matrix - The matrix to decompose\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n        this.dirty = true;\n    }\n\n    /** The rotation of the object in radians. */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this.skew);\n        }\n    }\n}\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends ViewContainer implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /**\n         * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n         * local space.\n         *\n         * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n         * this, the top-left corner always gets the (0, 0) texture coordinate.\n         * @default false\n         */\n        applyAnchorToTexture: false,\n    };\n\n    public override readonly renderPipeId: string = 'tilingSprite';\n    public readonly batched = true;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @default false\n     */\n    public applyAnchorToTexture: boolean;\n    /**\n     * @see {@link scene.TilingSpriteOptions.applyAnchorToTexture}\n     * @deprecated since 8.0.0\n     */\n    public get uvRespectAnchor(): boolean\n    {\n        warn('uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n\n        return this.applyAnchorToTexture;\n    }\n    public set uvRespectAnchor(value: boolean)\n    {\n        warn('uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n        this.applyAnchorToTexture = value;\n    }\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this.applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the TilingSprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    /**\n     * @private\n     */\n    protected override updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ViewContainer implements View\n{\n    public batched = true;\n    public _anchor: ObservablePoint;\n\n    public _resolution: number = null;\n    public _autoResolution: boolean = true;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style ||= {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public override onViewUpdate()\n    {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n\n    public _getKey(): string\n    {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n", "import { AbstractText, ensureOptions } from './AbstractText';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and givae the `wordWrapWidth` property a value.\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions>\n    implements View\n{\n    public override readonly renderPipeId: string = 'text';\n\n    /**\n     * @param {text.TextOptions} options - The options of the text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'Text');\n\n        super(options, TextStyle);\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const canvasMeasurement = CanvasTextMetrics.measureText(\n            this._text,\n            this._style\n        );\n\n        const { width, height } = canvasMeasurement;\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height);\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { Container } from '../scene/container/Container';\nimport { Graphics } from '../scene/graphics/shared/Graphics';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport { Mesh } from '../scene/mesh/shared/Mesh';\nimport { Sprite } from '../scene/sprite/Sprite';\nimport { AnimatedSprite } from '../scene/sprite-animated/AnimatedSprite';\nimport { TilingSprite } from '../scene/sprite-tiling/TilingSprite';\nimport { Text } from '../scene/text/Text';\nimport { PrepareBase } from './PrepareBase';\n\nimport type { FillInstruction, TextureInstruction } from '../scene/graphics/shared/GraphicsContext';\nimport type { FrameObject } from '../scene/sprite-animated/AnimatedSprite';\nimport type { PrepareQueueItem, PrepareSourceItem } from './PrepareBase';\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the base functionality and resolves given resource items ready for the queue.\n * @memberof rendering\n */\nexport abstract class PrepareQueue extends PrepareBase\n{\n    /**\n     * Resolve the given resource type and return an item for the queue\n     * @param source\n     * @param queue\n     */\n    protected resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void\n    {\n        if (source instanceof Container)\n        {\n            this.resolveContainerQueueItem(source, queue);\n        }\n        else if (source instanceof TextureSource || source instanceof Texture)\n        {\n            queue.push(source.source);\n        }\n        else if (source instanceof GraphicsContext)\n        {\n            queue.push(source);\n        }\n\n        // could not resolve the resource type\n        return null;\n    }\n\n    /**\n     * Resolve the given container and return an item for the queue\n     * @param container\n     * @param queue\n     */\n    protected resolveContainerQueueItem(container: Container, queue: PrepareQueueItem[]): void\n    {\n        // Note: we are just concerned with the given view.\n        // Children are handled by the recursive call of the base class\n\n        if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh)\n        {\n            queue.push(container.texture.source);\n        }\n        else if (container instanceof Text)\n        {\n            queue.push(container);\n        }\n        else if (container instanceof Graphics)\n        {\n            queue.push(container.context);\n        }\n        else if (container instanceof AnimatedSprite)\n        {\n            container.textures.forEach((textureOrFrame) =>\n            {\n                if ((textureOrFrame as Texture).source)\n                {\n                    queue.push((textureOrFrame as Texture).source);\n                }\n                else\n                {\n                    queue.push((textureOrFrame as FrameObject).texture.source);\n                }\n            });\n        }\n    }\n\n    /**\n     * Resolve the given graphics context and return an item for the queue\n     * @param graphicsContext\n     */\n    protected resolveGraphicsContextQueueItem(graphicsContext: GraphicsContext): PrepareQueueItem | null\n    {\n        this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n\n        const { instructions } = graphicsContext;\n\n        for (const instruction of instructions)\n        {\n            if (instruction.action === 'texture')\n            {\n                const { image } = (instruction as TextureInstruction).data;\n\n                return image.source;\n            }\n            else if (instruction.action === 'fill')\n            {\n                const { texture } = (instruction as FillInstruction).data.style;\n\n                return texture.source;\n            }\n        }\n\n        return null;\n    }\n}\n", "import { warn } from '../../utils/logging/warn';\nimport { AbstractText, ensureOptions } from '../text/AbstractText';\nimport { TextStyle } from '../text/TextStyle';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from '../text/AbstractText';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * A BitmapText Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * The text is created using a bitmap font (a sprite sheet of characters).\n *\n * The primary advantage of this render mode over `text` is that all of your textures are pre-generated and loaded,\n * meaning that rendering is fast, and changing text is much faster than Text.\n *\n * The primary disadvantage is that supporting character sets other than latin, such as CJK languages,\n * may be impractical due to the number of characters.\n *\n * <b>Pre-loaded BitmapFonts:</b>\n *\n *\n * PixiJS enables the loading of BitmapFonts through its Asset Manager, supporting both XML and FNT formats.\n * Additionally, PixiJS is compatible with MSDF (Multi-channel Signed Distance Field) and SDF (Signed Distance Field) fonts.\n * These advanced font types allow for scaling without quality degradation and must be created with specific tools,\n * such as the one available at https://msdf-bmfont.donmccurdy.com/.\n *\n * <b>Dynamically Generated BitmapFonts:</b>\n *\n *\n * PixiJS also offers the capability to generate BitmapFonts dynamically. This means that fonts are created in real-time\n * based on specified styles, eliminating the need for pre-loading. This process is initiated simply by assigning a style\n * to a BitmapText object, which then automatically generates the required font.\n *\n * However, dynamically generating a large number of fonts may lead to significant memory use. To prevent this,\n * PixiJS smartly attempts to reuse fonts that closely match the desired style parameters. For instance, if a text style\n * requires a font size of 80 but a similar font of size 100 has already been generated, PixiJS will scale the existing\n * font to fit the new requirement, rather than creating a new font from scratch.\n *\n * For those who prefer to manage BitmapFonts manually, PixiJS provides the BitmapFont.install method. This method\n * allows for the pre-generation and preparation of fonts, making them readily available for use by specifying the\n * fontFamily in your text styling.\n *\n * This approach ensures efficient font management within PixiJS, balancing between dynamic generation for flexibility\n * and manual management for optimized performance.\n * @example\n * import { BitmapText, BitmapFont } from 'pixi.js';\n *\n * // generate a dynamic font behind the scenes:\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // pre install\n * BitmapFont.install({\n *    name: 'myFont',\n *    style:{\n *        fontFamily: 'Arial',\n *    }\n * })\n *\n * // new bitmap text with preinstalled font\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myFont',\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * }\n *\n * // load a font from an xml file\n * const font = await Assets.load('path/to/myLoadedFont.fnt');\n *\n * // new bitmap text with loaded font\n * const text = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myLoadedFont', // the name of the font in the fnt file\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * }\n * @memberof scene\n */\nexport class BitmapText extends AbstractText<TextStyle, TextStyleOptions> implements View\n{\n    public override readonly renderPipeId: string = 'bitmapText';\n\n    /**\n     * **Note:** Our docs parser struggles to properly understand the constructor signature.\n     * This is the correct signature.\n     * ```ts\n     * new BitmapText(options?: TextOptions);\n     * ```\n     * @param { text.TextOptions } options - The options of the bitmap text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'BitmapText');\n\n        options.style ??= options.style || {};\n        options.style.fill ??= 0xffffff;\n\n        super(options, TextStyle);\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);\n        const scale = bitmapMeasurement.scale;\n        const offset = bitmapMeasurement.offsetY * scale;\n\n        let width = bitmapMeasurement.width * scale;\n        let height = bitmapMeasurement.height * scale;\n\n        const stroke = this._style._stroke;\n\n        if (stroke)\n        {\n            width += stroke.width;\n            height += stroke.width;\n        }\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * (height + offset));\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    override set resolution(value: number)\n    {\n        // #if _DEBUG\n        if (value !== null)\n        {\n            warn(\n            // eslint-disable-next-line max-len\n                '[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.'\n            );\n        }\n        // #endif\n    }\n\n    override get resolution(): number\n    {\n        return this._resolution;\n    }\n}\n", "import { AbstractText, ensureOptions } from '../text/AbstractText';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from '../text/AbstractText';\nimport type { HTMLTextStyleOptions } from './HtmlTextStyle';\n\n/**\n * Constructor options used for `HTMLText` instances.\n * @property {string} [text=''] - The string that you would like the text to display.\n * @property {text.HTMLTextStyle | text.HTMLTextStyleOptions} [style] - The style of the text.\n * @memberof text\n */\nexport type HTMLTextOptions = TextOptions<HTMLTextStyle, HTMLTextStyleOptions>;\n\n/**\n * A HTMLText Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * HTMLText uses an svg foreignObject to render HTML text.\n *\n *\n * The primary advantages of this render mode are:\n *\n *  - Supports [HTML tags](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals)\n * for styling such as `<strong>`, or `<em>`, as well as `<span style=\"\">`\n *\n *       - Better support for emojis and other HTML layout features, better compatibility with CSS\n *     line-height and letter-spacing.\n *\n *\n * The primary disadvantages are:\n *   - Unlike `text`, `html` rendering will vary slightly between platforms and browsers.\n * `html` uses SVG/DOM to render text and not Context2D's fillText like `text`.\n *\n *   - Performance and memory usage is on-par with `text` (that is to say, slow and heavy)\n *\n *   - Only works with browsers that support <foreignObject>.\n * @example\n * import { HTMLText } from 'pixi.js';\n *\n * const text = new HTMLText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class HTMLText extends AbstractText<HTMLTextStyle, HTMLTextStyleOptions> implements View\n{\n    public override readonly renderPipeId: string = 'htmlText';\n\n    /**\n     * @param {text.HTMLTextOptions} options - The options of the html text.\n     */\n    constructor(options?: HTMLTextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<HTMLTextStyle>);\n    constructor(...args: [HTMLTextOptions?] | [TextString, Partial<HTMLTextStyle>])\n    {\n        const options = ensureOptions<HTMLTextStyle, HTMLTextStyleOptions>(args, 'HtmlText');\n\n        super(options, HTMLTextStyle);\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const htmlMeasurement = measureHtmlText(this.text, this._style as HTMLTextStyle);\n\n        const { width, height } = htmlMeasurement;\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height);\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport { Text } from '../scene/text/Text';\nimport { BitmapText } from '../scene/text-bitmap/BitmapText';\nimport { HTMLText } from '../scene/text-html/HTMLText';\nimport { PrepareQueue } from './PrepareQueue';\n\nimport type { FillInstruction, TextureInstruction } from '../scene/graphics/shared/GraphicsContext';\nimport type { PrepareQueueItem } from './PrepareBase';\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the resolver functionality and uploads the given queue items.\n * @memberof rendering\n */\nexport abstract class PrepareUpload extends PrepareQueue\n{\n    /**\n     * Upload the given queue item\n     * @param item\n     */\n    protected uploadQueueItem(item: PrepareQueueItem): void\n    {\n        if (item instanceof TextureSource)\n        {\n            this.uploadTextureSource(item);\n        }\n        else if (item instanceof Text)\n        {\n            this.uploadText(item);\n        }\n        else if (item instanceof HTMLText)\n        {\n            this.uploadHTMLText(item);\n        }\n        else if (item instanceof BitmapText)\n        {\n            this.uploadBitmapText(item);\n        }\n        else if (item instanceof GraphicsContext)\n        {\n            this.uploadGraphicsContext(item);\n        }\n    }\n\n    protected uploadTextureSource(textureSource: TextureSource): void\n    {\n        this.renderer.texture.initSource(textureSource);\n    }\n\n    protected uploadText(_text: Text): void\n    {\n        this.renderer.renderPipes.text.initGpuText(_text);\n    }\n\n    protected uploadBitmapText(_text: BitmapText): void\n    {\n        this.renderer.renderPipes.bitmapText.initGpuText(_text);\n    }\n\n    protected uploadHTMLText(_text: HTMLText): void\n    {\n        this.renderer.renderPipes.htmlText.initGpuText(_text);\n    }\n\n    /**\n     * Resolve the given graphics context and return an item for the queue\n     * @param graphicsContext\n     */\n    protected uploadGraphicsContext(graphicsContext: GraphicsContext): void\n    {\n        this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n\n        const { instructions } = graphicsContext;\n\n        for (const instruction of instructions)\n        {\n            if (instruction.action === 'texture')\n            {\n                const { image } = (instruction as TextureInstruction).data;\n\n                this.uploadTextureSource(image.source);\n            }\n            else if (instruction.action === 'fill')\n            {\n                const { texture } = (instruction as FillInstruction).data.style;\n\n                this.uploadTextureSource(texture.source);\n            }\n        }\n\n        return null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { PrepareUpload } from './PrepareUpload';\n\nimport type { System } from '../rendering/renderers/shared/system/System';\n\n/**\n * The prepare system provides renderer-specific plugins for pre-rendering DisplayObjects. This is useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.prepare` property.\n * @example\n * import 'pixi.js/prepare';\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (prepare will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // Create a display object\n * const rect = new Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @memberof rendering\n */\nexport class PrepareSystem extends PrepareUpload implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'prepare',\n    } as const;\n\n    /** Destroys the plugin, don't use after this. */\n    public destroy(): void\n    {\n        clearTimeout(this.timeout);\n        this.renderer = null;\n        this.queue = null;\n        this.resolves = null;\n    }\n}\n", "export function generateGPULayout(maxTextures: number): GPUBindGroupLayoutEntry[]\n{\n    const gpuLayout: GPUBindGroupLayoutEntry[] = [];\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        gpuLayout[bindIndex] = {\n            texture: {\n                sampleType: 'float',\n                viewDimension: '2d',\n                multisampled: false,\n            },\n            binding: bindIndex,\n            visibility: GPUShaderStage.FRAGMENT,\n        };\n        bindIndex++;\n\n        gpuLayout[bindIndex] = {\n            sampler: {\n                type: 'filtering',\n            },\n            binding: bindIndex,\n            visibility: GPUShaderStage.FRAGMENT,\n        };\n\n        bindIndex++;\n    }\n\n    return gpuLayout;\n}\n", "export function generateLayout(maxTextures: number): Record<string, number>\n{\n    const layout: Record<string, number> = {};\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        layout[`textureSource${i + 1}`] = bindIndex++;\n        layout[`textureSampler${i + 1}`] = bindIndex++;\n    }\n\n    return layout;\n}\n", "/**\n * formats a shader so its more pleasant to read!\n * @param shader - a glsl shader program source\n */\nexport function formatShader(shader: string): string\n{\n    const spl = shader.split(/([\\n{}])/g)\n        .map((a) => a.trim())\n        .filter((a) => a.length);\n\n    let indent = '';\n\n    const formatted = spl.map((a) =>\n    {\n        let indentedLine = indent + a;\n\n        if (a === '{')\n        {\n            indent += '    ';\n        }\n        else if (a === '}')\n        {\n            indent = indent.substr(0, indent.length - 4);\n\n            indentedLine = indent + a;\n        }\n\n        return indentedLine;\n    }).join('\\n');\n\n    return formatted;\n}\n\n", "import { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\n\nexport class ScissorMask implements Effect\n{\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'scissorMask';\n\n    constructor(mask: Container)\n    {\n        this.mask = mask;\n\n        this.mask.renderable = false;\n        this.mask.measurable = false;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n}\n", "export function migrateFragmentFromV7toV8(fragmentShader: string): string\n{\n    fragmentShader = fragmentShader\n        .replaceAll('texture2D', 'texture')\n        .replaceAll('gl_FragColor', 'finalColor')\n        .replaceAll('varying', 'in');\n\n    fragmentShader = `\n        out vec4 finalColor;\n    ${fragmentShader}\n    `;\n\n    return fragmentShader;\n}\n", "import type { Dict } from '../../../../../utils/types';\n\nconst GLSL_TO_SIZE: Dict<number> = {\n    float:    1,\n    vec2:     2,\n    vec3:     3,\n    vec4:     4,\n\n    int:      1,\n    ivec2:    2,\n    ivec3:    3,\n    ivec4:    4,\n\n    uint:     1,\n    uvec2:    2,\n    uvec3:    3,\n    uvec4:    4,\n\n    bool:     1,\n    bvec2:    2,\n    bvec3:    3,\n    bvec4:    4,\n\n    mat2:     4,\n    mat3:     9,\n    mat4:     16,\n\n    sampler2D:  1,\n};\n\n/**\n * @private\n * @method mapSize\n * @param {string} type\n */\nexport function mapSize(type: string): number\n{\n    return GLSL_TO_SIZE[type];\n}\n", "import { Buffer } from '../../shared/buffer/Buffer';\nimport { BufferUsage } from '../../shared/buffer/const';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nexport function GpuReadBuffer(buffer: Buffer, renderer: WebGPURenderer)\n{\n    const bufferSize = buffer.descriptor.size;\n\n    const device = renderer.gpu.device;\n\n    const stagingBuffer = new Buffer({\n        data: new Float32Array(2400000),\n        usage: BufferUsage.MAP_READ | BufferUsage.COPY_DST,\n    });\n\n    const stagingGPUBuffer = renderer.buffer.createGPUBuffer(stagingBuffer);\n\n    const commandEncoder = device.createCommandEncoder();\n\n    commandEncoder.copyBufferToBuffer(\n        renderer.buffer.getGPUBuffer(buffer),\n        0, // Source offset\n        stagingGPUBuffer,\n        0, // Destination offset\n        bufferSize,\n    );\n\n    device.queue.submit([commandEncoder.finish()]);\n\n    void stagingGPUBuffer.mapAsync(\n        GPUMapMode.READ,\n        0, // Offset\n        bufferSize, // Length\n    ).then(() =>\n    {\n        stagingGPUBuffer.getMappedRange(0, bufferSize);\n        stagingGPUBuffer.unmap();\n    });\n}\n", "import { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\n/**\n * The different topology types supported by the renderer used to describe how the geometry should be renderer\n * @memberof rendering\n */\nexport type Topology =\n    'point-list'\n    | 'line-list'\n    | 'line-strip'\n    | 'triangle-list'\n    | 'triangle-strip';\n\nconst DEPRECATED_DRAW_MODES = {\n    POINTS: 'point-list',\n    LINES: 'line-list',\n    LINE_STRIP: 'line-strip',\n    TRIANGLES: 'triangle-list',\n    TRIANGLE_STRIP: 'triangle-strip',\n};\n\n/** @deprecated since 8.0.0 */\nexport const DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {\n    get(target, prop: keyof typeof DEPRECATED_DRAW_MODES)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);\n        // #endif\n\n        return target[prop];\n    },\n});\n\n/**\n * The different types of vertex formats supported by the renderer\n * @memberof rendering\n */\nexport type VertexFormat =\n    | 'uint8x2'\n    | 'uint8x4'\n    | 'sint8x2'\n    | 'sint8x4'\n    | 'unorm8x2'\n    | 'unorm8x4'\n    | 'snorm8x2'\n    | 'snorm8x4'\n    | 'uint16x2'\n    | 'uint16x4'\n    | 'sint16x2'\n    | 'sint16x4'\n    | 'unorm16x2'\n    | 'unorm16x4'\n    | 'snorm16x2'\n    | 'snorm16x4'\n    | 'float16x2'\n    | 'float16x4'\n    | 'float32'\n    | 'float32x2'\n    | 'float32x3'\n    | 'float32x4'\n    | 'uint32'\n    | 'uint32x2'\n    | 'uint32x3'\n    | 'uint32x4'\n    | 'sint32'\n    | 'sint32x2'\n    | 'sint32x3'\n    | 'sint32x4';\n\n", "import { Rectangle } from '../../../../maths/shapes/Rectangle';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\nconst fullFrame = new Rectangle(0, 0, 1, 1);\n\n/**\n * Takes a Texture source and a normalised frame\n * and returns a viewport for that frame.\n * @param viewport - The viewport rectangle to set.\n * @param source - The source to get the pixel width and height from.\n * @param frame - The frame to get the viewport from.\n * @returns the passed in viewport.\n */\nexport function viewportFromFrame(\n    viewport: Rectangle,\n    source: TextureSource,\n    frame?: Rectangle\n)\n{\n    frame ||= fullFrame;\n\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n\n    viewport.x = (frame.x * pixelWidth) | 0;\n    viewport.y = (frame.y * pixelHeight) | 0;\n    viewport.width = (frame.width * pixelWidth) | 0;\n    viewport.height = (frame.height * pixelHeight) | 0;\n\n    return viewport;\n}\n", "/* eslint-disable @typescript-eslint/indent */\n\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\n/**\n * Specifies the alpha composition mode for textures.\n *\n * - `no-premultiply-alpha`: Does not premultiply alpha.\n * - `premultiply-alpha-on-upload`: Premultiplies alpha on texture upload.\n * - `premultiplied-alpha`: Assumes the texture is already in premultiplied alpha format.\n * @typedef {'no-premultiply-alpha' | 'premultiply-alpha-on-upload' | 'premultiplied-alpha'} ALPHA_MODES\n */\nexport type ALPHA_MODES =\n    'no-premultiply-alpha' |\n    'premultiply-alpha-on-upload' |\n    'premultiplied-alpha';\n\n/**\n * Constants for multi-sampling antialiasing.\n * @see Framebuffer#multisample\n * @name MSAA_QUALITY\n * @static\n * @enum {number}\n * @property {number} NONE - No multisampling for this renderTexture\n * @property {number} LOW - Try 2 samples\n * @property {number} MEDIUM - Try 4 samples\n * @property {number} HIGH - Try 8 samples\n */\nexport enum MSAA_QUALITY\n    // eslint-disable-next-line @typescript-eslint/indent\n{\n    NONE = 0,\n    LOW = 2,\n    MEDIUM = 4,\n    HIGH = 8\n}\n\nexport type TEXTURE_FORMATS =\n    // eslint-disable-next-line @typescript-eslint/indent\n\n    // 8-bit formats\n    'r8unorm' |\n    'r8snorm' |\n    'r8uint' |\n    'r8sint' |\n\n    // 16-bit formats\n    'r16uint' |\n    'r16sint' |\n    'r16float' |\n    'rg8unorm' |\n    'rg8snorm' |\n    'rg8uint' |\n    'rg8sint' |\n\n    // 32-bit formats\n    'r32uint' |\n    'r32sint' |\n    'r32float' |\n    'rg16uint' |\n    'rg16sint' |\n    'rg16float' |\n    'rgba8unorm' |\n    'rgba8unorm-srgb' |\n    'rgba8snorm' |\n    'rgba8uint' |\n    'rgba8sint' |\n    'bgra8unorm' |\n    'bgra8unorm-srgb' |\n    // Packed 32-bit formats\n    'rgb9e5ufloat' |\n    'rgb10a2unorm' |\n    'rg11b10ufloat' |\n\n    // 64-bit formats\n    'rg32uint' |\n    'rg32sint' |\n    'rg32float' |\n    'rgba16uint' |\n    'rgba16sint' |\n    'rgba16float' |\n\n    // 128-bit formats\n    'rgba32uint' |\n    'rgba32sint' |\n    'rgba32float' |\n\n    // Depth/stencil formats\n    'stencil8' |\n    'depth16unorm' |\n    'depth24plus' |\n    'depth24plus-stencil8' |\n    'depth32float' |\n\n    // \"depth32float-stencil8\" feature\n    'depth32float-stencil8' |\n\n    // BC compressed formats usable if \"texture-compression-bc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'bc1-rgba-unorm' |\n    'bc1-rgba-unorm-srgb' |\n    'bc2-rgba-unorm' |\n    'bc2-rgba-unorm-srgb' |\n    'bc3-rgba-unorm' |\n    'bc3-rgba-unorm-srgb' |\n    'bc4-r-unorm' |\n    'bc4-r-snorm' |\n    'bc5-rg-unorm' |\n    'bc5-rg-snorm' |\n    'bc6h-rgb-ufloat' |\n    'bc6h-rgb-float' |\n    'bc7-rgba-unorm' |\n    'bc7-rgba-unorm-srgb' |\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm' |\n    'etc2-rgb8unorm-srgb' |\n    'etc2-rgb8a1unorm' |\n    'etc2-rgb8a1unorm-srgb' |\n    'etc2-rgba8unorm' |\n    'etc2-rgba8unorm-srgb' |\n    'eac-r11unorm' |\n    'eac-r11snorm' |\n    'eac-rg11unorm' |\n    'eac-rg11snorm' |\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm' |\n    'astc-4x4-unorm-srgb' |\n    'astc-5x4-unorm' |\n    'astc-5x4-unorm-srgb' |\n    'astc-5x5-unorm' |\n    'astc-5x5-unorm-srgb' |\n    'astc-6x5-unorm' |\n    'astc-6x5-unorm-srgb' |\n    'astc-6x6-unorm' |\n    'astc-6x6-unorm-srgb' |\n    'astc-8x5-unorm' |\n    'astc-8x5-unorm-srgb' |\n    'astc-8x6-unorm' |\n    'astc-8x6-unorm-srgb' |\n    'astc-8x8-unorm' |\n    'astc-8x8-unorm-srgb' |\n    'astc-10x5-unorm' |\n    'astc-10x5-unorm-srgb' |\n    'astc-10x6-unorm' |\n    'astc-10x6-unorm-srgb' |\n    'astc-10x8-unorm' |\n    'astc-10x8-unorm-srgb' |\n    'astc-10x10-unorm' |\n    'astc-10x10-unorm-srgb' |\n    'astc-12x10-unorm' |\n    'astc-12x10-unorm-srgb' |\n    'astc-12x12-unorm' |\n    'astc-12x12-unorm-srgb';\n\nexport type TEXTURE_VIEW_DIMENSIONS =\n    '1d' |\n    '2d' |\n    '2d-array' |\n    'cube' |\n    'cube-array' |\n    '3d';\n\nexport type TEXTURE_DIMENSIONS =\n    | '1d'\n    | '2d'\n    | '3d';\n\nexport type WRAP_MODE =\n    /**\n     * The texture uvs are clamped\n     * @default 33071\n     */\n    | 'clamp-to-edge'\n    /**\n     * The texture uvs tile and repeat\n     * @default 10497\n     */\n    | 'repeat'\n    /**\n     * The texture uvs tile and repeat with mirroring\n     * @default 33648\n     */\n    | 'mirror-repeat';\n\nexport enum DEPRECATED_WRAP_MODES\n{\n    CLAMP = 'clamp-to-edge',\n\n    REPEAT = 'repeat',\n\n    MIRRORED_REPEAT = 'mirror-repeat',\n}\n\n/** @deprecated since 8.0.0 */\nexport const WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {\n    get(target, prop: keyof typeof DEPRECATED_WRAP_MODES)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);\n        // #endif\n\n        return target[prop];\n    },\n});\n\n/**\n * The scale modes that are supported by pixi.\n *\n * The {@link settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.\n * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n * @static\n */\nexport type SCALE_MODE =\n    /** Pixelating scaling */\n | 'nearest'\n     /** Smooth scaling */\n | 'linear';\n\nexport enum DEPRECATED_SCALE_MODES\n{\n    NEAREST = 'nearest',\n    LINEAR = 'linear',\n}\n\n/**\n * @deprecated since 8.0.0\n */\nexport const SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {\n    get(target, prop: keyof typeof DEPRECATED_SCALE_MODES)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);\n        // #endif\n\n        return target[prop];\n    },\n});\n\nexport type COMPARE_FUNCTION =\n    | 'never'\n    | 'less'\n    | 'equal'\n    | 'less-equal'\n    | 'greater'\n    | 'not-equal'\n    | 'greater-equal'\n    | 'always';\n", "import { groupD8 } from '../../../../maths/matrix/groupD8';\n\nimport type { Size } from '../../../../maths/misc/Size';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\n\n/**\n * Stores a texture's frame in UV coordinates, in\n * which everything lies in the rectangle `[(0,0), (1,0),\n * (1,1), (0,1)]`.\n *\n * | Corner       | Coordinates |\n * |--------------|-------------|\n * | Top-Left     | `(x0,y0)`   |\n * | Top-Right    | `(x1,y1)`   |\n * | Bottom-Right | `(x2,y2)`   |\n * | Bottom-Left  | `(x3,y3)`   |\n * @protected\n * @memberof rendering\n */\nexport class TextureUvs\n{\n    /** X-component of top-left corner `(x0,y0)`. */\n    public x0: number;\n\n    /** Y-component of top-left corner `(x0,y0)`. */\n    public y0: number;\n\n    /** X-component of top-right corner `(x1,y1)`. */\n    public x1: number;\n\n    /** Y-component of top-right corner `(x1,y1)`. */\n    public y1: number;\n\n    /** X-component of bottom-right corner `(x2,y2)`. */\n    public x2: number;\n\n    /** Y-component of bottom-right corner `(x2,y2)`. */\n    public y2: number;\n\n    /** X-component of bottom-left corner `(x3,y3)`. */\n    public x3: number;\n\n    /** Y-component of bottom-right corner `(x3,y3)`. */\n    public y3: number;\n    public uvsFloat32: Float32Array;\n\n    constructor()\n    {\n        this.x0 = 0;\n        this.y0 = 0;\n        this.x1 = 1;\n        this.y1 = 0;\n        this.x2 = 1;\n        this.y2 = 1;\n        this.x3 = 0;\n        this.y3 = 1;\n\n        this.uvsFloat32 = new Float32Array(8);\n    }\n\n    /**\n     * Sets the texture Uvs based on the given frame information.\n     * @protected\n     * @param frame - The frame of the texture\n     * @param baseFrame - The base frame of the texture\n     * @param rotate - Rotation of frame, see {@link groupD8}\n     */\n    public set(frame: Rectangle, baseFrame: Size, rotate: number): void\n    {\n        const tw = baseFrame.width;\n        const th = baseFrame.height;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = frame.width / 2 / tw;\n            const h2 = frame.height / 2 / th;\n\n            // coordinates of center\n            const cX = (frame.x / tw) + w2;\n            const cY = (frame.y / th) + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            this.x0 = cX + (w2 * groupD8.uX(rotate));\n            this.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            this.x1 = cX + (w2 * groupD8.uX(rotate));\n            this.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            this.x2 = cX + (w2 * groupD8.uX(rotate));\n            this.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            this.x3 = cX + (w2 * groupD8.uX(rotate));\n            this.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n        else\n        {\n            this.x0 = frame.x / tw;\n            this.y0 = frame.y / th;\n\n            this.x1 = (frame.x + frame.width) / tw;\n            this.y1 = frame.y / th;\n\n            this.x2 = (frame.x + frame.width) / tw;\n            this.y2 = (frame.y + frame.height) / th;\n\n            this.x3 = frame.x / tw;\n            this.y3 = (frame.y + frame.height) / th;\n        }\n\n        this.uvsFloat32[0] = this.x0;\n        this.uvsFloat32[1] = this.y0;\n        this.uvsFloat32[2] = this.x1;\n        this.uvsFloat32[3] = this.y1;\n        this.uvsFloat32[4] = this.x2;\n        this.uvsFloat32[5] = this.y2;\n        this.uvsFloat32[6] = this.x3;\n        this.uvsFloat32[7] = this.y3;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:TextureUvs `\n            + `x0=${this.x0} y0=${this.y0} `\n            + `x1=${this.x1} y1=${this.y1} x2=${this.x2} `\n            + `y2=${this.y2} x3=${this.x3} y3=${this.y3}`\n            + `]`;\n    }\n    // #endif\n}\n", "let uidCount = 0;\n\nexport function generateUID(): number\n{\n    return uidCount++;\n}\n", "export function parseFunctionBody(fn: (...args: any[]) => any): string\n{\n    const fnStr = fn.toString();\n    const bodyStart = fnStr.indexOf('{');\n    const bodyEnd = fnStr.lastIndexOf('}');\n\n    if (bodyStart === -1 || bodyEnd === -1)\n    {\n        throw new Error('getFunctionBody: No body found in function definition');\n    }\n\n    return fnStr.slice(bodyStart + 1, bodyEnd).trim();\n}\n", "import { ViewContainer } from '../view/ViewContainer';\n\nimport type { Point } from '../../maths/point/Point';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Bounds, BoundsData } from './bounds/Bounds';\nimport type { ContainerOptions } from './Container';\n\ntype RenderFunction = (renderer: Renderer) => void;\n\n/**\n * Options for the {@link scene.RenderContainer} constructor.\n * @memberof scene\n */\nexport interface RenderContainerOptions extends ContainerOptions\n{\n    /** the optional custom render function if you want to inject the function via the constructor */\n    render?: RenderFunction;\n    /** how to know if the custom render logic contains a point or not, used for interaction */\n    containsPoint?: (point: Point) => boolean;\n    /** how to add the bounds of this object when measuring */\n    addBounds?: (bounds: BoundsData) => void;\n}\n\n/**\n * A container that allows for custom rendering logic. Its essentially calls the render function each frame\n * and allows for custom rendering logic - the render could be a WebGL renderer or WebGPU render or even a canvas render.\n * Its up to you to define the logic.\n *\n * This can be used in two ways, either by extending the class and overriding the render method,\n * or by passing a custom render function\n * @example\n * ```js\n * import { RenderContainer } from 'pixi.js';\n *\n * // extend the class\n * class MyRenderContainer extends RenderContainer\n * {\n *    render(renderer)\n *    {\n *      renderer.clear({\n *         clearColor: 'green', // clear the screen to green when rendering this item\n *      });\n *   }\n * }\n *\n * // override the render method\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class RenderContainer extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'customRender';\n    public batched = false;\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds: (bounds: Bounds) => void;\n\n    /**\n     * @param options - The options for the container.\n     */\n    constructor(options: RenderContainerOptions | RenderFunction)\n    {\n        if (typeof options === 'function')\n        {\n            options = { render: options };\n        }\n\n        const { render, ...rest } = options;\n\n        super({\n            label: 'RenderContainer',\n            ...rest,\n        });\n\n        if (render) this.render = render;\n\n        this.containsPoint = options.containsPoint ?? (() => false);\n        this.addBounds = options.addBounds ?? (() => false);\n    }\n\n    /** @private */\n    protected updateBounds(): void\n    {\n        // NOTE: this is for backwards compatibility with the old bounds system\n        this._bounds.clear();\n        this.addBounds(this._bounds);\n    }\n\n    /**\n     * An overridable function that can be used to render the object using the current renderer.\n     * @param _renderer - The current renderer\n     */\n    public render(_renderer: Renderer): void\n    {\n        // override me!\n    }\n}\n", "export function mixHexColors(color1: number, color2: number, ratio: number): number\n{\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = r1 + ((r2 - r1) * ratio);\n    const g = g1 + ((g2 - g1) * ratio);\n    const b = b1 + ((b2 - b1) * ratio);\n\n    return (r << 16) + (g << 8) + b;\n}\n\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Container } from '../Container';\n\nexport function updateLocalTransform(lt: Matrix, container: Container): void\n{\n    const scale = container._scale;\n    const pivot = container._pivot;\n    const position = container._position;\n\n    const sx = scale._x;\n    const sy = scale._y;\n\n    const px = pivot._x;\n    const py = pivot._y;\n\n    // get the matrix values of the container based on its this properties..\n    lt.a = container._cx * sx;\n    lt.b = container._sx * sx;\n    lt.c = container._cy * sy;\n    lt.d = container._sy * sy;\n\n    lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n    lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n}\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\n\nexport function updateWorldTransform(local: Matrix, parent: Matrix, world: Matrix): void\n{\n    const lta = local.a;\n    const ltb = local.b;\n    const ltc = local.c;\n    const ltd = local.d;\n    const lttx = local.tx;\n    const ltty = local.ty;\n\n    const pta = parent.a;\n    const ptb = parent.b;\n    const ptc = parent.c;\n    const ptd = parent.d;\n\n    world.a = (lta * pta) + (ltb * ptc);\n    world.b = (lta * ptb) + (ltb * ptd);\n    world.c = (ltc * pta) + (ltd * ptc);\n    world.d = (ltc * ptb) + (ltd * ptd);\n    world.tx = (lttx * pta) + (ltty * ptc) + parent.tx;\n    world.ty = (lttx * ptb) + (ltty * ptd) + parent.ty;\n}\n", "import { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { MeshGeometry } from '../../../mesh/shared/MeshGeometry';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nexport interface GeometryPathOptions\n{\n    /** the path to build the geometry from */\n    path: GraphicsPath\n    /** a `Matrix` that can be used to modify the the texture UVs of the the path being built */\n    textureMatrix?: Matrix\n    /** an optional `MeshGeometry` to write too instead of creating a new one*/\n    out?: MeshGeometry\n}\n\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * to define the geometry in a more human readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path);\n *\n * const mesh = new Mesh({geometry});\n *\n * ```\n * You can also pass in a Matrix to transform the uvs as by default you may want to control how they are set up.\n * @param options - either a `GraphicsPath` or `GeometryPathOptions`\n * @returns a new `MeshGeometry` instance build from the path\n */\nexport function buildGeometryFromPath(options: GraphicsPath | GeometryPathOptions): MeshGeometry\n{\n    if (options instanceof GraphicsPath)\n    {\n        options = {\n            path: options,\n            textureMatrix: null,\n            out: null,\n        };\n    }\n\n    const vertices: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    // build path collection of polygons and shapes points..\n    const shapePath = options.path.shapePath;\n    const textureMatrix = options.textureMatrix;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n        const uvsOffset = uvs.length / 2;\n\n        if (textureMatrix)\n        {\n            // todo can prolly do this before calculating uvs..\n            if (matrix)\n            {\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n    });\n\n    const out = options.out;\n\n    if (out)\n    {\n        out.positions = new Float32Array(vertices);\n        out.uvs = new Float32Array(uvs);\n        out.indices = new Uint32Array(indices);\n\n        return out;\n    }\n\n    const geometry = new MeshGeometry({\n        positions: new Float32Array(vertices),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n    });\n\n    return geometry;\n}\n", "import type { ArrayFixed } from '../../../utils/types';\nimport type { PlaneGeometry } from '../../mesh-plane/PlaneGeometry';\n\n/**\n * Apply a projective transformation to a plane geometry\n * @param width - The width of the plane\n * @param height - The height of the plane\n * @param geometry - The plane geometry to apply the transformation to\n * @param transformationMatrix - The transformation matrix to apply\n */\nexport function applyProjectiveTransformationToPlane(\n    width: number,\n    height: number,\n    geometry: PlaneGeometry,\n    transformationMatrix: ArrayFixed<number, 9>\n)\n{\n    const buffer = geometry.buffers[0];\n\n    // Access the vertices of the mesh\n    const vertices = buffer.data;\n\n    const { verticesX, verticesY } = geometry;\n\n    const sizeX = (width) / (verticesX - 1);\n    const sizeY = (height) / (verticesY - 1);\n\n    let index = 0;\n\n    const a00 = transformationMatrix[0];\n    const a01 = transformationMatrix[1];\n    const a02 = transformationMatrix[2];\n    const a10 = transformationMatrix[3];\n    const a11 = transformationMatrix[4];\n    const a12 = transformationMatrix[5];\n    const a20 = transformationMatrix[6];\n    const a21 = transformationMatrix[7];\n    const a22 = transformationMatrix[8];\n\n    // Apply the transformation to each vertex\n    for (let i = 0; i < vertices.length; i += 2)\n    {\n        const x = (index % verticesX) * sizeX;\n        const y = ((index / verticesX) | 0) * sizeY;\n\n        const newX = (a00 * x) + (a01 * y) + a02;\n        const newY = (a10 * x) + (a11 * y) + a12;\n        const w = (a20 * x) + (a21 * y) + a22;\n\n        vertices[i] = newX / w;\n        vertices[i + 1] = newY / w;\n\n        index++;\n    }\n\n    // Update the mesh geometry to reflect the changes\n    buffer.update();\n}\n", "import type { ArrayFixed } from '../../../utils/types';\n\ntype Matrix3x3 = ArrayFixed<number, 9>;\ntype Vector3 = ArrayFixed<number, 3>;\n\nfunction computeAdjugate(out: Matrix3x3, matrix: Matrix3x3): Matrix3x3\n{\n    const a00 = matrix[0];\n    const a01 = matrix[1];\n    const a02 = matrix[2];\n    const a10 = matrix[3];\n    const a11 = matrix[4];\n    const a12 = matrix[5];\n    const a20 = matrix[6];\n    const a21 = matrix[7];\n    const a22 = matrix[8];\n\n    out[0] = (a11 * a22) - (a12 * a21);\n    out[1] = (a02 * a21) - (a01 * a22);\n    out[2] = (a01 * a12) - (a02 * a11);\n    out[3] = (a12 * a20) - (a10 * a22);\n    out[4] = (a00 * a22) - (a02 * a20);\n    out[5] = (a02 * a10) - (a00 * a12);\n    out[6] = (a10 * a21) - (a11 * a20);\n    out[7] = (a01 * a20) - (a00 * a21);\n    out[8] = (a00 * a11) - (a01 * a10);\n\n    return out;\n}\n\nfunction multiplyMatrix3x3(out: Matrix3x3, a: Matrix3x3, b: Matrix3x3)\n{\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[3];\n    const a11 = a[4];\n    const a12 = a[5];\n    const a20 = a[6];\n    const a21 = a[7];\n    const a22 = a[8];\n\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[3];\n    const b11 = b[4];\n    const b12 = b[5];\n    const b20 = b[6];\n    const b21 = b[7];\n    const b22 = b[8];\n\n    out[0] = (b00 * a00) + (b01 * a10) + (b02 * a20);\n    out[1] = (b00 * a01) + (b01 * a11) + (b02 * a21);\n    out[2] = (b00 * a02) + (b01 * a12) + (b02 * a22);\n\n    out[3] = (b10 * a00) + (b11 * a10) + (b12 * a20);\n    out[4] = (b10 * a01) + (b11 * a11) + (b12 * a21);\n    out[5] = (b10 * a02) + (b11 * a12) + (b12 * a22);\n\n    out[6] = (b20 * a00) + (b21 * a10) + (b22 * a20);\n    out[7] = (b20 * a01) + (b21 * a11) + (b22 * a21);\n    out[8] = (b20 * a02) + (b21 * a12) + (b22 * a22);\n\n    return out;\n}\n\nfunction multiplyMatrixAndVector(out: Vector3, m: Matrix3x3, v: Vector3): Vector3\n{\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n\n    out[0] = (m[0] * x) + (m[1] * y) + (m[2] * z);\n    out[1] = (m[3] * x) + (m[4] * y) + (m[5] * z);\n    out[2] = (m[6] * x) + (m[7] * y) + (m[8] * z);\n\n    return out;\n}\n\n//\nconst tempMatrix: Matrix3x3 = [0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst tempVec: Vector3 = [0, 0, 0];\nconst tempVec2: Vector3 = [0, 0, 0];\n\nfunction generateBasisToPointsMatrix(\n    out: Matrix3x3,\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number\n): Matrix3x3\n{\n    const m: Matrix3x3 = tempMatrix;\n\n    m[0] = x1;\n    m[1] = x2;\n    m[2] = x3;\n    m[3] = y1;\n    m[4] = y2;\n    m[5] = y3;\n    m[6] = 1;\n    m[7] = 1;\n    m[8] = 1;\n\n    const adjugateM: Matrix3x3 = computeAdjugate(\n        out, // reusing out as adjugateM is only used once\n        m\n    );\n\n    tempVec2[0] = x4;\n    tempVec2[1] = y4;\n    tempVec2[2] = 1;\n\n    const v: Vector3 = multiplyMatrixAndVector(\n        tempVec,\n        adjugateM,\n        tempVec2,\n    );\n\n    const diagonalMatrix = out; // we can reuse the out matrix as the diagonal matrix is only used once\n\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = v[1];\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = v[2];\n\n    return multiplyMatrix3x3(out, diagonalMatrix, m);\n}\n\nconst tempSourceMatrix: Matrix3x3 = [0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst tempDestinationMatrix: Matrix3x3 = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n/**\n * Compute a 2D projection matrix\n * @param out - The matrix to store the result in\n * @param x1s - The x coordinate of the first source point\n * @param y1s - The y coordinate of the first source point\n * @param x1d - The x coordinate of the first destination point\n * @param y1d - The y coordinate of the first destination point\n * @param x2s - The x coordinate of the second source point\n * @param y2s - The y coordinate of the second source point\n * @param x2d - The x coordinate of the second destination point\n * @param y2d - The y coordinate of the second destination point\n * @param x3s - The x coordinate of the third source point\n * @param y3s - The y coordinate of the third source point\n * @param x3d - The x coordinate of the third destination point\n * @param y3d - The y coordinate of the third destination point\n * @param x4s - The x coordinate of the fourth source point\n * @param y4s - The y coordinate of the fourth source point\n * @param x4d - The x coordinate of the fourth destination point\n * @param y4d - The y coordinate of the fourth destination point\n * @returns - The computed 2D projection matrix\n * @private\n */\n// eslint-disable-next-line max-params\nexport function compute2DProjection(\n    out: Matrix3x3,\n    x1s: number, y1s: number, x1d: number, y1d: number,\n    x2s: number, y2s: number, x2d: number, y2d: number,\n    x3s: number, y3s: number, x3d: number, y3d: number,\n    x4s: number, y4s: number, x4d: number, y4d: number\n): Matrix3x3\n{\n    const sourceMatrix = generateBasisToPointsMatrix(\n        tempSourceMatrix,\n        x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s\n    );\n\n    const destinationMatrix = generateBasisToPointsMatrix(\n        tempDestinationMatrix,\n        x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d\n    );\n\n    return multiplyMatrix3x3(\n        out,\n        computeAdjugate(sourceMatrix, sourceMatrix),\n        destinationMatrix\n    );\n}\n", "import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\nimport { applyProjectiveTransformationToPlane } from './utils/applyProjectiveTransformationToPlane';\nimport { compute2DProjection } from './utils/compute2DProjections';\n\nimport type { ArrayFixed } from '../../utils/types';\nimport type { PlaneGeometryOptions } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Constructor options used for `PerspectivePlaneGeometry` instances.\n * @memberof scene\n */\nexport interface PerspectivePlaneGeometryOptions extends PlaneGeometryOptions\n{\n    /** The width of the plane */\n    width: number;\n    /** The height of the plane */\n    height: number;\n}\n\n/**\n * A PerspectivePlaneGeometry allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * IMPORTANT: This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it :)\n *\n * ```js\n * const perspectivePlaneGeometry = new PerspectivePlaneGeometry({\n *  width: 100,\n *  height: 100,\n *  verticesX: 10,\n *  verticesY: 10,\n * });\n * ```\n * @see {@link scene.PerspectivePlaneGeometry}\n * @memberof scene\n */\nexport class PerspectivePlaneGeometry extends PlaneGeometry\n{\n    /** The corner points of the quad you can modify these directly, if you do make sure to call `updateProjection` */\n    public corners: [number, number, number, number, number, number, number, number];\n    private readonly _projectionMatrix: ArrayFixed<number, 9> = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    /**\n     * @param options - Options to be applied to MeshPlane\n     * @param options.width - The width of the plane\n     * @param options.height - The height of the plane\n     * @param options.verticesX - The amount of vertices on the x axis\n     * @param options.verticesY - The amount of vertices on the y axis\n     */\n    constructor(options: PerspectivePlaneGeometryOptions)\n    {\n        super(options);\n\n        const { width, height } = options;\n\n        this.corners = [0, 0, width, 0, width, height, 0, height];\n    }\n\n    /**\n     * Will set the corners of the quad to the given coordinates\n     * Calculating the perspective so it looks correct!\n     * @param x0 - x coordinate of the first corner\n     * @param y0 - y coordinate of the first corner\n     * @param x1 - x coordinate of the second corner\n     * @param y1 - y coordinate of the second corner\n     * @param x2 - x coordinate of the third corner\n     * @param y2 - y coordinate of the third corner\n     * @param x3 - x coordinate of the fourth corner\n     * @param y3 - y coordinate of the fourth corner\n     */\n    public setCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number)\n    {\n        const corners = this.corners;\n\n        corners[0] = x0;\n        corners[1] = y0;\n        corners[2] = x1;\n        corners[3] = y1;\n        corners[4] = x2;\n        corners[5] = y2;\n        corners[6] = x3;\n        corners[7] = y3;\n\n        this.updateProjection();\n    }\n\n    /** Update the projection matrix based on the corners */\n    public updateProjection()\n    {\n        const { width, height } = this;\n        const corners = this.corners;\n\n        const projectionMatrix = compute2DProjection(\n            this._projectionMatrix,\n            0, 0, // top-left source\n            corners[0], corners[1], // top-left dest\n            width, 0, // top-right source\n            corners[2], corners[3], // top-right dest\n            width, height, // bottom-right source\n            corners[4], corners[5], // bottom-right dest\n            0, height, // bottom-left source\n            corners[6], corners[7] // bottom-left dest\n        );\n\n        applyProjectiveTransformationToPlane(\n            width,\n            height,\n            this,\n            projectionMatrix\n        );\n    }\n}\n\n", "import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { definedProps } from '../container/utils/definedProps';\nimport { Mesh } from '../mesh/shared/Mesh';\nimport { PerspectivePlaneGeometry } from './PerspectivePlaneGeometry';\n\nimport type { MeshPlaneOptions } from '../mesh-plane/MeshPlane';\n/**\n *\n * Constructor options used for `PerspectiveMesh` instances.\n * ```js\n * const meshPlane = new PerspectiveMesh({\n *  texture: Texture.from('snake.png'),\n *  verticesX: 20,\n *  verticesY: 20,\n *  x0: 0,\n *  y0: 0,\n *  x1: 100,\n *  y1: 0,\n *  x2: 100,\n *  y2: 100,\n *  x3: 0,\n *  y3: 100\n * });\n * @see {@link scene.PerspectiveMesh}\n * @memberof scene\n */\nexport interface PerspectivePlaneOptions extends MeshPlaneOptions\n{\n    /** top left corner x value */\n    x0?: number,\n    /** top left corner y value */\n    y0?: number,\n    /** top right corner x value */\n    x1?: number,\n    /** top right corner y value */\n    y1?: number,\n    /** bottom right corner x value */\n    x2?: number,\n    /** bottom right corner y value */\n    y2?: number,\n    /** bottom left corner x value */\n    x3?: number,\n    /** bottom left corner y value */\n    y3?: number\n}\n\n/**\n * A perspective mesh that allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * The calculations is done at the uv level. This means that the more vertices you have the more smooth\n * the perspective will be. If you have a low amount of vertices you may see the texture stretch. Too many vertices\n * could be slower. It is a balance between performance and quality! We leave that to you to decide.\n *\n * IMPORTANT: This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it :)\n * @example\n * ```js\n * const meshPlane = new PerspectiveMesh({\n *  texture: Texture.from('snake.png'),\n *  verticesX: 20,\n *  verticesY: 20,\n *  x0: 0,\n *  y0: 0,\n *  x1: 100,\n *  y1: 0,\n *  x2: 100,\n *  y2: 100,\n *  x3: 0,\n *  y3: 100\n * });\n * @see {@link scene.PerspectiveMesh}\n * @memberof scene\n */\nexport class PerspectiveMesh extends Mesh<PerspectivePlaneGeometry>\n{\n    /** default options for the mesh */\n    public static defaultOptions: PerspectivePlaneOptions = {\n        texture: Texture.WHITE,\n        verticesX: 10,\n        verticesY: 10,\n        x0: 0,\n        y0: 0,\n        x1: 100,\n        y1: 0,\n        x2: 100,\n        y2: 100,\n        x3: 0,\n        y3: 100\n    };\n\n    /**\n     * @param options - Options to be applied to PerspectiveMesh\n     */\n    constructor(options: PerspectivePlaneOptions)\n    {\n        options = { ...PerspectiveMesh.defaultOptions, ...options };\n\n        const { texture, verticesX, verticesY, ...rest } = options;\n        const planeGeometry = new PerspectivePlaneGeometry(definedProps({\n            width: texture.width,\n            height: texture.height,\n            verticesX,\n            verticesY,\n        }));\n\n        super(definedProps({ ...rest, geometry: planeGeometry }));\n\n        this._texture = texture;\n\n        this.geometry.setCorners(\n            options.x0, options.y0,\n            options.x1, options.y1,\n            options.x2, options.y2,\n            options.x3, options.y3\n        );\n    }\n\n    /** Update the geometry when the texture is updated */\n    protected textureUpdated(): void\n    {\n        const geometry: PerspectivePlaneGeometry = this.geometry as any;\n\n        if (!geometry) return;\n\n        const { width, height } = this.texture;\n\n        if (geometry.width !== width || geometry.height !== height)\n        {\n            geometry.width = width;\n            geometry.height = height;\n            geometry.updateProjection();\n        }\n    }\n\n    set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        super.texture = value;\n\n        this.textureUpdated();\n    }\n\n    /** The texture that the mesh uses */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    /**\n     * Set the corners of the quad to the given coordinates\n     * The mesh will then calculate the perspective so it looks correct!\n     * @param x0 - x coordinate of the first corner\n     * @param y0 - y coordinate of the first corner\n     * @param x1 - x coordinate of the second corner\n     * @param y1 - y coordinate of the second corner\n     * @param x2 - x coordinate of the third corner\n     * @param y2 - y coordinate of the third corner\n     * @param x3 - x coordinate of the fourth corner\n     * @param y3 - y coordinate of the fourth corner\n     */\n    public setCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number)\n    {\n        this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);\n    }\n}\n", "import { definedProps } from '../container/utils/definedProps';\nimport { Mesh } from '../mesh/shared/Mesh';\nimport { PlaneGeometry } from './PlaneGeometry';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { MeshOptions } from '../mesh/shared/Mesh';\n\n/**\n * Constructor options used for `MeshPlane` instances.\n * ```js\n * const meshPlane = new MeshPlane({\n *    texture: Texture.from('snake.png'),\n *    verticesX: 20,\n *    verticesY: 20,\n * });\n * ```\n * @see {@link scene.MeshPlane}\n * @memberof scene\n */\nexport interface MeshPlaneOptions extends Omit<MeshOptions, 'geometry'>\n{\n    /** The texture to use on the plane. */\n    texture: Texture;\n    /** The number of vertices in the x-axis */\n    verticesX?: number;\n    /** The number of vertices in the y-axis */\n    verticesY?: number;\n}\n\n/**\n * The MeshPlane allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, MeshPlane, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * }\n * const MeshPlane = new MeshPlane({ texture: Texture.from('snake.png'), verticesX: points });\n * @memberof scene\n */\nexport class MeshPlane extends Mesh\n{\n    /** The geometry is automatically updated when the texture size changes. */\n    public autoResize: boolean;\n    protected _textureID: number;\n\n    /**\n     * @param options - Options to be applied to MeshPlane\n     */\n    constructor(options: MeshPlaneOptions)\n    {\n        const { texture, verticesX, verticesY, ...rest } = options;\n        const planeGeometry = new PlaneGeometry(definedProps({\n            width: texture.width,\n            height: texture.height,\n            verticesX,\n            verticesY,\n        }));\n\n        super(definedProps({ ...rest, geometry: planeGeometry, texture }));\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n        this.autoResize = true;\n    }\n\n    /**\n     * Method used for overrides, to do something in case texture frame was changed.\n     * Meshes based on plane can override it and change more details based on texture.\n     */\n    public textureUpdated(): void\n    {\n        const geometry: PlaneGeometry = this.geometry as any;\n        const { width, height } = this.texture;\n\n        if (this.autoResize && (geometry.width !== width || geometry.height !== height))\n        {\n            geometry.width = width;\n            geometry.height = height;\n            geometry.build({});\n        }\n    }\n\n    set texture(value: Texture)\n    {\n        this._texture?.off('update', this.textureUpdated, this);\n\n        super.texture = value;\n\n        value.on('update', this.textureUpdated, this);\n\n        this.textureUpdated();\n    }\n\n    /** The texture of the MeshPlane */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        this.texture.off('update', this.textureUpdated, this);\n        super.destroy(options);\n    }\n}\n", "import { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `RopeGeometry` instances.\n * ```js\n * const ropeGeometry = new RopeGeometry({\n *    points: [new Point(0, 0), new Point(100, 0)],\n *    width: 10,\n *    textureScale: 0,\n * });\n * ```\n * @see {@link scene.RopeGeometry}\n * @memberof scene\n */\nexport interface RopeGeometryOptions\n{\n    /** The width (i.e., thickness) of the rope. */\n    width?: number;\n    /** An array of points that determine the rope. */\n    points?: PointData[];\n    /**\n     * Rope texture scale, if zero then the rope texture is stretched.\n     * By default the rope texture will be stretched to match\n     * rope length. If textureScale is positive this value will be treated as a scaling\n     * factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n     * set baseTexture.wrapMode to 'repeat' and use a power of two texture,\n     * then set textureScale=1 to keep the original texture pixel size.\n     * In order to reduce alpha channel artifacts provide a larger texture and downsample -\n     * i.e. set textureScale=0.5 to scale it down twice.\n     */\n    textureScale?: number;\n}\n\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n * @example\n * import { Point, RopeGeometry } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new RopeGeometry(100, points);\n * @memberof scene\n */\nexport class RopeGeometry extends MeshGeometry\n{\n    /** Default options for RopeGeometry constructor. */\n    public static defaultOptions: RopeGeometryOptions & MeshGeometryOptions = {\n        /** The width (i.e., thickness) of the rope. */\n        width: 200,\n        /** An array of points that determine the rope. */\n        points: [],\n        /** Rope texture scale, if zero then the rope texture is stretched. */\n        textureScale: 0,\n    };\n\n    /** An array of points that determine the rope. */\n    public points: PointData[];\n\n    /** Rope texture scale, if zero then the rope texture is stretched. */\n    public readonly textureScale: number;\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    public _width: number;\n\n    /**\n     * @param options - Options to be applied to rope geometry\n     */\n    constructor(options: RopeGeometryOptions)\n    {\n        const { width, points, textureScale } = { ...RopeGeometry.defaultOptions, ...options };\n\n        super({\n            positions: new Float32Array(points.length * 4),\n            uvs: new Float32Array(points.length * 4),\n            indices: new Uint32Array((points.length - 1) * 6),\n        });\n\n        this.points = points;\n        this._width = width;\n        this.textureScale = textureScale;\n\n        this._build();\n    }\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    /** Refreshes Rope indices and uvs */\n    private _build(): void\n    {\n        const points = this.points;\n\n        if (!points) return;\n\n        const vertexBuffer = this.getBuffer('aPosition');\n        const uvBuffer = this.getBuffer('aUV');\n        const indexBuffer = this.getIndex();\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (vertexBuffer.data.length / 4 !== points.length)\n        {\n            vertexBuffer.data = new Float32Array(points.length * 4);\n            uvBuffer.data = new Float32Array(points.length * 4);\n            indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n        }\n\n        const uvs = uvBuffer.data;\n        const indices = indexBuffer.data;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        let amount = 0;\n        let prev = points[0];\n        const textureWidth = this._width * this.textureScale;\n        const total = points.length; // - 1;\n\n        for (let i = 0; i < total; i++)\n        {\n            // time to do some smart drawing!\n            const index = i * 4;\n\n            if (this.textureScale > 0)\n            {\n                // calculate pixel distance from previous point\n                const dx = prev.x - points[i].x;\n                const dy = prev.y - points[i].y;\n                const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n                prev = points[i];\n                amount += distance / textureWidth;\n            }\n            else\n            {\n                // stretch texture\n                amount = i / (total - 1);\n            }\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n        }\n\n        let indexCount = 0;\n\n        for (let i = 0; i < total - 1; i++)\n        {\n            const index = i * 2;\n\n            indices[indexCount++] = index;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 2;\n\n            indices[indexCount++] = index + 2;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 3;\n        }\n\n        // ensure that the changes are uploaded\n        uvBuffer.update();\n        indexBuffer.update();\n\n        this.updateVertices();\n    }\n\n    /** refreshes vertices of Rope mesh */\n    public updateVertices(): void\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        const vertices = this.buffers[0].data;\n        const total = points.length;\n        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n            if (perpLength < 1e-6)\n            {\n                perpX = 0;\n                perpY = 0;\n            }\n            else\n            {\n                perpX /= perpLength;\n                perpY /= perpLength;\n\n                perpX *= halfWidth;\n                perpY *= halfWidth;\n            }\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        this.buffers[0].update();\n    }\n\n    /** Refreshes Rope indices and uvs */\n    public update(): void\n    {\n        if (this.textureScale > 0)\n        {\n            this._build(); // we need to update UVs\n        }\n        else\n        {\n            this.updateVertices();\n        }\n    }\n}\n", "import { definedProps } from '../container/utils/definedProps';\nimport { Mesh } from '../mesh/shared/Mesh';\nimport { RopeGeometry } from './RopeGeometry';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { MeshOptions } from '../mesh/shared/Mesh';\n\n/**\n * Constructor options used for `MeshRope` instances.\n * ```js\n * const meshRope = new MeshRope({\n *    texture: Texture.from('snake.png'),\n *    points: [new Point(0, 0), new Point(100, 0)],\n *    textureScale: 0,\n * });\n * ```\n * @see {@link scene.MeshRope}\n * @memberof scene\n */\nexport interface MeshRopeOptions extends Omit<MeshOptions, 'geometry'>\n{\n    /** The texture to use on the rope. */\n    texture: Texture;\n    /** An array of points that determine the rope. */\n    points: PointData[];\n    /**\n     * Rope texture scale, if zero then the rope texture is stretched.\n     * Positive values scale rope texture\n     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n     * and downsampling here. If set to zero, texture will be stretched instead.\n     */\n    textureScale?: number;\n}\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, MeshRope, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new MeshRope(Texture.from('snake.png'), points);\n * @memberof scene\n */\nexport class MeshRope extends Mesh\n{\n    public static defaultOptions: Partial<MeshRopeOptions> = {\n        textureScale: 0,\n    };\n\n    /** re-calculate vertices by rope points each frame */\n    public autoUpdate: boolean;\n\n    /**\n     * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n     * @param options\n     * @param options.texture - The texture to use on the rope.\n     * @param options.points - An array of {@link math.Point} objects to construct this rope.\n     * @param {number} options.textureScale - Optional. Positive values scale rope texture\n     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n     * and downsampling here. If set to zero, texture will be stretched instead.\n     */\n    constructor(options: MeshRopeOptions)\n    {\n        const { texture, points, textureScale, ...rest } = { ...MeshRope.defaultOptions, ...options };\n        const ropeGeometry = new RopeGeometry(definedProps({ width: texture.height, points, textureScale }));\n\n        if (textureScale > 0)\n        {\n            // attempt to set UV wrapping, will fail on non-power of two textures\n            texture.source.style.addressMode = 'repeat';\n        }\n        super(definedProps({\n            ...rest,\n            texture,\n            geometry: ropeGeometry,\n        }));\n\n        this.autoUpdate = true;\n\n        this.onRender = this._render;\n    }\n\n    private _render(): void\n    {\n        const geometry: RopeGeometry = this.geometry as any;\n\n        if (this.autoUpdate || geometry._width !== this.texture.height)\n        {\n            geometry._width = this.texture.height;\n            geometry.update();\n        }\n    }\n}\n", "import { definedProps } from '../container/utils/definedProps';\nimport { Mesh } from '../mesh/shared/Mesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { TypedArray } from '../../rendering/renderers/shared/buffer/Buffer';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { MeshOptions } from '../mesh/shared/Mesh';\n\n/**\n * Options for the simple mesh.\n * @memberof scene\n */\nexport interface SimpleMeshOptions extends Omit<MeshOptions, 'geometry'>\n{\n    /** The texture to use */\n    texture: Texture,\n    /** if you want to specify the vertices */\n    vertices?: Float32Array,\n    /** if you want to specify the uvs */\n    uvs?: Float32Array,\n    /** if you want to specify the indices */\n    indices?: Uint32Array,\n    /** the topology, can be any of the Topology values */\n    topology?: Topology\n}\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link scene.Mesh}.\n * @memberof scene\n */\nexport class MeshSimple extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param options - Options to be used for construction\n     */\n    constructor(options: SimpleMeshOptions)\n    {\n        const { texture, vertices, uvs, indices, topology, ...rest } = options;\n        const geometry = new MeshGeometry(definedProps({\n            positions: vertices,\n            uvs,\n            indices,\n            topology\n        }));\n\n        // geometry.getBuffer('aPosition').static = false;\n\n        super(definedProps({\n            ...rest,\n            texture,\n            geometry,\n        }));\n\n        this.autoUpdate = true;\n        this.onRender = this._render;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): TypedArray\n    {\n        return this.geometry.getBuffer('aPosition').data;\n    }\n    set vertices(value: TypedArray)\n    {\n        this.geometry.getBuffer('aPosition').data = value;\n    }\n\n    private _render(): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aPosition').update();\n        }\n    }\n}\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nexport function getTextureDefaultMatrix(texture: Texture, out: Matrix): Matrix\n{\n    const { width, height } = texture.frame;\n\n    out.scale(1 / width, 1 / height);\n\n    return out;\n}\n", "import { Color } from '../../../color/Color';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { bgr2rgb } from '../../container/container-mixins/getGlobalMixin';\nimport { assignWithIgnore } from '../../container/utils/assignWithIgnore';\n\nimport type { ColorSource } from '../../../color/Color';\n\n/**\n * Represents a particle with properties for position, scale, rotation, color, and texture.\n * @property {number} x - The x-coordinate of the particle.\n * @property {number} y - The y-coordinate of the particle.\n * @property {number} scaleX - The scale factor in the x-axis.\n * @property {number} scaleY - The scale factor in the y-axis.\n * @property {number} anchorX - The x-coordinate of the anchor point.\n * @property {number} anchorY - The y-coordinate of the anchor point.\n * @property {number} rotation - The rotation of the particle in radians.\n * @property {number} color - The color of the particle as a hexadecimal number.\n * @property {Texture} texture - The texture of the particle.\n * @memberof scene\n */\nexport interface IParticle\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    anchorX: number;\n    anchorY: number;\n    rotation: number;\n    color: number;\n    texture: Texture;\n}\n\n/**\n * Represents the options for creating a new particle.\n * @property {number} x - The x-coordinate of the particle.\n * @property {number} y - The y-coordinate of the particle.\n * @property {number} scaleX - The scale factor in the x-axis.\n * @property {number} scaleY - The scale factor in the y-axis.\n * @property {number} anchorX - The x-coordinate of the anchor point.\n * @property {number} anchorY - The y-coordinate of the anchor point.\n * @property {number} rotation - The rotation of the particle in radians.\n * @property {Texture} texture - The texture of the particle.\n * @property {ColorSource} tint - The tint color of the particle as a hexadecimal number.\n * @property {number} alpha - The alpha value of the particle.\n * @memberof scene\n */\nexport type ParticleOptions = Omit<Partial<IParticle>, 'color'> & {\n    texture: Texture\n    tint?: ColorSource;\n    alpha?: number;\n};\n\n/**\n * Represents a single particle within a particle container. This class implements the IParticle interface,\n * providing properties and methods to manage the particle's position, scale, rotation, color, and texture.\n *\n * The reason we use a particle over a sprite is that these are much lighter weight and we can create a lot of them\n * without taking on the overhead of a full sprite.\n *\n * Here is an example of how to create a new particle:\n *\n * ```javascript\n * const particle = new Particle({\n *   texture,\n *   x: 100,\n *   y: 100,\n *   scaleX: 0.5,\n *   scaleY: 0.5,\n *   rotation: Math.PI / 2,\n *   color: 0xff0000,\n * });\n * ```\n * @implements {IParticle}\n * @memberof scene\n */\nexport class Particle implements IParticle\n{\n    /** Default options for constructing with options */\n    public static defaultOptions: Partial<ParticleOptions> = {\n        anchorX: 0,\n        anchorY: 0,\n        x: 0,\n        y: 0,\n        scaleX: 1,\n        scaleY: 1,\n        rotation: 0,\n        tint: 0xffffff,\n        alpha: 1,\n    };\n    /** The x-coordinate of the anchor point. */\n    public anchorX: number;\n    /** The y-coordinate of the anchor point. */\n    public anchorY: number;\n    /** The x-coordinate of the particle. */\n    public x: number;\n    /** The y-coordinate of the particle. */\n    public y: number;\n    /** The scale factor in the x-axis. */\n    public scaleX: number;\n    /** The scale factor in the y-axis. */\n    public scaleY: number;\n    /** The rotation of the particle in radians. */\n    public rotation: number;\n    /** The color of the particle as a hexadecimal number. */\n    public color: number;\n    /** The texture of the particle. */\n    public texture: Texture;\n\n    private _alpha: number;\n    private _tint: number;\n\n    constructor(options: Texture | ParticleOptions)\n    {\n        if (options instanceof Texture)\n        {\n            this.texture = options;\n            assignWithIgnore(this, Particle.defaultOptions, {});\n        }\n        else\n        {\n            const combined = { ...Particle.defaultOptions, ...options };\n\n            assignWithIgnore(this, combined, {});\n        }\n    }\n\n    /** Gets or sets the alpha value of the particle. */\n    get alpha(): number\n    {\n        return this._alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._alpha = Math.min(Math.max(value, 0), 1);\n\n        this._updateColor();\n    }\n\n    /** Gets or sets the tint color of the particle. */\n    get tint(): number\n    {\n        return bgr2rgb(this._tint);\n    }\n\n    set tint(value: ColorSource)\n    {\n        if (typeof value === 'number')\n        {\n            this._tint = value;\n        }\n        else\n        {\n            this._tint = Color.shared.setValue(value ?? 0xFFFFFF).toBgrNumber();\n        }\n\n        this._updateColor();\n    }\n\n    private _updateColor()\n    {\n        // combine alpha and tint\n        this.color = this._tint + (((this._alpha * 255) | 0) << 24);\n    }\n}\n", "import type { VertexFormat } from '../../../rendering/renderers/shared/geometry/const';\nimport type { IParticle } from './Particle';\n\nexport interface ParticleRendererProperty\n{\n    attributeName: string;\n    format: VertexFormat;\n    code: string;\n    dynamic: boolean;\n    // optional update function if you have customized this stuff and need it to work with unsafe-eval\n    updateFunction?: (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array, offset: number, stride: number) => void;\n}\n\nexport const particleData = {\n    vertex: {\n        attributeName: 'aVertex',\n        format: 'float32x2',\n        code: `\n            const texture = p.texture;\n            const sx = p.scaleX;\n            const sy = p.scaleY;\n            const ax = p.anchorX;\n            const ay = p.anchorY;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                w1 = trim.x - (ax * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (ay * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w1 = -ax * (orig.width);\n                w0 = w1 + orig.width;\n\n                h1 = -ay * (orig.height);\n                h0 = h1 + orig.height;\n            }\n\n            f32v[offset] = w1 * sx;\n            f32v[offset + 1] = h1 * sy;\n\n            f32v[offset + stride] = w0 * sx;\n            f32v[offset + stride + 1] = h1 * sy;\n\n            f32v[offset + (stride * 2)] = w0 * sx;\n            f32v[offset + (stride * 2) + 1] = h0 * sy;\n\n            f32v[offset + (stride * 3)] = w1 * sx;\n            f32v[offset + (stride * 3) + 1] = h0 * sy;\n        `,\n        dynamic: false,\n    },\n    // positionData\n    position: {\n        attributeName: 'aPosition',\n        format: 'float32x2',\n        code: `\n            var x = p.x;\n            var y = p.y;\n\n            f32v[offset] = x;\n            f32v[offset + 1] = y;\n\n            f32v[offset + stride] = x;\n            f32v[offset + stride + 1] = y;\n\n            f32v[offset + (stride * 2)] = x;\n            f32v[offset + (stride * 2) + 1] = y;\n\n            f32v[offset + (stride * 3)] = x;\n            f32v[offset + (stride * 3) + 1] = y;\n        `,\n        dynamic: true,\n    },\n    // rotationData\n    rotation: {\n        attributeName: 'aRotation',\n        format: 'float32',\n        code: `\n            var rotation = p.rotation;\n\n            f32v[offset] = rotation;\n            f32v[offset + stride] = rotation;\n            f32v[offset + (stride * 2)] = rotation;\n            f32v[offset + (stride * 3)] = rotation;\n        `,\n        dynamic: false,\n    },\n    // uvsData\n    uvs: {\n        attributeName: 'aUV',\n        format: 'float32x2',\n        code: `\n            var uvs = p.texture.uvs;\n\n            f32v[offset] = uvs.x0;\n            f32v[offset + 1] = uvs.y0;\n\n            f32v[offset + stride] = uvs.x1;\n            f32v[offset + stride + 1] = uvs.y1;\n\n            f32v[offset + (stride * 2)] = uvs.x2;\n            f32v[offset + (stride * 2) + 1] = uvs.y2;\n\n            f32v[offset + (stride * 3)] = uvs.x3;\n            f32v[offset + (stride * 3) + 1] = uvs.y3;\n        `,\n        dynamic: false,\n    },\n    // tintData\n    color: {\n        attributeName: 'aColor',\n        format: 'unorm8x4',\n        code: `\n            const c = p.color;\n\n            u32v[offset] = c;\n            u32v[offset + stride] = c;\n            u32v[offset + (stride * 2)] = c;\n            u32v[offset + (stride * 3)] = c;\n        `,\n        dynamic: false,\n    },\n} as Record<string, ParticleRendererProperty>;\n", "import { Bounds } from '../../container/bounds/Bounds';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { particleData } from './particleData';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ContainerChild, ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\n\nconst emptyBounds = new Bounds(0, 0, 0, 0);\n\n/**\n * Represents the properties of a particle that can be dynamically updated.\n * @property {boolean} [vertices] - Indicates if vertices are dynamic.\n * @property {boolean} [position] - Indicates if position is dynamic.\n * @property {boolean} [rotation] - Indicates if rotation is dynamic.\n * @property {boolean} [uvs] - Indicates if UVs are dynamic.\n * @property {boolean} [color] - Indicates if color is dynamic.\n * @memberof scene\n */\nexport interface ParticleProperties\n{\n    vertex?: boolean;\n    position?: boolean;\n    rotation?: boolean;\n    uvs?: boolean;\n    color?: boolean;\n}\n\n/**\n * Options for the ParticleContainer constructor.\n * @extends ContainerOptions\n * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n * @property {Shader} shader - The shader to use for rendering.\n * @property {boolean} roundPixels - Indicates if pixels should be rounded.\n * @property {Texture} texture - The texture to use for rendering - if not provided the texture of the first child is used.\n * @property {IParticle[]} particles - An array of particles to add to the container.\n * @memberof scene\n */\nexport interface ParticleContainerOptions extends Omit<ContainerOptions, 'children'>\n{\n    dynamicProperties?: Record<string, boolean>;\n    shader?: Shader;\n    roundPixels?: boolean;\n    texture?: Texture;\n    particles?: IParticle[];\n}\n\n/**\n * The ParticleContainer class is a highly optimized container that can render 1000s or particles at great speed.\n *\n * A ParticleContainer is specialized in that it can only contain and render particles. Particles are\n * lightweight objects that use minimal memory, which helps boost performance.\n *\n * It can render particles EXTREMELY fast!\n *\n * The tradeoff of using a ParticleContainer is that most advanced functionality is unavailable. Particles are simple\n * and cannot have children, filters, masks, etc. They possess only the basic properties: position, scale, rotation,\n * and color.\n *\n * All particles must share the same texture source (using something like a sprite sheet works well here).\n *\n * When creating a ParticleContainer, a developer can specify which of these properties are static and which are dynamic.\n * - Static properties are only updated when you add or remove a child, or when the `update` function is called.\n * - Dynamic properties are updated every frame.\n *\n * It is up to the developer to specify which properties are static and which are dynamic. Generally, the more static\n * properties you have (i.e., those that do not change per frame), the faster the rendering.\n *\n * If the developer modifies the children order or any static properties of the particle, they must call the `update` method.\n *\n * By default, only the `position` property is set to dynamic, which makes rendering very fast!\n *\n * Developers can also provide a custom shader to the particle container, allowing them to render particles in a custom way.\n *\n * To help with performance, the particle containers bounds are not calculated.\n * It's up to the developer to set the boundsArea property.\n *\n * It's extremely easy to use. Below is an example of rendering thousands of sprites at lightning speed.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * import { ParticleContainer, Particle } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let particle = new Particle(texture);\n *     container.addParticle(particle);\n * }\n * @memberof scene\n */\nexport class ParticleContainer extends ViewContainer implements Instruction\n{\n    /**\n     * Defines the default options for creating a ParticleContainer.\n     * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n     * @property {boolean} roundPixels - Indicates if pixels should be  rounded.\n     */\n    public static defaultOptions: ParticleContainerOptions = {\n        dynamicProperties: {\n            vertex: false, // Indicates if vertex positions are dynamic.\n            position: true, // Indicates if particle positions are dynamic.\n            rotation: false, // Indicates if particle rotations are dynamic.\n            uvs: false, // Indicates if UV coordinates are dynamic.\n            color: false, // Indicates if particle colors are dynamic.\n        },\n        roundPixels: false, // Indicates if pixels should be rounded for rendering.\n    };\n\n    /** The unique identifier for the render pipe of this ParticleContainer. */\n    public override readonly renderPipeId: string = 'particle';\n\n    public batched = false;\n\n    /**\n     * A record of properties and their corresponding ParticleRendererProperty.\n     * @internal\n     */\n    public _properties: Record<string, ParticleRendererProperty>;\n\n    /** Indicates if the children of this ParticleContainer have changed and need to be updated. */\n    public _childrenDirty = false;\n\n    /**\n     * An array of particles that are children of this ParticleContainer.\n     * it can be modified directly, after which the 'update' method must be called.\n     * to ensure the container is rendered correctly.\n     */\n    public particleChildren: IParticle[];\n\n    /** The shader used for rendering particles in this ParticleContainer. */\n    public shader: Shader;\n\n    /**\n     * The texture used for rendering particles in this ParticleContainer.\n     * Defaults to the first childs texture if not set\n     */\n    public texture: Texture;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: ParticleContainerOptions = {})\n    {\n        options = {\n            ...ParticleContainer.defaultOptions,\n            ...options,\n            dynamicProperties: {\n                ...ParticleContainer.defaultOptions.dynamicProperties,\n                ...options?.dynamicProperties,\n            },\n        };\n\n        // split out\n        const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;\n\n        super({\n            label: 'ParticleContainer',\n            ...rest,\n        });\n\n        this.texture = texture || null;\n        this.shader = shader;\n\n        this._properties = {};\n\n        for (const key in particleData)\n        {\n            const property = particleData[key];\n            const dynamic = dynamicProperties[key];\n\n            this._properties[key] = {\n                ...property,\n                dynamic,\n            };\n        }\n\n        this.allowChildren = true;\n        this.roundPixels = roundPixels ?? false;\n\n        this.particleChildren = particles ?? [];\n    }\n\n    /**\n     * Adds one or more particles to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`\n     * @param {...IParticle} children - The Particle(s) to add to the container\n     * @returns {IParticle} - The first child that was added.\n     */\n    public addParticle(...children: IParticle[]): IParticle\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.particleChildren.push(children[i]);\n        }\n\n        this.onViewUpdate();\n\n        return children[0];\n    }\n\n    /**\n     * Removes one or more particles from the container.\n     * @param {...IParticle} children - The Particle(s) to remove\n     * @returns {IParticle} The first child that was removed.\n     */\n    public removeParticle(...children: IParticle[]): IParticle\n    {\n        let didRemove = false;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const index = this.particleChildren.indexOf(children[i] as IParticle);\n\n            if (index > -1)\n            {\n                this.particleChildren.splice(index, 1);\n                didRemove = true;\n            }\n        }\n\n        if (didRemove) this.onViewUpdate();\n\n        return children[0];\n    }\n\n    /**\n     * Updates the particle container.\n     * Please call this when you modify the particleChildren array.\n     * or any static properties of the particles.\n     */\n    public update()\n    {\n        this._childrenDirty = true;\n    }\n\n    protected override onViewUpdate()\n    {\n        this._childrenDirty = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * ParticleContainer does not calculated bounds as it would slow things down,\n     * its up to you to set this via the boundsArea property\n     */\n    public get bounds()\n    {\n        return emptyBounds;\n    }\n\n    /** @private */\n    protected override updateBounds(): void { /* empty */ }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            const texture = this.texture ?? this.particleChildren[0]?.texture;\n\n            if (texture)\n            {\n                texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this.texture = null;\n        this.shader?.destroy();\n    }\n\n    /**\n     * Removes all particles from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed particles\n     */\n    public removeParticles(beginIndex?: number, endIndex?: number)\n    {\n        const children = this.particleChildren.splice(beginIndex, endIndex);\n\n        this.onViewUpdate();\n\n        return children;\n    }\n\n    /**\n     * Removes a particle from the specified index position.\n     * @param index - The index to get the particle from\n     * @returns The particle that was removed.\n     */\n    public removeParticleAt<U extends IParticle>(index: number): U\n    {\n        const child = this.particleChildren.splice(index, 1);\n\n        this.onViewUpdate();\n\n        return child[0] as U;\n    }\n\n    /**\n     * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the particle is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The particle to add.\n     * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n     * @returns {Container} The particle that was added.\n     */\n    public addParticleAt<U extends IParticle>(child: U, index: number): U\n    {\n        this.particleChildren.splice(index, 0, child);\n\n        this.onViewUpdate();\n\n        return child;\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override addChild<U extends ContainerChild[]>(..._children: U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChild<U extends ContainerChild[]>(..._children: U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.\n     * @param {number} [_beginIndex]\n     * @param {number} [_endIndex]\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChildren(_beginIndex?: number, _endIndex?: number): ContainerChild[]\n    {\n        throw new Error(\n            'ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChildAt<U extends ContainerChild>(_index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override getChildAt<U extends ContainerChild>(_index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.\n     * @param {ContainerChild} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override setChildIndex(_child: ContainerChild, _index: number): void\n    {\n        throw new Error(\n            'ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.\n     * @param {ContainerChild} _child\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override getChildIndex(_child: ContainerChild): number\n    {\n        throw new Error(\n            'ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.\n     * @param {ContainerChild} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override addChildAt<U extends ContainerChild>(_child: U, _index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.\n     * @param {ContainerChild} _child\n     * @param {ContainerChild} _child2\n     */\n    public override swapChildren<U extends ContainerChild>(_child: U, _child2: U): void\n    {\n        throw new Error(\n            'ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()',\n        );\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override reparentChild(..._child: ContainerChild[]): any\n    {\n        throw new Error('ParticleContainer.reparentChild() is not available with the particle container');\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @param _index - The index to reparent the child to\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override reparentChildAt(_child: ContainerChild, _index: number): any\n    {\n        throw new Error('ParticleContainer.reparentChildAt() is not available with the particle container');\n    }\n}\n", "import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/ViewContainer';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `NineSliceSprite` instances.\n * ```js\n * const nineSliceSprite = new NineSliceSprite({\n *    texture: Texture.from('button.png'),\n *    leftWidth: 20,\n *    topHeight: 20,\n *    rightWidth: 20,\n *    bottomHeight: 20,\n * });\n * ```\n * @see {@link scene.NineSliceSprite}\n * @memberof scene\n */\nexport interface NineSliceSpriteOptions extends ContainerOptions\n{\n    /** The texture to use on the NineSliceSprite. */\n    texture: Texture;\n    /** Width of the left vertical bar (A) */\n    leftWidth?: number;\n    /** Height of the top horizontal bar (C) */\n    topHeight?: number;\n    /** Width of the right vertical bar (B) */\n    rightWidth?: number;\n    /** Height of the bottom horizontal bar (D) */\n    bottomHeight?: number;\n    /** Width of the NineSliceSprite, setting this will actually modify the vertices and not the UV's of this plane. */\n    width?: number;\n    /** Height of the NineSliceSprite, setting this will actually modify the vertices and not UV's of this plane. */\n    height?: number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The NineSliceSprite allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * import { NineSliceSprite, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSliceSprite(Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n * @memberof scene\n */\nexport class NineSliceSprite extends ViewContainer implements View\n{\n    /** The default options, used to override the initial values of any options passed in the constructor. */\n    public static defaultOptions: NineSliceSpriteOptions = {\n        /** @default Texture.EMPTY */\n        texture: Texture.EMPTY,\n    };\n\n    public override readonly renderPipeId: string = 'nineSliceSprite';\n    public _texture: Texture;\n\n    public batched = true;\n\n    private _leftWidth: number;\n    private _topHeight: number;\n    private _rightWidth: number;\n    private _bottomHeight: number;\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use\n     * @param options.texture - The texture to use on the NineSliceSprite.\n     * @param options.leftWidth - Width of the left vertical bar (A)\n     * @param options.topHeight - Height of the top horizontal bar (C)\n     * @param options.rightWidth - Width of the right vertical bar (B)\n     * @param options.bottomHeight - Height of the bottom horizontal bar (D)\n     * @param options.width - Width of the NineSliceSprite,\n     * setting this will actually modify the vertices and not the UV's of this plane.\n     * @param options.height - Height of the NineSliceSprite,\n     * setting this will actually modify the vertices and not UV's of this plane.\n     */\n    constructor(options: NineSliceSpriteOptions | Texture)\n    {\n        if ((options instanceof Texture))\n        {\n            options = { texture: options };\n        }\n\n        const {\n            width,\n            height,\n            leftWidth,\n            rightWidth,\n            topHeight,\n            bottomHeight,\n            texture,\n            roundPixels,\n            ...rest\n        } = options;\n\n        super({\n            label: 'NineSliceSprite',\n            ...rest\n        });\n\n        this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.defaultOptions.leftWidth;\n        this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.defaultOptions.topHeight;\n        this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.defaultOptions.rightWidth;\n        this._bottomHeight = bottomHeight\n                            ?? texture?.defaultBorders?.bottom\n                            ?? NineSliceGeometry.defaultOptions.bottomHeight;\n        this.bounds.maxX = this._width = width ?? texture.width ?? NineSliceGeometry.defaultOptions.width;\n        this.bounds.maxY = this._height = height ?? texture.height ?? NineSliceGeometry.defaultOptions.height;\n\n        this.allowChildren = false;\n        this.texture = texture ?? NineSliceSprite.defaultOptions.texture;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /** @private */\n    protected override updateBounds(): void { /* empty */ }\n\n    /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n    override get width(): number\n    {\n        return this._width;\n    }\n\n    override set width(value: number)\n    {\n        this.bounds.maxX = this._width = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */\n    override get height(): number\n    {\n        return this._height;\n    }\n\n    override set height(value: number)\n    {\n        this.bounds.maxY = this._height = value;\n        this.onViewUpdate();\n    }\n\n    /**\n     * Sets the size of the NiceSliceSprite to the specified width and height.\n     * setting this will actually modify the vertices and UV's of this plane\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this.bounds.maxX = this._width = value;\n        this.bounds.maxY = this._height = height ?? value;\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the NineSliceSprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    /** The width of the left column (a) of the NineSliceSprite. */\n    get leftWidth(): number\n    {\n        return this._leftWidth;\n    }\n\n    set leftWidth(value: number)\n    {\n        this._leftWidth = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get topHeight(): number\n    {\n        return this._topHeight;\n    }\n\n    set topHeight(value: number)\n    {\n        this._topHeight = value;\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get rightWidth(): number\n    {\n        return this._rightWidth;\n    }\n\n    set rightWidth(value: number)\n    {\n        this._rightWidth = value;\n        this.onViewUpdate();\n    }\n\n    /** The width of the right column (b) of the NineSliceSprite. */\n    get bottomHeight(): number\n    {\n        return this._bottomHeight;\n    }\n\n    set bottomHeight(value: number)\n    {\n        this._bottomHeight = value;\n        this.onViewUpdate();\n    }\n\n    /** The texture that the NineSliceSprite is using. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The original width of the texture */\n    get originalWidth()\n    {\n        return this._texture.width;\n    }\n\n    /** The original height of the texture */\n    get originalHeight()\n    {\n        return this._texture.height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n/**\n * Please use the `NineSliceSprite` class instead.\n * @deprecated since 8.0.0\n * @memberof scene\n */\nexport class NineSlicePlane extends NineSliceSprite\n{\n    constructor(options: NineSliceSpriteOptions | Texture);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, leftWidth: number, topHeight: number, rightWidth: number, bottomHeight: number);\n    constructor(...args: [NineSliceSpriteOptions | Texture] | [Texture, number, number, number, number])\n    {\n        let options = args[0];\n\n        if (options instanceof Texture)\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}');\n            // #endif\n\n            options = {\n                texture: options,\n                leftWidth: args[1],\n                topHeight: args[2],\n                rightWidth: args[3],\n                bottomHeight: args[4],\n            };\n        }\n\n        // #if _DEBUG\n        deprecation(v8_0_0, 'NineSlicePlane is deprecated. Use NineSliceSprite instead.');\n        // #endif\n\n        super(options);\n    }\n}\n", "import { HTMLTextStyle } from '../../text-html/HtmlTextStyle';\nimport { TextStyle } from '../TextStyle';\n\nimport type { HTMLTextStyleOptions } from '../../text-html/HtmlTextStyle';\nimport type { TextStyleOptions } from '../TextStyle';\n\n/**\n * converts the style input into the correct type of TextStyle\n * either HTMLTextStyle or TextStyle based on the renderMode.\n * @param renderMode - The render mode to use\n * @param style - The style to use\n * @returns - The style class\n */\nexport function ensureTextStyle(\n    renderMode: string,\n    style: TextStyle | HTMLTextStyle | TextStyleOptions | HTMLTextStyleOptions\n)\n{\n    if (style instanceof TextStyle || style instanceof HTMLTextStyle)\n    {\n        return style;\n    }\n\n    return renderMode === 'html'\n        ? new HTMLTextStyle(style)\n        : new TextStyle(style);\n}\n", "import type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../rendering/renderers/types';\n\n/**\n * Logs a texture to the console as a base64 image.\n * This can be very useful for debugging issues with rendering.\n * @param texture - The texture to log\n * @param renderer - The renderer to use\n * @param size - The size of the texture to log in the console\n * @ignore\n */\nexport async function logDebugTexture(texture: Texture, renderer: Renderer, size = 200)\n{\n    const base64 = await renderer.extract.base64(texture);\n\n    await renderer.encoder.commandFinished;\n\n    const width = size;\n\n    // eslint-disable-next-line no-console\n    console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);\n\n    const style = [\n        'font-size: 1px;',\n        `padding: ${width}px ${300}px;`,\n        `background: url(${base64}) no-repeat;`,\n        'background-size: contain;',\n    ].join(' ');\n\n    // eslint-disable-next-line no-console\n    console.log('%c ', style);\n}\n", "/* eslint-disable no-console */\n\nimport { Sprite } from '../../scene/sprite/Sprite';\n\nimport type { Container } from '../../scene/container/Container';\nimport type { RenderGroup } from '../../scene/container/RenderGroup';\n\nconst colors = [\n    '#000080', // Navy Blue\n    '#228B22', // Forest Green\n    '#8B0000', // Dark Red\n    '#4169E1', // Royal Blue\n    '#008080', // Teal\n    '#800000', // Maroon\n    '#9400D3', // Dark Violet\n    '#FF8C00', // Dark Orange\n    '#556B2F', // Olive Green\n    '#8B008B' // Dark Magenta\n];\n\nlet colorTick = 0;\n\nexport function logScene(container: Container, depth = 0, data: {color?: string} = { color: '#000000' })\n{\n    if (container.renderGroup)\n    {\n        data.color = colors[colorTick++];\n    }\n\n    //    turn depth into number of spaces:\n    let spaces = '';\n\n    for (let i = 0; i < depth; i++)\n    {\n        spaces += '    ';\n    }\n\n    let label = container.label;\n\n    if (!label && container instanceof Sprite)\n    {\n        label = `sprite:${container.texture.label}`;\n    }\n\n    // eslint-disable-next-line max-len\n    let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;\n\n    if (container.renderGroup)\n    {\n        output += ' (RenderGroup)';\n    }\n\n    if (container.filters)\n    {\n        output += '(*filters)';\n    }\n\n    console.log(output, `color:${data.color}; font-weight:bold;`);\n\n    depth++;\n\n    for (let i = 0; i < container.children.length; i++)\n    {\n        const child = container.children[i];\n\n        logScene(child, depth, { ...data });\n    }\n}\n\nexport function logRenderGroupScene(\n    renderGroup: RenderGroup, depth = 0,\n    data: {index: number, color?: string} = { index: 0, color: '#000000' }\n)\n{\n    // turn depth into number of spaces:\n    let spaces = '';\n\n    for (let i = 0; i < depth; i++)\n    {\n        spaces += '    ';\n    }\n\n    const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;\n\n    console.log(output, `color:${data.color}; font-weight:bold;`);\n\n    depth++;\n\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n    {\n        const child = renderGroup.renderGroupChildren[i];\n\n        logRenderGroupScene(child, depth, { ...data, index: i });\n    }\n}\n", "// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck - we dynamically create the other index files, so these will throw errors if we don't ignore them\n\nimport { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n"],
  "mappings": "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IAAK,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE;AAClE,QAAA,CAAC,IAAK,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE;AAClE,QAAA,CAAC,IAAK,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE;AAClE,QAAA,CAAC,IAAK,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE;AAClE,QAAA,CAAC,IAAK,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,CAAC,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAM,EAAE,CAAC,IAAI,EAAE,EAAE,IAAK,EAAE,CAAC;AAG1E,QAAA,EAAE,IAAK,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE;AACvE,QAAA,EAAE,IAAK,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE;AACvE,QAAA,EAAE,IAAK,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE;AACvE,QAAA,EAAE,IAAK,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,CAAC,IAAM,EAAE,EAAE,IAAI,EAAE,EAAE,IAAM,EA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",
  "names": ["source", "WebGPURenderer", "WebGLRenderer", "_Application", "i", "parser", "defaultValue", "source", "crossOrigin", "WORKER_CODE", "WORKER_URL", "WorkerInstance", "revokeObjectURL", "CheckImageBitmapWorker", "LoadImageBitmapWorker", "resolveResult", "_isWebGPUSupported", "_isWebGLSupported", "WORKER_CODE", "WORKER_URL", "WorkerInstance", "revokeObjectURL", "BasisWorker", "ktxWorker", "success", "DXGI_FORMAT", "D3D10_RESOURCE_DIMENSION", "D3DFMT", "GL_INTERNAL_FORMAT", "GL_FORMATS", "GL_TYPES", "WORKER_CODE", "WORKER_URL", "WorkerInstance", "revokeObjectURL", "urlHash", "KTXWorker", "ktxWorker", "gpuFormatToBasisTranscoderFormatMap", "supportedCompressedTextureFormats", "extensions", "_Culler", "_AlphaFilter", "vertex", "fragment", "source", "source", "_BlurFilterPass", "fragment", "source", "source", "fragment", "fragment", "vertex", "source", "vertex", "fragment", "source", "fragment", "source", "_NoiseFilter", "source", "fragment", "_PrepareBase", "_TilingSprite", "source", "source", "source", "MSAA_QUALITY", "DEPRECATED_WRAP_MODES", "DEPRECATED_SCALE_MODES", "_PerspectiveMesh", "_RopeGeometry", "_MeshRope", "_Particle", "_ParticleContainer", "_NineSliceSprite"]
}
